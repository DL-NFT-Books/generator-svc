//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_ea "bytes";_fg "encoding/xml";_e "errors";_cb "fmt";_ddg "github.com/gorilla/i18n/linebreak";_ec "github.com/unidoc/unichart/render";_cf "github.com/unidoc/unipdf/v3/common";_cc "github.com/unidoc/unipdf/v3/contentstream";_ggb "github.com/unidoc/unipdf/v3/contentstream/draw";
_a "github.com/unidoc/unipdf/v3/core";_fdd "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_edc "github.com/unidoc/unipdf/v3/internal/license";_faf "github.com/unidoc/unipdf/v3/internal/transform";_ddb "github.com/unidoc/unipdf/v3/model";_fd "golang.org/x/text/unicode/bidi";
_fa "image";_dd "io";_d "math";_c "os";_gb "regexp";_b "sort";_gg "strconv";_gga "strings";_g "text/template";_ed "unicode";);func _ffcbe (_ccee *_ddb .PdfRectangle ,_dfgaa _faf .Matrix )*_ddb .PdfRectangle {var _gcee _ddb .PdfRectangle ;_gcee .Llx ,_gcee .Lly =_dfgaa .Transform (_ccee .Llx ,_ccee .Lly );
_gcee .Urx ,_gcee .Ury =_dfgaa .Transform (_ccee .Urx ,_ccee .Ury );_gcee .Normalize ();return &_gcee ;};func (_ggc *Block )translate (_eb ,_eae float64 ){_ffb :=_cc .NewContentCreator ().Translate (_eb ,-_eae ).Operations ();*_ggc ._bb =append (*_ffb ,*_ggc ._bb ...);
_ggc ._bb .WrapIfNeeded ();};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_fgaf *Paragraph )SetMaxLines (maxLines int ){_fgaf ._dcad =maxLines ;_fgaf .wrapText ()};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_gagbb *Table )MultiColCell (colspan int )*TableCell {return _gagbb .MultiCell (1,colspan )};

// CreateFrontPage sets a function to generate a front Page.
func (_fefa *Creator )CreateFrontPage (genFrontPageFunc func (_fbda FrontpageFunctionArgs )){_fefa ._gfd =genFrontPageFunc ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_gdge float64 ;_befbf float64 ;_afbgf float64 ;_cdbg float64 ;_aedaf Positioning ;_gdac Color ;_eefdg Color ;_baeb float64 ;};func (_cafac *TextStyle )horizontalScale ()float64 {return _cafac .HorizontalScaling /100};func _ffab (_fffc int64 ,_cdge ,_cdcfd ,_fgadf float64 )*_ddb .PdfAnnotation {_feaf :=_ddb .NewPdfAnnotationLink ();
_bcbee :=_ddb .NewBorderStyle ();_bcbee .SetBorderWidth (0);_feaf .BS =_bcbee .ToPdfObject ();if _fffc < 0{_fffc =0;};_feaf .Dest =_a .MakeArray (_a .MakeInteger (_fffc ),_a .MakeName ("\u0058\u0059\u005a"),_a .MakeFloat (_cdge ),_a .MakeFloat (_cdcfd ),_a .MakeFloat (_fgadf ));
return _feaf .PdfAnnotation ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cgfb *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _cgfb ._dada [0],_cgfb ._dada [1]};

// Style returns the style of the line.
func (_daga *Line )Style ()_ggb .LineStyle {return _daga ._edeg };

// Height returns the height of the line.
func (_eadb *Line )Height ()float64 {_bafc :=_eadb ._ffae ;if _eadb ._bdbec ==_eadb ._faec {_bafc /=2;};return _d .Abs (_eadb ._abgf -_eadb ._fgbd )+_bafc ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;
);

// SetTerms sets the terms and conditions section of the invoice.
func (_abda *Invoice )SetTerms (title ,content string ){_abda ._dbdf =[2]string {title ,content }};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_cgf *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_cgf ._aefe .Left =left ;_cgf ._aefe .Right =right ;_cgf ._aefe .Top =top ;_cgf ._aefe .Bottom =bottom ;};func _bcbc (_cdf ,_aba *_ddb .PdfPageResources )error {_ddbg ,_ :=_cdf .GetColorspaces ();
if _ddbg !=nil &&len (_ddbg .Colorspaces )> 0{for _ggba ,_bcd :=range _ddbg .Colorspaces {_bdg :=*_a .MakeName (_ggba );if _aba .HasColorspaceByName (_bdg ){continue ;};_cea :=_aba .SetColorspaceByName (_bdg ,_bcd );if _cea !=nil {return _cea ;};};};return nil ;
};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_gcdd *Invoice )Sections ()[][2]string {return _gcdd ._fdbc };

// NewCurvePolygon creates a new curve polygon.
func (_dgggb *Creator )NewCurvePolygon (rings [][]_ggb .CubicBezierCurve )*CurvePolygon {return _dgac (rings );};

// SetLineColor sets the line color.
func (_agddf *Polyline )SetLineColor (color Color ){_agddf ._ecfd .LineColor =_ffad (color )};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_agca *Chapter )GetHeading ()*Paragraph {return _agca ._edf };

// The Image type is used to draw an image onto PDF.
type Image struct{_gebaa *_ddb .XObjectImage ;_aeaed *_ddb .Image ;_ddggf float64 ;_ddac ,_fdca float64 ;_cfcb ,_bbd float64 ;_bfee Positioning ;_egg HorizontalAlignment ;_afcd float64 ;_begb float64 ;_geedcc float64 ;_abbf Margins ;_efae ,_fgbg float64 ;
_dbgb _a .StreamEncoder ;_cagg FitMode ;};type componentRenderer interface{Draw (_aagaa Drawable )error ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_dcfa Drawable )(Drawable ,error );};func (_aece *InvoiceAddress )fmtLine (_ecae ,_bfbb string ,_gdgeb bool )string {if _gdgeb {_bfbb ="";};return _cb .Sprintf ("\u0025\u0073\u0025s\u000a",_bfbb ,_ecae );};

// SetTitle sets the title of the invoice.
func (_gabe *Invoice )SetTitle (title string ){_gabe ._caa =title };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        â€¢ This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_eefg []*listItem ;_fgfbf Margins ;_cfdc TextChunk ;_daedd float64 ;_dgbb bool ;_bfda Positioning ;_fgbe TextStyle ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_bcba *StyledParagraph )SetWidth (width float64 ){_bcba ._ceec =width ;_bcba .wrapText ()};

// SetBuyerAddress sets the buyer address of the invoice.
func (_gcca *Invoice )SetBuyerAddress (address *InvoiceAddress ){_gcca ._efbg =address };

// NewImageFromFile creates an Image from a file.
func (_cgcd *Creator )NewImageFromFile (path string )(*Image ,error ){return _adbd (path )};

// GetMargins returns the left, right, top, bottom Margins.
func (_adgc *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adgc ._edcc .Left ,_adgc ._edcc .Right ,_adgc ._edcc .Top ,_adgc ._edcc .Bottom ;};func (_egfa *StyledParagraph )getTextLineWidth (_ebga []*TextChunk )float64 {var _dcbed float64 ;
_acca :=len (_ebga );for _dbda ,_eebb :=range _ebga {_gdff :=&_eebb .Style ;_ffbca :=len (_eebb .Text );for _bede ,_fdad :=range _eebb .Text {if _fdad =='\u000A'{continue ;};_ecag ,_cgbb :=_gdff .Font .GetRuneMetrics (_fdad );if !_cgbb {_cf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fdad );
return -1;};_dcbed +=_gdff .FontSize *_ecag .Wx *_gdff .horizontalScale ();if _fdad !=' '&&(_dbda !=_acca -1||_bede !=_ffbca -1){_dcbed +=_gdff .CharSpacing *1000.0;};};};return _dcbed ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_eee *Creator )SetPageSize (size PageSize ){_eee ._ggbb =size ;_eee ._bedd =size [0];_eee ._edb =size [1];_deb :=0.1*_eee ._bedd ;_eee ._aefe .Left =_deb ;_eee ._aefe .Right =_deb ;_eee ._aefe .Top =_deb ;_eee ._aefe .Bottom =_deb ;};

// Columns returns all the columns in the invoice line items table.
func (_dggb *Invoice )Columns ()[]*InvoiceCell {return _dggb ._eeec };

// SetTotal sets the total of the invoice.
func (_ddad *Invoice )SetTotal (value string ){_ddad ._fddd [1].Value =value };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_eeaf _ec .ChartRenderable ;_egdc Positioning ;_eafe float64 ;_bdgba float64 ;_cfg Margins ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_ffff *TOC )SetShowLinks (showLinks bool ){_ffff ._gggcb =showLinks };

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_fagg *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _bgdfg (x1 ,y1 ,x2 ,y2 )};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_dgce *Chapter )SetShowNumbering (show bool ){_dgce ._bab =show ;_dgce ._edf .SetText (_dgce .headingText ());};

// SetNotes sets the notes section of the invoice.
func (_eebd *Invoice )SetNotes (title ,content string ){_eebd ._gade =[2]string {title ,content }};

// SetDate sets the date of the invoice.
func (_afge *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_afge ._dada [1].Value =date ;return _afge ._dada [0],_afge ._dada [1];};

// SetBorderColor sets the cell's border color.
func (_ffcbb *TableCell )SetBorderColor (col Color ){_ffcbb ._aggf =col ;_ffcbb ._cdbab =col ;_ffcbb ._ebfcg =col ;_ffcbb ._ddgga =col ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SellerAddress returns the seller address used in the invoice template.
func (_dcaag *Invoice )SellerAddress ()*InvoiceAddress {return _dcaag ._fdde };func (_fcgdb *templateProcessor )parseFloatArray (_eafd ,_feadb string )[]float64 {_cf .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_eafd ,_feadb );
_bccd :=_gga .Fields (_feadb );_aafa :=make ([]float64 ,0,len (_bccd ));for _ ,_aeeac :=range _bccd {_cegb ,_ :=_gg .ParseFloat (_aeeac ,64);_aafa =append (_aafa ,_cegb );};return _aafa ;};func (_dfbf *Invoice )generateInformationBlocks (_aaag DrawContext )([]*Block ,DrawContext ,error ){_cgfa :=_fgee (_dfbf ._dbecf );
_cgfa .SetMargins (0,0,0,20);_edcf :=_dfbf .drawAddress (_dfbf ._fdde );_edcf =append (_edcf ,_cgfa );_edcf =append (_edcf ,_dfbf .drawAddress (_dfbf ._efbg )...);_dccf :=_dbg ();for _ ,_gdfcg :=range _edcf {_dccf .Add (_gdfcg );};_efce :=_dfbf .drawInformation ();
_beeaa :=_abeacc (2);_beeaa .SetMargins (0,0,25,0);_ead :=_beeaa .NewCell ();_ead .SetIndent (0);_ead .SetContent (_dccf );_ead =_beeaa .NewCell ();_ead .SetContent (_efce );return _beeaa .GeneratePageBlocks (_aaag );};type templateProcessor struct{creator *Creator ;
_bcbe []byte ;_adfg *TemplateOptions ;_acad componentRenderer ;};

// SetAngle sets the rotation angle in degrees.
func (_cfc *Block )SetAngle (angleDeg float64 ){_cfc ._bf =angleDeg };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_dacc *Paragraph )Height ()float64 {_dacc .wrapText ();return float64 (len (_dacc ._bfbc ))*_dacc ._gggdb *_dacc ._fabb ;};func _gcfg (_cab string ,_ggcc _a .PdfObject ,_cga *_ddb .PdfPageResources )_a .PdfObjectName {_eaad :=_gga .TrimRightFunc (_gga .TrimSpace (_cab ),func (_ggg rune )bool {return _ed .IsNumber (_ggg )});
if _eaad ==""{_eaad ="\u0046\u006f\u006e\u0074";};_bga :=0;_gdg :=_a .PdfObjectName (_cab );for {_bcbcg ,_gab :=_cga .GetFontByName (_gdg );if !_gab ||_bcbcg ==_ggcc {break ;};_bga ++;_gdg =_a .PdfObjectName (_cb .Sprintf ("\u0025\u0073\u0025\u0064",_eaad ,_bga ));
};return _gdg ;};

// FitMode returns the fit mode of the image.
func (_fdcf *Image )FitMode ()FitMode {return _fdcf ._cagg };func (_dba rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _dba ._gafd ,_dba ._gfa ,_dba ._gcad };

// CurRow returns the currently active cell's row number.
func (_dcafa *Table )CurRow ()int {_acfc :=(_dcafa ._bdaaf -1)/_dcafa ._fdeb +1;return _acfc };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// Width returns Ellipse's document width.
func (_cdaag *Ellipse )Width ()float64 {return _cdaag ._afbgf };func _ffad (_fbdc Color )_ddb .PdfColor {if _fbdc ==nil {_fbdc =ColorBlack ;};switch _eaea :=_fbdc .(type ){case cmykColor :return _ddb .NewPdfColorDeviceCMYK (_eaea ._cdb ,_eaea ._daeg ,_eaea ._fdefb ,_eaea ._aedd );
};return _ddb .NewPdfColorDeviceRGB (_fbdc .ToRGB ());};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_effe *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _effe ._abbf .Left ,_effe ._abbf .Right ,_effe ._abbf .Top ,_effe ._abbf .Bottom ;};

// SetBorderWidth sets the border width.
func (_bdgc *Rectangle )SetBorderWidth (bw float64 ){_bdgc ._debge =bw };func (_egeee *templateProcessor )parseInt64Array (_gadeb ,_gbdb string )[]int64 {_cf .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gadeb ,_gbdb );
_cdbf :=_gga .Fields (_gbdb );_fggb :=make ([]int64 ,0,len (_cdbf ));for _ ,_bcce :=range _cdbf {_fbbcc ,_ :=_gg .ParseInt (_bcce ,10,64);_fggb =append (_fggb ,_fbbcc );};return _fggb ;};func (_fcceg *templateProcessor )parseStyledParagraph (_dfbbd *templateNode )(interface{},error ){_bgfcd :=_fcceg .creator .NewStyledParagraph ();
for _ ,_bggg :=range _dfbbd ._cgfe .Attr {_bccb :=_bggg .Value ;switch _agbee :=_bggg .Name .Local ;_agbee {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_bgfcd .SetTextAlignment (_fcceg .parseTextAlignmentAttr (_agbee ,_bccb ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_bgfcd .SetTextVerticalAlignment (_fcceg .parseTextVerticalAlignmentAttr (_agbee ,_bccb ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_bgfcd .SetLineHeight (_fcceg .parseFloatAttr (_agbee ,_bccb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ebdfd :=_fcceg .parseMarginAttr (_agbee ,_bccb );_bgfcd .SetMargins (_ebdfd .Left ,_ebdfd .Right ,_ebdfd .Top ,_ebdfd .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_bgfcd .SetEnableWrap (_fcceg .parseBoolAttr (_agbee ,_bccb ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_bgfcd .EnableWordWrap (_fcceg .parseBoolAttr (_agbee ,_bccb ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_bgfcd .SetTextOverflow (_fcceg .parseTextOverflowAttr (_agbee ,_bccb ));case "\u0078":_bgfcd .SetPos (_fcceg .parseFloatAttr (_agbee ,_bccb ),_bgfcd ._bggb );case "\u0079":_bgfcd .SetPos (_bgfcd ._acgd ,_fcceg .parseFloatAttr (_agbee ,_bccb ));
case "\u0061\u006e\u0067l\u0065":_bgfcd .SetAngle (_fcceg .parseFloatAttr (_agbee ,_bccb ));default:_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0073\u0074\u0079l\u0065\u0064 \u0070\u0061\u0072\u0061\u0067\u0072a\u0070h \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_agbee );
};};return _bgfcd ,nil ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_cdagc *Invoice )SetTitleStyle (style TextStyle ){_cdagc ._fea =style };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bbcb *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gfbac :=ctx ;_bdddb ,ctx ,_dagcc :=_bbcb ._aabbg .GeneratePageBlocks (ctx );if _dagcc !=nil {return _bdddb ,ctx ,_dagcc ;};if _bbcb ._caga .IsRelative (){ctx .X =_gfbac .X ;
};if _bbcb ._caga .IsAbsolute (){return _bdddb ,_gfbac ,nil ;};return _bdddb ,ctx ,nil ;};

// Append adds a new text chunk to the paragraph.
func (_bggcg *StyledParagraph )Append (text string )*TextChunk {_bfgg :=NewTextChunk (text ,_bggcg ._aebg );return _bggcg .appendChunk (_bfgg );};func _eaab (_fddcf *templateProcessor ,_bcgce *templateNode )(interface{},error ){return _fddcf .parseTextChunk (_bcgce );
};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ecg *Block )AddAnnotation (annotation *_ddb .PdfAnnotation ){for _ ,_ecgf :=range _ecg ._fb {if _ecgf ==annotation {return ;};};_ecg ._fb =append (_ecg ._fb ,annotation );};

// SetFillColor sets the fill color.
func (_dcfff *Polygon )SetFillColor (color Color ){_dcfff ._gcga .FillColor =_ffad (color )};func (_baba *pageTransformations )transformPage (_gea *_ddb .PdfPage )error {if _fff :=_baba .applyFlip (_gea );_fff !=nil {return _fff ;};return nil ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_aeage *Image )SetEncoder (encoder _a .StreamEncoder ){_aeage ._dbgb =encoder };

// Scale block by specified factors in the x and y directions.
func (_gfc *Block )Scale (sx ,sy float64 ){_gdf :=_cc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gfc ._bb =append (*_gdf ,*_gfc ._bb ...);_gfc ._bb .WrapIfNeeded ();_gfc ._af *=sx ;_gfc ._eag *=sy ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_geg *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faaf :=ctx ;if _geg ._fbc .IsRelative (){ctx .X +=_geg ._eeb .Left ;ctx .Y +=_geg ._eeb .Top ;ctx .Width -=_geg ._eeb .Left +_geg ._eeb .Right ;ctx .Height -=_geg ._eeb .Top ;
};_efg ,_ebgf ,_abcgd :=_geg ._edf .GeneratePageBlocks (ctx );if _abcgd !=nil {return _efg ,ctx ,_abcgd ;};ctx =_ebgf ;_gggd :=ctx .X ;_gff :=ctx .Y -_geg ._edf .Height ();_fadg :=int64 (ctx .Page );_aacc :=_geg .headingNumber ();_gdbe :=_geg .headingText ();
if _geg ._fedf {_dfa :=_geg ._gccb .Add (_aacc ,_geg ._bege ,_gg .FormatInt (_fadg ,10),_geg ._gagf );if _geg ._gccb ._gggcb {_dfa .SetLink (_fadg ,_gggd ,_gff );};};if _geg ._afbc ==nil {_geg ._afbc =_ddb .NewOutlineItem (_gdbe ,_ddb .NewOutlineDest (_fadg -1,_gggd ,_gff ));
if _geg ._dgg !=nil {_geg ._dgg ._afbc .Add (_geg ._afbc );}else {_geg ._age .Add (_geg ._afbc );};}else {_edce :=&_geg ._afbc .Dest ;_edce .Page =_fadg -1;_edce .X =_gggd ;_edce .Y =_gff ;};for _ ,_ggaf :=range _geg ._fade {_fgcd ,_faag ,_dabf :=_ggaf .GeneratePageBlocks (ctx );
if _dabf !=nil {return _efg ,ctx ,_dabf ;};if len (_fgcd )< 1{continue ;};_efg [len (_efg )-1].mergeBlocks (_fgcd [0]);_efg =append (_efg ,_fgcd [1:]...);ctx =_faag ;};if _geg ._fbc .IsRelative (){ctx .X =_faaf .X ;};if _geg ._fbc .IsAbsolute (){return _efg ,_faaf ,nil ;
};return _efg ,ctx ,nil ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_gacf []*_ddb .PdfPage ;_dfg map[*_ddb .PdfPage ]*Block ;_effb map[*_ddb .PdfPage ]*pageTransformations ;_ecfb *_ddb .PdfPage ;_ggbb PageSize ;_fda DrawContext ;_aefe Margins ;_bedd ,_edb float64 ;_dcf int ;_gfd func (_efcb FrontpageFunctionArgs );
_cgca func (_gcff *TOC )error ;_cbdb func (_daa *Block ,_ebef HeaderFunctionArgs );_dcb func (_cfb *Block ,_gdfg FooterFunctionArgs );_ada func (_gec PageFinalizeFunctionArgs )error ;_ebbd func (_bbg *_ddb .PdfWriter )error ;_ged bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_bcdf *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_dagd *_ddb .Outline ;_bedc *_ddb .PdfOutlineTreeNode ;_cdg *_ddb .PdfAcroForm ;_ecef _a .PdfObject ;_gbfd _ddb .Optimizer ;_ebec []*_ddb .PdfFont ;_abcf *_ddb .PdfFont ;_bgee *_ddb .PdfFont ;};func (_bbfb *Block )duplicate ()*Block {_gbf :=&Block {};
*_gbf =*_bbfb ;_bbfg :=_cc .ContentStreamOperations {};_bbfg =append (_bbfg ,*_bbfb ._bb ...);_gbf ._bb =&_bbfg ;return _gbf ;};

// SetFillColor sets background color for border.
func (_gca *border )SetFillColor (col Color ){_gca ._dda =col };func (_ffed *Invoice )newCell (_egea string ,_fccbe InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_fccbe ,_egea };};func (_dfcd *List )tableHeight (_agag float64 )float64 {var _dgaf float64 ;
for _ ,_afabe :=range _dfcd ._eefg {switch _cadb :=_afabe ._debeb .(type ){case *Paragraph :_gcbd :=_cadb ;if _gcbd ._ccad {_gcbd .SetWidth (_agag );};_dgaf +=_gcbd .Height ()+_gcbd ._ceadb .Bottom +_gcbd ._ceadb .Bottom ;_dgaf +=0.5*_gcbd ._fabb *_gcbd ._gggdb ;
case *StyledParagraph :_efgb :=_cadb ;if _efgb ._bfba {_efgb .SetWidth (_agag );};_dgaf +=_efgb .Height ()+_efgb ._ebgb .Top +_efgb ._ebgb .Bottom ;_dgaf +=0.5*_efgb .getTextHeight ();default:_dgaf +=_afabe ._debeb .Height ();};};return _dgaf ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_eecg *Creator )RotateDeg (angleDeg int64 )error {_gad :=_eecg .getActivePage ();if _gad ==nil {_cf .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_cf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _ced int64 ;if _gad .Rotate !=nil {_ced =*(_gad .Rotate );};_ced +=angleDeg ;_gad .Rotate =&_ced ;return nil ;};

// SetFontSize sets the font size in document units (points).
func (_eeef *Paragraph )SetFontSize (fontSize float64 ){_eeef ._fabb =fontSize };

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
func (_ffbc *Division )Add (d VectorDrawable )error {switch _fgdac :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division :case containerDrawable :_gegg ,_bbgb :=_fgdac .ContainerComponent (_ffbc );
if _bbgb !=nil {return _bbgb ;};_dagb ,_fbdd :=_gegg .(VectorDrawable );if !_fbdd {return _cb .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_gegg );
};d =_dagb ;default:return _e .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_ffbc ._bfcd =append (_ffbc ._bfcd ,d );return nil ;};

// SetSideBorderColor sets the cell's side border color.
func (_ccgb *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_ccgb ._ddgga =col ;_ccgb ._cdbab =col ;_ccgb ._aggf =col ;_ccgb ._ebfcg =col ;case CellBorderSideTop :_ccgb ._ddgga =col ;case CellBorderSideBottom :_ccgb ._cdbab =col ;
case CellBorderSideLeft :_ccgb ._aggf =col ;case CellBorderSideRight :_ccgb ._ebfcg =col ;};};func (_dfbe *Invoice )drawSection (_edfa ,_adgd string )[]*StyledParagraph {var _aadg []*StyledParagraph ;if _edfa !=""{_dacb :=_fgee (_dfbe ._fbaa );_dacb .SetMargins (0,0,0,5);
_dacb .Append (_edfa );_aadg =append (_aadg ,_dacb );};if _adgd !=""{_egce :=_fgee (_dfbe ._egfb );_egce .Append (_adgd );_aadg =append (_aadg ,_egce );};return _aadg ;};

// SetFillColor sets the fill color for the path.
func (_cfae *FilledCurve )SetFillColor (color Color ){_cfae ._fefb =color };

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_gafd :float64 (r )/255.0,_gfa :float64 (g )/255.0,_gcad :float64 (b )/255.0};};func _gcaf (_gadcf *templateProcessor ,_fbcd *templateNode )(interface{},error ){return _gadcf .parseChapterHeading (_fbcd );
};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_eeee *Creator )PageFinalize (pageFinalizeFunc func (_aega PageFinalizeFunctionArgs )error ){_eeee ._ada =pageFinalizeFunc ;};func (_ccdg *Image )rotatedSize ()(float64 ,float64 ){_addd :=_ccdg ._ddac ;_dgb :=_ccdg ._fdca ;_abfg :=_ccdg ._ddggf ;
if _abfg ==0{return _addd ,_dgb ;};_dege :=_ggb .Path {Points :[]_ggb .Point {_ggb .NewPoint (0,0).Rotate (_abfg ),_ggb .NewPoint (_addd ,0).Rotate (_abfg ),_ggb .NewPoint (0,_dgb ).Rotate (_abfg ),_ggb .NewPoint (_addd ,_dgb ).Rotate (_abfg )}}.GetBoundingBox ();
return _dege .Width ,_dege .Height ;};func (_fgfc *StyledParagraph )appendChunk (_bceb *TextChunk )*TextChunk {_fgfc ._fgbgc =append (_fgfc ._fgbgc ,_bceb );_fgfc .wrapText ();return _bceb ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_gaee *Invoice )TitleStyle ()TextStyle {return _gaee ._fea };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_ffec *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_fdedc :=range subtable ._edeebg {_cfgcd :=&TableCell {};*_cfgcd =*_fdedc ;_cfgcd ._bbccb =_ffec ;_cfgcd ._fbcc +=col -1;if _dbdg :=_ffec ._fdeb -(_cfgcd ._fbcc -1);_dbdg < _cfgcd ._dagag {_ffec ._fdeb +=_cfgcd ._dagag -_dbdg ;
_ffec .resetColumnWidths ();_cf .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_ffec ._fdeb );
};_cfgcd ._gdfb +=row -1;_gfee :=subtable ._fcga [_fdedc ._gdfb -1];if _cfgcd ._gdfb > _ffec ._aceec {for _cfgcd ._gdfb > _ffec ._aceec {_ffec ._aceec ++;_ffec ._fcga =append (_ffec ._fcga ,_ffec ._baegf );};_ffec ._fcga [_cfgcd ._gdfb -1]=_gfee ;}else {_ffec ._fcga [_cfgcd ._gdfb -1]=_d .Max (_ffec ._fcga [_cfgcd ._gdfb -1],_gfee );
};_ffec ._edeebg =append (_ffec ._edeebg ,_cfgcd );};_b .Slice (_ffec ._edeebg ,func (_cebc ,_cfee int )bool {_cffad :=_ffec ._edeebg [_cebc ]._gdfb ;_cdba :=_ffec ._edeebg [_cfee ]._gdfb ;if _cffad < _cdba {return true ;};if _cffad > _cdba {return false ;
};return _ffec ._edeebg [_cebc ]._fbcc < _ffec ._edeebg [_cfee ]._fbcc ;});};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_ccdaf *Table )SetPos (x ,y float64 ){_ccdaf ._afbd =PositionAbsolute ;_ccdaf ._daaaa =x ;_ccdaf ._adgf =y ;};func (_aagg *templateProcessor )parseFloatAttr (_ceggd ,_agbf string )float64 {_cf .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_ceggd ,_agbf );
_gbcb ,_ :=_gg .ParseFloat (_agbf ,64);return _gbcb ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bfgd *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _bfgd ._fddd [0],_bfgd ._fddd [1]};

// SetSideBorderStyle sets the cell's side border style.
func (_bgabb *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_bgabb ._dcbb =style ;_bgabb ._gbaf =style ;_bgabb ._fcbf =style ;_bgabb ._dfdba =style ;case CellBorderSideTop :_bgabb ._dcbb =style ;
case CellBorderSideBottom :_bgabb ._gbaf =style ;case CellBorderSideLeft :_bgabb ._fcbf =style ;case CellBorderSideRight :_bgabb ._dfdba =style ;};};

// Width returns Rectangle's document width.
func (_aaea *Rectangle )Width ()float64 {return _aaea ._bfde };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func (_eacgdf *templateProcessor )parseBackground (_eaaf *templateNode )(interface{},error ){_egcb :=&Background {};for _ ,_gceab :=range _eaaf ._cgfe .Attr {_adbeb :=_gceab .Value ;switch _ffade :=_gceab .Name .Local ;
_ffade {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_egcb .FillColor =_eacgdf .parseColorAttr (_ffade ,_adbeb );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_egcb .BorderColor =_eacgdf .parseColorAttr (_ffade ,_adbeb );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_egcb .BorderSize =_eacgdf .parseFloatAttr (_ffade ,_adbeb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_fgfbc ,_dgbee ,_ddace ,_babd :=_eacgdf .parseBorderRadiusAttr (_ffade ,_adbeb );
_egcb .SetBorderRadius (_fgfbc ,_dgbee ,_babd ,_ddace );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_egcb .BorderRadiusTopLeft =_eacgdf .parseFloatAttr (_ffade ,_adbeb );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_egcb .BorderRadiusTopRight =_eacgdf .parseFloatAttr (_ffade ,_adbeb );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_egcb .BorderRadiusBottomLeft =_eacgdf .parseFloatAttr (_ffade ,_adbeb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_egcb .BorderRadiusBottomRight =_eacgdf .parseFloatAttr (_ffade ,_adbeb );
default:_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ffade );
};};return _egcb ,nil ;};func (_dbdfg *Table )wrapRow (_gacfd int ,_cgab DrawContext ,_bfgda float64 )(bool ,error ){if !_dbdfg ._fgge {return false ,nil ;};var (_bcea =_dbdfg ._edeebg [_gacfd ];_dbaga =-1;_agfee []*TableCell ;_ecafe float64 ;_dfcfe bool ;
_cded =make ([]float64 ,0,len (_dbdfg ._fefbb )););_ffced :=func (_dggd *TableCell ,_gddc VectorDrawable ,_fcff bool )*TableCell {_cebg :=*_dggd ;_cebg ._ffbee =_gddc ;if _fcff {_cebg ._gdfb ++;};return &_cebg ;};_fcggc :=func (_bgeee int ,_gddcf VectorDrawable ){var _accb float64 =-1;
if _gddcf ==nil {if _cdce :=_cded [_bgeee -_gacfd ];_cdce > _cgab .Height {_gddcf =_dbdfg ._edeebg [_bgeee ]._ffbee ;_dbdfg ._edeebg [_bgeee ]._ffbee =nil ;_cded [_bgeee -_gacfd ]=0;_accb =_cdce ;};};_agbe :=_ffced (_dbdfg ._edeebg [_bgeee ],_gddcf ,true );
_agfee =append (_agfee ,_agbe );if _accb < 0{_accb =_agbe .height (_cgab .Width );};if _accb > _ecafe {_ecafe =_accb ;};};for _dcgef :=_gacfd ;_dcgef < len (_dbdfg ._edeebg );_dcgef ++{_fggfcf :=_dbdfg ._edeebg [_dcgef ];if _bcea ._gdfb !=_fggfcf ._gdfb {_dbaga =_dcgef ;
break ;};_cgab .Width =_fggfcf .width (_dbdfg ._fefbb ,_bfgda );var _dcbde VectorDrawable ;switch _ggeaf :=_fggfcf ._ffbee .(type ){case *StyledParagraph :if _agdg :=_fggfcf .height (_cgab .Width );_agdg > _cgab .Height {_gffb :=_cgab ;_gffb .Height =_d .Floor (_cgab .Height -_ggeaf ._ebgb .Top -_ggeaf ._ebgb .Bottom -0.5*_ggeaf .getTextHeight ());
_ddga ,_ggacb ,_fege :=_ggeaf .split (_gffb );if _fege !=nil {return false ,_fege ;};if _ddga !=nil &&_ggacb !=nil {_ggeaf =_ddga ;_fggfcf =_ffced (_fggfcf ,_ddga ,false );_dbdfg ._edeebg [_dcgef ]=_fggfcf ;_dcbde =_ggacb ;_dfcfe =true ;};};case *Division :if _bbdfa :=_fggfcf .height (_cgab .Width );
_bbdfa > _cgab .Height {_bcgb :=_cgab ;_bcgb .Height =_d .Floor (_cgab .Height -_ggeaf ._acdf .Top -_ggeaf ._acdf .Bottom );_facfd ,_geef :=_ggeaf .split (_bcgb );if _facfd !=nil &&_geef !=nil {_ggeaf =_facfd ;_fggfcf =_ffced (_fggfcf ,_facfd ,false );
_dbdfg ._edeebg [_dcgef ]=_fggfcf ;_dcbde =_geef ;_dfcfe =true ;if _facfd ._egfcb !=nil {_facfd ._egfcb .BorderRadiusBottomLeft =0;_facfd ._egfcb .BorderRadiusBottomRight =0;};if _geef ._egfcb !=nil {_geef ._egfcb .BorderRadiusTopLeft =0;_geef ._egfcb .BorderRadiusTopRight =0;
};};};};_cded =append (_cded ,_fggfcf .height (_cgab .Width ));if _dfcfe {if _agfee ==nil {_agfee =make ([]*TableCell ,0,len (_dbdfg ._fefbb ));for _edcb :=_gacfd ;_edcb < _dcgef ;_edcb ++{_fcggc (_edcb ,nil );};};_fcggc (_dcgef ,_dcbde );};};var _bgacf float64 ;
for _ ,_bagc :=range _cded {if _bagc > _bgacf {_bgacf =_bagc ;};};if _dfcfe &&_bgacf < _cgab .Height {if _dbaga < 0{_dbaga =len (_dbdfg ._edeebg );};_bdac :=_dbdfg ._edeebg [_dbaga -1]._gdfb +_dbdfg ._edeebg [_dbaga -1]._fgfbg -1;for _faagb :=_dbaga ;_faagb < len (_dbdfg ._edeebg );
_faagb ++{_dbdfg ._edeebg [_faagb ]._gdfb ++;};_dbdfg ._edeebg =append (_dbdfg ._edeebg [:_dbaga ],append (_agfee ,_dbdfg ._edeebg [_dbaga :]...)...);_dbdfg ._fcga =append (_dbdfg ._fcga [:_bdac ],append ([]float64 {_ecafe },_dbdfg ._fcga [_bdac :]...)...);
_dbdfg ._fcga [_bcea ._gdfb +_bcea ._fgfbg -2]=_bgacf ;};return _dfcfe ,nil ;};

// SetDueDate sets the due date of the invoice.
func (_aacgf *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_aacgf ._fegd [1].Value =dueDate ;return _aacgf ._fegd [0],_aacgf ._fegd [1];};const (DefaultHorizontalScaling =100;);

// SetNumber sets the number of the invoice.
func (_cfaa *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_cfaa ._adfd [1].Value =number ;return _cfaa ._adfd [0],_cfaa ._adfd [1];};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_fffe *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_babed :=NewTextChunk (text ,_fffe ._bgafb );_babed ._acdb =_becf (url );return _fffe .appendChunk (_babed );};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// SetLevel sets the indentation level of the TOC line.
func (_ffdg *TOCLine )SetLevel (level uint ){_ffdg ._aaaa =level ;_ffdg ._aabbg ._ebgb .Left =_ffdg ._fcgb +float64 (_ffdg ._aaaa -1)*_ffdg ._eaede ;};

// SetBorderColor sets border color.
func (_gcebf *Rectangle )SetBorderColor (col Color ){_gcebf ._ebdcg =col };func (_agfe *StyledParagraph )getTextHeight ()float64 {var _fgfec float64 ;for _ ,_dbeda :=range _agfe ._fgbgc {_dggf :=_dbeda .Style .FontSize *_agfe ._ccfgg ;if _dggf > _fgfec {_fgfec =_dggf ;
};};return _fgfec ;};func _gbba (_efag *_ddb .PdfAnnotation )*_ddb .PdfAnnotation {if _efag ==nil {return nil ;};var _bcad *_ddb .PdfAnnotation ;switch _bdbda :=_efag .GetContext ().(type ){case *_ddb .PdfAnnotationLink :if _fabcc :=_ecage (_bdbda );_fabcc !=nil {_bcad =_fabcc .PdfAnnotation ;
};};return _bcad ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bebf *Creator )NewPolyBezierCurve (curves []_ggb .CubicBezierCurve )*PolyBezierCurve {return _fead (curves );};func _dbg ()*Division {return &Division {_aeae :true }};

// SetFillOpacity sets the fill opacity.
func (_ecbf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_ecbf ._fggfc =opacity };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_aaefc *Table )NewCell ()*TableCell {return _aaefc .MultiCell (1,1)};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_fgefg *TOCLine )SetStyle (style TextStyle ){_fgefg .Number .Style =style ;_fgefg .Title .Style =style ;_fgefg .Separator .Style =style ;_fgefg .Page .Style =style ;};

// SetBorderWidth sets the border width.
func (_cgedbb *Polygon )SetBorderWidth (borderWidth float64 ){_cgedbb ._gcga .BorderWidth =borderWidth };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_eedg float64 ;_gfea float64 ;_bfde float64 ;_adfff float64 ;_abgg Positioning ;_aeddb Color ;_ccbd float64 ;_ebdcg Color ;_debge float64 ;_dcdd float64 ;_abcgb float64 ;_aaedc float64 ;_abcdf float64 ;_febab float64 ;};func _abbcf (_cfagd string )([]string ,error ){var (_bebge []string ;
_daced []rune ;);for _ ,_gbce :=range _cfagd {if _gbce =='\u000A'{if len (_daced )> 0{_bebge =append (_bebge ,string (_daced ));};_bebge =append (_bebge ,string (_gbce ));_daced =nil ;continue ;};_daced =append (_daced ,_gbce );};if len (_daced )> 0{_bebge =append (_bebge ,string (_daced ));
};var _dfbff []string ;for _ ,_edfd :=range _bebge {_deeg :=[]rune (_edfd );_eacf :=_ddg .NewScanner (_deeg );var _aeeae []rune ;for _acfce :=0;_acfce < len (_deeg );_acfce ++{_ ,_bgacb ,_cdaac :=_eacf .Next ();if _cdaac !=nil {return nil ,_cdaac ;};if _bgacb ==_ddg .BreakProhibited ||_ed .IsSpace (_deeg [_acfce ]){_aeeae =append (_aeeae ,_deeg [_acfce ]);
if _ed .IsSpace (_deeg [_acfce ]){_dfbff =append (_dfbff ,string (_aeeae ));_aeeae =[]rune {};};continue ;}else {if len (_aeeae )> 0{_dfbff =append (_dfbff ,string (_aeeae ));};_aeeae =[]rune {_deeg [_acfce ]};};};if len (_aeeae )> 0{_dfbff =append (_dfbff ,string (_aeeae ));
};};return _dfbff ,nil ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_geaf *Image )SetWidth (w float64 ){_geaf ._ddac =w };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_debc *Creator )NewTextStyle ()TextStyle {return _abge (_debc ._abcf )};

// LineWidth returns the width of the line.
func (_dcbeg *Line )LineWidth ()float64 {return _dcbeg ._ffae };

// SetFillColor sets the fill color.
func (_dbbe *CurvePolygon )SetFillColor (color Color ){_dbbe ._efdg .FillColor =_ffad (color )};

// BuyerAddress returns the buyer address used in the invoice template.
func (_aedab *Invoice )BuyerAddress ()*InvoiceAddress {return _aedab ._efbg };type rgbColor struct{_gafd ,_gfa ,_gcad float64 };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};func (_bacdc *templateProcessor )parseHorizontalAlignmentAttr (_afegc ,_agdgf string )HorizontalAlignment {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_afegc ,_agdgf );
_fgbdc :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_agdgf ];return _fgbdc ;};

// SetBorderOpacity sets the border opacity.
func (_dfac *CurvePolygon )SetBorderOpacity (opacity float64 ){_dfac ._cdaaa =opacity };func (_dga *pageTransformations )transformBlock (_dbfc *Block ){if _dga ._befe !=nil {_dbfc .transform (*_dga ._befe );};};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_dee Color ;_bcffc _ggb .LineStyle ;_fcbf CellBorderStyle ;_aggf Color ;_aecd float64 ;_gbaf CellBorderStyle ;_cdbab Color ;_ecaegf float64 ;_dfdba CellBorderStyle ;_ebfcg Color ;_deff float64 ;_dcbb CellBorderStyle ;_ddgga Color ;
_caca float64 ;_gdfb ,_fbcc int ;_fgfbg int ;_dagag int ;_ffbee VectorDrawable ;_ggbg CellHorizontalAlignment ;_gdddf CellVerticalAlignment ;_geag float64 ;_bbccb *Table ;};

// SetFillOpacity sets the fill opacity.
func (_cfbaf *Polygon )SetFillOpacity (opacity float64 ){_cfbaf ._fabae =opacity };

// IsAbsolute checks if the positioning is absolute.
func (_dfdg Positioning )IsAbsolute ()bool {return _dfdg ==PositionAbsolute };

// SetPos sets absolute positioning with specified coordinates.
func (_fffgb *StyledParagraph )SetPos (x ,y float64 ){_fffgb ._egbce =PositionAbsolute ;_fffgb ._acgd =x ;_fffgb ._bggb =y ;};func (_feae *TableCell )cloneProps (_fddc VectorDrawable )*TableCell {_dcae :=*_feae ;_dcae ._ffbee =_fddc ;return &_dcae ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_fcbe *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fabf []*Block ;_dcfce bool ;_aebb error ;_cgea =_fcbe ._effbb .IsRelative ();_gfdf =_fcbe ._acdf .Top ;);if _cgea &&!_fcbe ._aeae &&!_fcbe ._bbee {_gcge :=_fcbe .ctxHeight (ctx .Width );
if _gcge > ctx .Height -_fcbe ._acdf .Top &&_gcge <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _fabf ,ctx ,_aebb =_ggcgd ().GeneratePageBlocks (ctx );_aebb !=nil {return nil ,ctx ,_aebb ;};_dcfce =true ;_gfdf =0;};};_ebc :=ctx ;_gegb :=ctx ;
if _cgea {ctx .X +=_fcbe ._acdf .Left ;ctx .Y +=_gfdf ;ctx .Width -=_fcbe ._acdf .Left +_fcbe ._acdf .Right ;ctx .Height -=_gfdf ;_gegb =ctx ;ctx .X +=_fcbe ._acbg .Left ;ctx .Y +=_fcbe ._acbg .Top ;ctx .Width -=_fcbe ._acbg .Left +_fcbe ._acbg .Right ;
ctx .Height -=_fcbe ._acbg .Top ;ctx .Margins .Top +=_fcbe ._acbg .Top ;ctx .Margins .Bottom +=_fcbe ._acbg .Bottom ;ctx .Margins .Left +=_fcbe ._acdf .Left +_fcbe ._acbg .Left ;ctx .Margins .Right +=_fcbe ._acdf .Right +_fcbe ._acbg .Right ;};ctx .Inline =_fcbe ._bbee ;
_bbcc :=ctx ;_addg :=ctx ;var _fgfgg float64 ;for _ ,_daegb :=range _fcbe ._bfcd {if ctx .Inline {if (ctx .X -_bbcc .X )+_daegb .Width ()<=ctx .Width {ctx .Y =_addg .Y ;ctx .Height =_addg .Height ;}else {ctx .X =_bbcc .X ;ctx .Width =_bbcc .Width ;_addg .Y +=_fgfgg ;
_addg .Height -=_fgfgg ;_fgfgg =0;};};_beae ,_aeaf ,_cddb :=_daegb .GeneratePageBlocks (ctx );if _cddb !=nil {_cf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_cddb );
return nil ,ctx ,_cddb ;};if len (_beae )< 1{continue ;};if len (_fabf )> 0{_fabf [len (_fabf )-1].mergeBlocks (_beae [0]);_fabf =append (_fabf ,_beae [1:]...);}else {if _ffca :=_beae [0]._bb ;_ffca ==nil ||len (*_ffca )==0{_dcfce =true ;};_fabf =append (_fabf ,_beae [0:]...);
};if ctx .Inline {if ctx .Page !=_aeaf .Page {_bbcc .Y =ctx .Margins .Top ;_bbcc .Height =ctx .PageHeight -ctx .Margins .Top ;_addg .Y =_bbcc .Y ;_addg .Height =_bbcc .Height ;_fgfgg =_aeaf .Height -_bbcc .Height ;}else {if _egdae :=ctx .Height -_aeaf .Height ;
_egdae > _fgfgg {_fgfgg =_egdae ;};};}else {_aeaf .X =ctx .X ;};ctx =_aeaf ;};ctx .Inline =_ebc .Inline ;ctx .Margins =_ebc .Margins ;if _cgea {ctx .X =_ebc .X ;ctx .Width =_ebc .Width ;ctx .Y +=_fcbe ._acbg .Bottom ;ctx .Height -=_fcbe ._acbg .Bottom ;
};if _fcbe ._egfcb !=nil {_fabf ,_aebb =_fcbe .drawBackground (_fabf ,_gegb ,ctx ,_dcfce );if _aebb !=nil {return nil ,ctx ,_aebb ;};};if _fcbe ._effbb .IsAbsolute (){return _fabf ,_ebc ,nil ;};ctx .Y +=_fcbe ._acdf .Bottom ;ctx .Height -=_fcbe ._acdf .Bottom ;
return _fabf ,ctx ,nil ;};type listItem struct{_debeb VectorDrawable ;_dbed TextChunk ;};func _eafg (_ffd [][]_ggb .Point )*Polygon {return &Polygon {_gcga :&_ggb .Polygon {Points :_ffd },_fabae :1.0,_adbf :1.0};};func _dgbf (_adda *templateProcessor ,_bdgcd *templateNode )(interface{},error ){return _adda .parseChart (_bdgcd );
};func _gebg (_cbga *_ddb .Image )(*Image ,error ){_fccd :=float64 (_cbga .Width );_bffeg :=float64 (_cbga .Height );return &Image {_aeaed :_cbga ,_cfcb :_fccd ,_bbd :_bffeg ,_ddac :_fccd ,_fdca :_bffeg ,_ddggf :0,_geedcc :1.0,_bfee :PositionRelative },nil ;
};func _gfgd (_fadb ,_gbec ,_ffbaa ,_gabce float64 )*Rectangle {return &Rectangle {_eedg :_fadb ,_gfea :_gbec ,_bfde :_ffbaa ,_adfff :_gabce ,_ebdcg :ColorBlack ,_debge :1.0,_ccbd :1.0,_dcdd :1.0,_abgg :PositionAbsolute };};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_bcfb *TOC )SetLineStyle (style TextStyle ){_bcfb .SetLineNumberStyle (style );_bcfb .SetLineTitleStyle (style );_bcfb .SetLineSeparatorStyle (style );_bcfb .SetLinePageStyle (style );};

// Width returns the cell's width based on the input draw context.
func (_abeg *TableCell )Width (ctx DrawContext )float64 {_ggcab :=float64 (0.0);for _bfcga :=0;_bfcga < _abeg ._dagag ;_bfcga ++{_ggcab +=_abeg ._bbccb ._fefbb [_abeg ._fbcc +_bfcga -1];};_facfe :=ctx .Width *_ggcab ;return _facfe ;};type pageTransformations struct{_befe *_faf .Matrix ;
_cec bool ;_cdc bool ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_fegdd *Paragraph )SetEnableWrap (enableWrap bool ){_fegdd ._ccad =enableWrap ;_fegdd ._fcdd =false ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_bac *Image )GetHorizontalAlignment ()HorizontalAlignment {return _bac ._egg };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_fdab *TOCLine )SetLink (page int64 ,x ,y float64 ){_fdab ._added =x ;_fdab ._ecdf =y ;_fdab ._efgbg =page ;_ggccf :=_fdab ._aabbg ._bgafb .Color ;_fdab .Number .Style .Color =_ggccf ;_fdab .Title .Style .Color =_ggccf ;_fdab .Separator .Style .Color =_ggccf ;
_fdab .Page .Style .Color =_ggccf ;};

// SetBorderOpacity sets the border opacity.
func (_bddg *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_bddg ._babf =opacity };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_adf *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _adf ._bgd .Left ,_adf ._bgd .Right ,_adf ._bgd .Top ,_adf ._bgd .Bottom ;};

// SetOpacity sets opacity for Image.
func (_afcc *Image )SetOpacity (opacity float64 ){_afcc ._geedcc =opacity };func (_aacg *Creator )setActivePage (_beef *_ddb .PdfPage ){_aacg ._ecfb =_beef };func _ggdd (_aecg string ,_ffac bool )string {_ddbe :=_aecg ;if _ddbe ==""{return "";};_ecgc :=_fd .Paragraph {};
_ ,_eede :=_ecgc .SetString (_aecg );if _eede !=nil {return _ddbe ;};_dgagg ,_eede :=_ecgc .Order ();if _eede !=nil {return _ddbe ;};_bbaac :=_dgagg .NumRuns ();_bfdc :=make ([]string ,_bbaac );for _bdbag :=0;_bdbag < _dgagg .NumRuns ();_bdbag ++{_edeee :=_dgagg .Run (_bdbag );
_cbgca :=_edeee .String ();if _edeee .Direction ()==_fd .RightToLeft {_cbgca =_fd .ReverseString (_cbgca );};if _ffac {_bfdc [_bdbag ]=_cbgca ;}else {_bfdc [_bbaac -1]=_cbgca ;};_bbaac --;};if len (_bfdc )!=_dgagg .NumRuns (){return _aecg ;};_ddbe =_gga .Join (_bfdc ,"");
return _ddbe ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_fded *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_fbbe :=_fgee (_fded ._fgbe );_fbbe .Append (text );_ebfc ,_edbd :=_fded .Add (_fbbe );return _fbbe ,_ebfc ,_edbd ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ecbg *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gffeg :=ctx ;_bdbdc ,ctx ,_gdcba :=_ecbg ._dacd .GeneratePageBlocks (ctx );if _gdcba !=nil {return _bdbdc ,ctx ,_gdcba ;};for _ ,_gbge :=range _ecbg ._dacda {_afgda :=_gbge ._efgbg ;
if !_ecbg ._gggcb {_gbge ._efgbg =0;};_cfcg ,_fbffd ,_gaag :=_gbge .GeneratePageBlocks (ctx );_gbge ._efgbg =_afgda ;if _gaag !=nil {return _bdbdc ,ctx ,_gaag ;};if len (_cfcg )< 1{continue ;};_bdbdc [len (_bdbdc )-1].mergeBlocks (_cfcg [0]);_bdbdc =append (_bdbdc ,_cfcg [1:]...);
ctx =_fbffd ;};if _ecbg ._bcgcg .IsRelative (){ctx .X =_gffeg .X ;};if _ecbg ._bcgcg .IsAbsolute (){return _bdbdc ,_gffeg ,nil ;};return _bdbdc ,ctx ,nil ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_ddb .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_afb :=&Block {};_afb ._bb =&_cc .ContentStreamOperations {};_afb ._ad =_ddb .NewPdfPageResources ();_afb ._af =width ;_afb ._eag =height ;return _afb ;};func _abccd (_acgg string )bool {_gaga :=func (_ccdgd rune )bool {return _ccdgd =='\u000A'};
_cccc :=_gga .TrimFunc (_acgg ,_gaga );_bgegg :=_fd .Paragraph {};_ ,_fbaaed :=_bgegg .SetString (_cccc );if _fbaaed !=nil {return true ;};_efgdd ,_fbaaed :=_bgegg .Order ();if _fbaaed !=nil {return true ;};if _efgdd .NumRuns ()< 1{return true ;};return _bgegg .IsLeftToRight ();
};

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_becd *Division )SetPadding (left ,right ,top ,bottom float64 ){_becd ._acbg .Left =left ;_becd ._acbg .Right =right ;_becd ._acbg .Top =top ;_becd ._acbg .Bottom =bottom ;};func (_aefa *templateProcessor )parseChapterHeading (_dbfcf *templateNode )(interface{},error ){if _dbfcf ._cfeb ==nil {_cf .Log .Error ("\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_cbbfe ;};_aaec ,_gdee :=_dbfcf ._cfeb ._beabg .(*Chapter );if !_gdee {_cf .Log .Error ("\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_dbfcf ._cfeb ._beabg );
return nil ,_cbbfe ;};_cddf :=_aaec .GetHeading ();if _ ,_cfbd :=_aefa .parseParagraph (_dbfcf ,_cddf );_cfbd !=nil {return nil ,_cfbd ;};return _cddf ,nil ;};

// Height returns Image's document height.
func (_fegc *Image )Height ()float64 {return _fegc ._fdca };

// SetAngle sets the rotation angle of the text.
func (_fgfcf *StyledParagraph )SetAngle (angle float64 ){_fgfcf ._edba =angle };func _eeba (_feeb []byte )(*Image ,error ){_fabc :=_ea .NewReader (_feeb );_fggf ,_ebeg :=_ddb .ImageHandling .Read (_fabc );if _ebeg !=nil {_cf .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ebeg );
return nil ,_ebeg ;};return _gebg (_fggf );};

// SetAngle sets Image rotation angle in degrees.
func (_fgfb *Image )SetAngle (angle float64 ){_fgfb ._ddggf =angle };func _agfg (_acaf *templateProcessor ,_bcedb *templateNode )(interface{},error ){return _acaf .parseStyledParagraph (_bcedb );};func _bcbfg (_faagd *templateProcessor ,_agefa *templateNode )(interface{},error ){return _faagd .parseLine (_agefa );
};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_dcgd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_gdbb :=uint (len (_dcgd ._fgbgc ));if index > _gdbb {index =_gdbb ;};_abgd :=NewTextChunk (text ,_dcgd ._aebg );_dcgd ._fgbgc =append (_dcgd ._fgbgc [:index ],append ([]*TextChunk {_abgd },_dcgd ._fgbgc [index :]...)...);
_dcgd .wrapText ();return _abgd ;};

// Length calculates and returns the length of the line.
func (_ecea *Line )Length ()float64 {return _d .Sqrt (_d .Pow (_ecea ._faec -_ecea ._bdbec ,2.0)+_d .Pow (_ecea ._abgf -_ecea ._fgbd ,2.0));};

// Height returns the current page height.
func (_afgg *Creator )Height ()float64 {return _afgg ._edb };func _eagfa (_debdg *templateProcessor ,_gbafe *templateNode )(interface{},error ){return _debdg .parseChapter (_gbafe );};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_cfad *TOC )SetLineSeparator (separator string ){_cfad ._fcfcg =separator };

// SetStyleBottom sets border style for bottom side.
func (_ffa *border )SetStyleBottom (style CellBorderStyle ){_ffa ._dfd =style };

// Invoice represents a configurable invoice template.
type Invoice struct{_caa string ;_gagb *Image ;_efbg *InvoiceAddress ;_fdde *InvoiceAddress ;_ebefe string ;_adfd [2]*InvoiceCell ;_dada [2]*InvoiceCell ;_fegd [2]*InvoiceCell ;_baeg [][2]*InvoiceCell ;_eeec []*InvoiceCell ;_baad [][]*InvoiceCell ;_gcdg [2]*InvoiceCell ;
_fddd [2]*InvoiceCell ;_fada [][2]*InvoiceCell ;_gade [2]string ;_dbdf [2]string ;_fdbc [][2]string ;_dbecf TextStyle ;_gcfe TextStyle ;_fea TextStyle ;_dcaa TextStyle ;_bdec TextStyle ;_egfb TextStyle ;_fbaa TextStyle ;_aca InvoiceCellProps ;_aaa InvoiceCellProps ;
_cbc InvoiceCellProps ;_agedb InvoiceCellProps ;_bfabb Positioning ;};

// SetLineHeight sets the line height (1.0 default).
func (_bbae *Paragraph )SetLineHeight (lineheight float64 ){_bbae ._gggdb =lineheight };

// SetSubtotal sets the subtotal of the invoice.
func (_dafb *Invoice )SetSubtotal (value string ){_dafb ._gcdg [1].Value =value };

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ceaf *Invoice )InfoLines ()[][2]*InvoiceCell {_bce :=[][2]*InvoiceCell {_ceaf ._adfd ,_ceaf ._dada ,_ceaf ._fegd };return append (_bce ,_ceaf ._baeg ...);};

// SetLineWidth sets the line width.
func (_gcddc *Line )SetLineWidth (width float64 ){_gcddc ._ffae =width };

// SetOpacity sets the opacity of the line (0-1).
func (_gebga *Line )SetOpacity (opacity float64 ){_gebga ._acbgef =opacity };

// SetSellerAddress sets the seller address of the invoice.
func (_abed *Invoice )SetSellerAddress (address *InvoiceAddress ){_abed ._fdde =address };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_egfg *Paragraph )SetWidth (width float64 ){_egfg ._aeea =width ;_egfg .wrapText ()};

// NewPageBreak create a new page break.
func (_cgb *Creator )NewPageBreak ()*PageBreak {return _ggcgd ()};

// SetWidth sets line width.
func (_eaac *Curve )SetWidth (width float64 ){_eaac ._adecf =width };

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_baafe *Table )EnableRowWrap (enable bool ){_baafe ._fgge =enable };func _beeb (_bfbe ,_gabd ,_cbda ,_bffb float64 )*Ellipse {_dadb :=&Ellipse {};_dadb ._gdge =_bfbe ;_dadb ._befbf =_gabd ;_dadb ._afbgf =_cbda ;_dadb ._cdbg =_bffb ;_dadb ._aedaf =PositionAbsolute ;
_dadb ._eefdg =ColorBlack ;_dadb ._baeb =1.0;return _dadb ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_dacd *StyledParagraph ;_dacda []*TOCLine ;_aebeg TextStyle ;_dddg TextStyle ;_dgbba TextStyle ;_fdccf TextStyle ;_fcfcg string ;_dcace float64 ;_eadae Margins ;_bcgcg Positioning ;_efdcb TextStyle ;_gggcb bool ;};

// SetBorderColor sets the border color.
func (_ecaf *PolyBezierCurve )SetBorderColor (color Color ){_ecaf ._bddf .BorderColor =_ffad (color )};

// SetMargins sets the margins of the paragraph.
func (_eegd *List )SetMargins (left ,right ,top ,bottom float64 ){_eegd ._fgfbf .Left =left ;_eegd ._fgfbf .Right =right ;_eegd ._fgfbf .Top =top ;_eegd ._fgfbf .Bottom =bottom ;};

// SetBorderWidth sets the border width.
func (_gcb *CurvePolygon )SetBorderWidth (borderWidth float64 ){_gcb ._efdg .BorderWidth =borderWidth };

// NewFilledCurve returns a instance of filled curve.
func (_dgfbf *Creator )NewFilledCurve ()*FilledCurve {return _abdc ()};

// MoveY moves the drawing context to absolute position y.
func (_gbag *Creator )MoveY (y float64 ){_gbag ._fda .Y =y };func (_acdg *templateProcessor )parseImage (_fceca *templateNode )(interface{},error ){var _fbde string ;for _ ,_dcfcc :=range _fceca ._cgfe .Attr {_fefac :=_dcfcc .Value ;switch _bfadb :=_dcfcc .Name .Local ;
_bfadb {case "\u0073\u0072\u0063":_fbde =_fefac ;};};_edgg ,_gafb :=_acdg .loadImageFromSrc (_fbde );if _gafb !=nil {return nil ,_gafb ;};for _ ,_cgba :=range _fceca ._cgfe .Attr {_baafb :=_cgba .Value ;switch _afdfg :=_cgba .Name .Local ;_afdfg {case "\u0061\u006c\u0069g\u006e":_edgg .SetHorizontalAlignment (_acdg .parseHorizontalAlignmentAttr (_afdfg ,_baafb ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_edgg .SetOpacity (_acdg .parseFloatAttr (_afdfg ,_baafb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_cgfef :=_acdg .parseMarginAttr (_afdfg ,_baafb );_edgg .SetMargins (_cgfef .Left ,_cgfef .Right ,_cgfef .Top ,_cgfef .Bottom );
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_edgg .SetFitMode (_acdg .parseFitModeAttr (_afdfg ,_baafb ));case "\u0078":_edgg .SetPos (_acdg .parseFloatAttr (_afdfg ,_baafb ),_edgg ._begb );case "\u0079":_edgg .SetPos (_edgg ._afcd ,_acdg .parseFloatAttr (_afdfg ,_baafb ));
case "\u0077\u0069\u0064t\u0068":_edgg .SetWidth (_acdg .parseFloatAttr (_afdfg ,_baafb ));case "\u0068\u0065\u0069\u0067\u0068\u0074":_edgg .SetHeight (_acdg .parseFloatAttr (_afdfg ,_baafb ));case "\u0061\u006e\u0067l\u0065":_edgg .SetAngle (_acdg .parseFloatAttr (_afdfg ,_baafb ));
case "\u0073\u0072\u0063":break ;default:_cf .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_afdfg );
};};return _edgg ,nil ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ege *Image )SetFitMode (fitMode FitMode ){_ege ._cagg =fitMode };

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_bb *_cc .ContentStreamOperations ;_ad *_ddb .PdfPageResources ;_bg Positioning ;_eda ,_cbb float64 ;_af float64 ;_eag float64 ;_bf float64 ;_bgd Margins ;_fb []*_ddb .PdfAnnotation ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_cdb :_d .Max (_d .Min (c ,1.0),0.0),_daeg :_d .Max (_d .Min (m ,1.0),0.0),_fdefb :_d .Max (_d .Min (y ,1.0),0.0),_aedd :_d .Max (_d .Min (k ,1.0),0.0)};};func (_caec *templateProcessor )parseCellBorderStyleAttr (_gbecf ,_dacg string )CellBorderStyle {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_gbecf ,_dacg );
_eaeag :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_dacg ];return _eaeag ;};

// CurCol returns the currently active cell's column number.
func (_dccgg *Table )CurCol ()int {_bfff :=(_dccgg ._bdaaf -1)%(_dccgg ._fdeb )+1;return _bfff };

// SetPositioning sets Rectangle's position attribute.
func (_bfae *Rectangle )SetPositioning (position Positioning ){_bfae ._abgg =position };

// SetColorTop sets border color for top.
func (_fdcd *border )SetColorTop (col Color ){_fdcd ._gdb =col };

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_eeac *Invoice )Terms ()(string ,string ){return _eeac ._dbdf [0],_eeac ._dbdf [1]};

// SetWidthBottom sets border width for bottom.
func (_bbb *border )SetWidthBottom (bw float64 ){_bbb ._ede =bw };func (_dbgc *Paragraph )getTextLineWidth (_cdfgf string )float64 {var _dbde float64 ;for _ ,_bafd :=range _cdfgf {if _bafd =='\u000A'{continue ;};_ebcd ,_ccdgc :=_dbgc ._bbea .GetRuneMetrics (_bafd );
if !_ccdgc {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bafd ,_bafd );
return -1;};_dbde +=_dbgc ._fabb *_ebcd .Wx ;};return _dbde ;};func _bgdfg (_cagd ,_aegc ,_egee ,_faba float64 )*Line {return &Line {_bdbec :_cagd ,_fgbd :_aegc ,_faec :_egee ,_abgf :_faba ,_ddbb :ColorBlack ,_acbgef :1.0,_ffae :1.0,_cefb :[]int64 {1,1},_bfce :PositionAbsolute };
};

// FitMode returns the fit mode of the line.
func (_bfea *Line )FitMode ()FitMode {return _bfea ._ccba };

// Height returns Ellipse's document height.
func (_gggb *Ellipse )Height ()float64 {return _gggb ._cdbg };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_fbgc *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_fbgc ._cgge =textOverflow };

// DrawHeader sets a function to draw a header on created output pages.
func (_egdb *Creator )DrawHeader (drawHeaderFunc func (_bgef *Block ,_gaff HeaderFunctionArgs )){_egdb ._cbdb =drawHeaderFunc ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_dfea *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_aedde :=NewTextChunk (text ,_dfea ._bgafb );_aedde ._acdb =_ffab (page -1,x ,y ,zoom );return _dfea .appendChunk (_aedde );};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_aaf *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _aaf ._bdbec ,_aaf ._fgbd ,_aaf ._faec ,_aaf ._abgf ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bddf *_ggb .PolyBezierCurve ;_fggfc float64 ;_babf float64 ;};func (_gaaa *Line )computeCoords (_acaea DrawContext )(_gabg ,_eadd ,_fecg ,_dcgb float64 ){_gabg =_acaea .X ;_fecg =_gabg +_gaaa ._faec -_gaaa ._bdbec ;_cddge :=_gaaa ._ffae ;
if _gaaa ._bdbec ==_gaaa ._faec {_cddge /=2;};if _gaaa ._fgbd < _gaaa ._abgf {_eadd =_acaea .PageHeight -_acaea .Y -_cddge ;_dcgb =_eadd -_gaaa ._abgf +_gaaa ._fgbd ;}else {_dcgb =_acaea .PageHeight -_acaea .Y -_cddge ;_eadd =_dcgb -_gaaa ._fgbd +_gaaa ._abgf ;
};switch _gaaa ._ccba {case FitModeFillWidth :_fecg =_gabg +_acaea .Width ;};return _gabg ,_eadd ,_fecg ,_dcgb ;};func _eaae (_dbag ,_dfdc TextStyle )*Invoice {_fbaae :=&Invoice {_caa :"\u0049N\u0056\u004f\u0049\u0043\u0045",_ebefe :"\u002c\u0020",_dbecf :_dbag ,_gcfe :_dfdc };
_fbaae ._fdde =&InvoiceAddress {Separator :_fbaae ._ebefe };_fbaae ._efbg =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_fbaae ._ebefe };_aecf :=ColorRGBFrom8bit (245,245,245);_bgge :=ColorRGBFrom8bit (155,155,155);_fbaae ._fea =_dfdc ;
_fbaae ._fea .Color =_bgge ;_fbaae ._fea .FontSize =20;_fbaae ._dcaa =_dbag ;_fbaae ._bdec =_dfdc ;_fbaae ._egfb =_dbag ;_fbaae ._fbaa =_dfdc ;_fbaae ._aca =_fbaae .NewCellProps ();_fbaae ._aca .BackgroundColor =_aecf ;_fbaae ._aca .TextStyle =_dfdc ;_fbaae ._aaa =_fbaae .NewCellProps ();
_fbaae ._aaa .TextStyle =_dfdc ;_fbaae ._aaa .BackgroundColor =_aecf ;_fbaae ._aaa .BorderColor =_aecf ;_fbaae ._cbc =_fbaae .NewCellProps ();_fbaae ._cbc .BorderColor =_aecf ;_fbaae ._cbc .BorderSides =[]CellBorderSide {CellBorderSideBottom };_fbaae ._cbc .Alignment =CellHorizontalAlignmentRight ;
_fbaae ._agedb =_fbaae .NewCellProps ();_fbaae ._agedb .Alignment =CellHorizontalAlignmentRight ;_fbaae ._adfd =[2]*InvoiceCell {_fbaae .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_fbaae ._aca ),_fbaae .newCell ("",_fbaae ._aca )};
_fbaae ._dada =[2]*InvoiceCell {_fbaae .newCell ("\u0044\u0061\u0074\u0065",_fbaae ._aca ),_fbaae .newCell ("",_fbaae ._aca )};_fbaae ._fegd =[2]*InvoiceCell {_fbaae .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_fbaae ._aca ),_fbaae .newCell ("",_fbaae ._aca )};
_fbaae ._gcdg =[2]*InvoiceCell {_fbaae .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_fbaae ._agedb ),_fbaae .newCell ("",_fbaae ._agedb )};_efcbd :=_fbaae ._agedb ;_efcbd .TextStyle =_dfdc ;_efcbd .BackgroundColor =_aecf ;_efcbd .BorderColor =_aecf ;
_fbaae ._fddd =[2]*InvoiceCell {_fbaae .newCell ("\u0054\u006f\u0074a\u006c",_efcbd ),_fbaae .newCell ("",_efcbd )};_fbaae ._gade =[2]string {"\u004e\u006f\u0074e\u0073",""};_fbaae ._dbdf =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_fbaae ._eeec =[]*InvoiceCell {_fbaae .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_fbaae .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_fbaae .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_fbaae .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _fbaae ;};

// RotatedSize returns the width and height of the rotated block.
func (_ff *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_fc ,_gbd :=_dddd (_ff ._af ,_ff ._eag ,_ff ._bf );return _fc ,_gbd ;};

// Cols returns the total number of columns the table has.
func (_fged *Table )Cols ()int {return _fged ._fdeb };

// GeneratePageBlocks generates a page break block.
func (_ggff *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbdba :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_ebbe :=ctx ;_ebbe .Y =ctx .Margins .Top ;
_ebbe .X =ctx .Margins .Left ;_ebbe .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_ebbe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_ebbe ;return _cbdba ,ctx ,nil ;};func (_ccec *StyledParagraph )getLineMetrics (_edbcc int )(_gafa ,_bgbd ,_eggb float64 ){if _ccec ._fcddb ==nil ||len (_ccec ._fcddb )==0{_ccec .wrapText ();
};if _edbcc < 0||_edbcc > len (_ccec ._fcddb )-1{_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_edbcc );
return 0,0,0;};_fccaf :=_ccec ._fcddb [_edbcc ];for _ ,_ffce :=range _fccaf {_dffb ,_ggfb :=_ffce .Style .Font .GetFontDescriptor ();if _ggfb !=nil {_cf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _ebbb ,_cffg float64 ;if _dffb !=nil {if _ebbb ,_ggfb =_dffb .GetCapHeight ();_ggfb !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ggfb );
};if _cffg ,_ggfb =_dffb .GetDescent ();_ggfb !=nil {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_ggfb );
};};if int (_ebbb )<=0{_cf .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_ebbb =1000;};if _cccd :=_ebbb /1000.0*_ffce .Style .FontSize ;_cccd > _gafa {_gafa =_cccd ;};if _efdc :=_cffg /1000.0*_ffce .Style .FontSize ;_efdc < _eggb {_eggb =_efdc ;};if _fgbdg :=_ffce .Style .FontSize ;_fgbdg > _bgbd {_bgbd =_fgbdg ;};};return _gafa ,_bgbd ,_eggb ;
};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_fgbgc []*TextChunk ;_aebg TextStyle ;_bgafb TextStyle ;_eadg TextAlignment ;_abffg TextVerticalAlignment ;_ccfgg float64 ;_bfba bool ;_ceec float64 ;_gacgb bool ;_bfcg bool ;_cgge TextOverflow ;_edba float64 ;_ebgb Margins ;
_egbce Positioning ;_acgd float64 ;_bggb float64 ;_ceeb float64 ;_gabcb float64 ;_fcddb [][]*TextChunk ;_abgbd func (_ffda *StyledParagraph ,_gddf DrawContext );};func (_eg *Block )drawToPage (_df *_ddb .PdfPage )error {_da :=&_cc .ContentStreamOperations {};
if _df .Resources ==nil {_df .Resources =_ddb .NewPdfPageResources ();};_ba :=_abcg (_da ,_df .Resources ,_eg ._bb ,_eg ._ad );if _ba !=nil {return _ba ;};if _ba =_bcbc (_eg ._ad ,_df .Resources );_ba !=nil {return _ba ;};if _ba =_df .AppendContentBytes (_da .Bytes (),true );
_ba !=nil {return _ba ;};for _ ,_ecd :=range _eg ._fb {_df .AddAnnotation (_ecd );};return nil ;};

// SetWidthRight sets border width for right.
func (_dcgcd *border )SetWidthRight (bw float64 ){_dcgcd ._eec =bw };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_dcbd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeafe :=ctx ;var _dadg []*Block ;_gcgea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dcbd ._dcbf .IsRelative (){ctx .X +=_dcbd ._ceadb .Left ;ctx .Y +=_dcbd ._ceadb .Top ;
ctx .Width -=_dcbd ._ceadb .Left +_dcbd ._ceadb .Right ;ctx .Height -=_dcbd ._ceadb .Top ;_dcbd .SetWidth (ctx .Width );if _dcbd .Height ()> ctx .Height {_dadg =append (_dadg ,_gcgea );_gcgea =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_eadbb :=ctx ;
_eadbb .Y =ctx .Margins .Top ;_eadbb .X =ctx .Margins .Left +_dcbd ._ceadb .Left ;_eadbb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_eadbb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dcbd ._ceadb .Left -_dcbd ._ceadb .Right ;
ctx =_eadbb ;};}else {if int (_dcbd ._aeea )<=0{_dcbd .SetWidth (_dcbd .getTextWidth ());};ctx .X =_dcbd ._dgcf ;ctx .Y =_dcbd ._abga ;};ctx ,_dfgf :=_geda (_gcgea ,_dcbd ,ctx );if _dfgf !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dfgf );
return nil ,ctx ,_dfgf ;};_dadg =append (_dadg ,_gcgea );if _dcbd ._dcbf .IsRelative (){ctx .Y +=_dcbd ._ceadb .Bottom ;ctx .Height -=_dcbd ._ceadb .Bottom ;if !ctx .Inline {ctx .X =_aeafe .X ;ctx .Width =_aeafe .Width ;};return _dadg ,ctx ,nil ;};return _dadg ,_aeafe ,nil ;
};func (_cgede *Division )split (_dbcf DrawContext )(_eab ,_deg *Division ){var (_abd float64 ;_fbcf ,_fgef []VectorDrawable ;);_gacc :=_dbcf .Width -_cgede ._acdf .Left -_cgede ._acdf .Right -_cgede ._acbg .Left -_cgede ._acbg .Right ;for _aefbf ,_eefd :=range _cgede ._bfcd {_abd +=_cdea (_eefd ,_gacc );
if _abd < _dbcf .Height {_fbcf =append (_fbcf ,_eefd );}else {_fgef =_cgede ._bfcd [_aefbf :];break ;};};if len (_fbcf )> 0{_eab =_dbg ();*_eab =*_cgede ;_eab ._bfcd =_fbcf ;if _cgede ._egfcb !=nil {_eab ._egfcb =&Background {};*_eab ._egfcb =*_cgede ._egfcb ;
};};if len (_fgef )> 0{_deg =_dbg ();*_deg =*_cgede ;_deg ._bfcd =_fgef ;if _cgede ._egfcb !=nil {_deg ._egfcb =&Background {};*_deg ._egfcb =*_cgede ._egfcb ;};};return _eab ,_deg ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_cfaeb *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _cfaeb ._fgfbf .Left ,_cfaeb ._fgfbf .Right ,_cfaeb ._fgfbf .Top ,_cfaeb ._fgfbf .Bottom ;};func (_abg *Chapter )headingNumber ()string {var _befc string ;if _abg ._bab {if _abg ._fbd !=0{_befc =_gg .Itoa (_abg ._fbd )+"\u002e";
};if _abg ._dgg !=nil {_aed :=_abg ._dgg .headingNumber ();if _aed !=""{_befc =_aed +_befc ;};};};return _befc ;};func _dgac (_fcbc [][]_ggb .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_efdg :&_ggb .CurvePolygon {Rings :_fcbc },_afgd :1.0,_cdaaa :1.0};
};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_gfe *Creator )EnableFontSubsetting (font *_ddb .PdfFont ){_gfe ._ebec =append (_gfe ._ebec ,font )};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fgecf *Chapter )SetIncludeInTOC (includeInTOC bool ){_fgecf ._fedf =includeInTOC };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fggff *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _fggff ._adfd [0],_fggff ._adfd [1]};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_geaa *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgdee :=ctx ;var _gbc []*Block ;_beccg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _geaa ._egbce .IsRelative (){ctx .X +=_geaa ._ebgb .Left ;ctx .Y +=_geaa ._ebgb .Top ;
ctx .Width -=_geaa ._ebgb .Left +_geaa ._ebgb .Right ;ctx .Height -=_geaa ._ebgb .Top ;_geaa .SetWidth (ctx .Width );}else {if int (_geaa ._ceec )<=0{_geaa .SetWidth (_geaa .getTextWidth ()/1000.0);};ctx .X =_geaa ._acgd ;ctx .Y =_geaa ._bggb ;};if _geaa ._abgbd !=nil {_geaa ._abgbd (_geaa ,ctx );
};if _gabfd :=_geaa .wrapText ();_gabfd !=nil {return nil ,ctx ,_gabfd ;};_dcgca :=_geaa ._fcddb ;for {_abec ,_dcaf ,_fgbc :=_cdgba (_beccg ,_geaa ,_dcgca ,ctx );if _fgbc !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgbc );return nil ,ctx ,_fgbc ;
};ctx =_abec ;_gbc =append (_gbc ,_beccg );if _dcgca =_dcaf ;len (_dcaf )==0{break ;};_beccg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_abec =ctx ;_abec .Y =ctx .Margins .Top ;_abec .X =ctx .Margins .Left +_geaa ._ebgb .Left ;_abec .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
_abec .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_geaa ._ebgb .Left -_geaa ._ebgb .Right ;ctx =_abec ;};if _geaa ._egbce .IsRelative (){ctx .Y +=_geaa ._ebgb .Bottom ;ctx .Height -=_geaa ._ebgb .Bottom ;if !ctx .Inline {ctx .X =_bgdee .X ;
ctx .Width =_bgdee .Width ;};return _gbc ,ctx ,nil ;};return _gbc ,_bgdee ,nil ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_acbf *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdfga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fggda ,_ ,_afab :=_acbf .draw ("");if _afab !=nil {return nil ,ctx ,_afab ;};_afab =_bdfga .addContentsByString (string (_fggda ));
if _afab !=nil {return nil ,ctx ,_afab ;};return []*Block {_bdfga },ctx ,nil ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_dgbe *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_dgbe ._gdddf =valign };func (_edff *Paragraph )getTextWidth ()float64 {_aeceg :=0.0;for _ ,_aeca :=range _edff ._aadgg {if _aeca =='\u000A'{continue ;};_dgcg ,_bdgd :=_edff ._bbea .GetRuneMetrics (_aeca );
if !_bdgd {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_aeca ,_aeca );
return -1;};_aeceg +=_edff ._fabb *_dgcg .Wx ;};return _aeceg ;};

// GetOptimizer returns current PDF optimizer.
func (_gbfe *Creator )GetOptimizer ()_ddb .Optimizer {return _gbfe ._gbfd };func _geda (_fgfe *Block ,_fadae *Paragraph ,_caac DrawContext )(DrawContext ,error ){_gdeg :=1;_cgeg :=_a .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gg .Itoa (_gdeg ));for _fgfe ._ad .HasFontByName (_cgeg ){_gdeg ++;
_cgeg =_a .PdfObjectName ("\u0046\u006f\u006e\u0074"+_gg .Itoa (_gdeg ));};_ddefe :=_fgfe ._ad .SetFontByName (_cgeg ,_fadae ._bbea .ToPdfObject ());if _ddefe !=nil {return _caac ,_ddefe ;};_fadae .wrapText ();_eba :=_cc .NewContentCreator ();_eba .Add_q ();
_gdgg :=_caac .PageHeight -_caac .Y -_fadae ._fabb *_fadae ._gggdb ;_eba .Translate (_caac .X ,_gdgg );if _fadae ._afeg !=0{_eba .RotateDeg (_fadae ._afeg );};_eba .Add_BT ().SetNonStrokingColor (_ffad (_fadae ._aacbd )).Add_Tf (_cgeg ,_fadae ._fabb ).Add_TL (_fadae ._fabb *_fadae ._gggdb );
for _bbdd ,_cff :=range _fadae ._bfbc {if _bbdd !=0{_eba .Add_Tstar ();};_acgb :=[]rune (_cff );_bbgeg :=0.0;_bfec :=0;for _eaef ,_efcf :=range _acgb {if _efcf ==' '{_bfec ++;continue ;};if _efcf =='\u000A'{continue ;};_ggfg ,_fgdag :=_fadae ._bbea .GetRuneMetrics (_efcf );
if !_fgdag {_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_eaef ,_efcf ,_efcf ,_fadae ._bbea .BaseFont (),_fadae ._bbea .Subtype ());
return _caac ,_e .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bbgeg +=_fadae ._fabb *_ggfg .Wx ;};var _fgaa []_a .PdfObject ;_agad ,_ffbb :=_fadae ._bbea .GetRuneMetrics (' ');
if !_ffbb {return _caac ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dbfa :=_agad .Wx ;switch _fadae ._cccg {case TextAlignmentJustify :if _bfec > 0&&_bbdd < len (_fadae ._bfbc )-1{_dbfa =(_fadae ._aeea *1000.0-_bbgeg )/float64 (_bfec )/_fadae ._fabb ;
};case TextAlignmentCenter :_ccdba :=_bbgeg +float64 (_bfec )*_dbfa *_fadae ._fabb ;_cdgd :=(_fadae ._aeea *1000.0-_ccdba )/2/_fadae ._fabb ;_fgaa =append (_fgaa ,_a .MakeFloat (-_cdgd ));case TextAlignmentRight :_debg :=_bbgeg +float64 (_bfec )*_dbfa *_fadae ._fabb ;
_cdec :=(_fadae ._aeea *1000.0-_debg )/_fadae ._fabb ;_fgaa =append (_fgaa ,_a .MakeFloat (-_cdec ));};_dcce :=_fadae ._bbea .Encoder ();var _dfcf []byte ;for _ ,_ecgb :=range _acgb {if _ecgb =='\u000A'{continue ;};if _ecgb ==' '{if len (_dfcf )> 0{_fgaa =append (_fgaa ,_a .MakeStringFromBytes (_dfcf ));
_dfcf =nil ;};_fgaa =append (_fgaa ,_a .MakeFloat (-_dbfa ));}else {if _ ,_dgcc :=_dcce .RuneToCharcode (_ecgb );!_dgcc {_ddefe =UnsupportedRuneError {Message :_cb .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ecgb ,_ecgb ),Rune :_ecgb };
_caac ._ggcf =append (_caac ._ggcf ,_ddefe );_cf .Log .Debug (_ddefe .Error ());if _caac ._accf <=0{continue ;};_ecgb =_caac ._accf ;};_dfcf =append (_dfcf ,_dcce .Encode (string (_ecgb ))...);};};if len (_dfcf )> 0{_fgaa =append (_fgaa ,_a .MakeStringFromBytes (_dfcf ));
};_eba .Add_TJ (_fgaa ...);};_eba .Add_ET ();_eba .Add_Q ();_ccff :=_eba .Operations ();_ccff .WrapIfNeeded ();_fgfe .addContents (_ccff );if _fadae ._dcbf .IsRelative (){_bced :=_fadae .Height ();_caac .Y +=_bced ;_caac .Height -=_bced ;if _caac .Inline {_caac .X +=_fadae .Width ()+_fadae ._ceadb .Right ;
};};return _caac ,nil ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_dfbc *Invoice )NoteStyle ()TextStyle {return _dfbc ._egfb };func (_eeffa *templateProcessor )parseTextOverflowAttr (_fedg ,_fegbc string )TextOverflow {_cf .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_fedg ,_fegbc );
_edbe :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_fegbc ];return _edbe ;};

// SetFillColor sets the fill color.
func (_gebff *Rectangle )SetFillColor (col Color ){_gebff ._aeddb =col };

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_gafd :_d .Max (_d .Min (r ,1.0),0.0),_gfa :_d .Max (_d .Min (g ,1.0),0.0),_gcad :_d .Max (_d .Min (b ,1.0),0.0)};};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_ag *Block )ScaleToWidth (w float64 ){_ae :=w /_ag ._af ;_ag .Scale (_ae ,_ae )};

// AppendCurve appends a Bezier curve to the filled curve.
func (_cdef *FilledCurve )AppendCurve (curve _ggb .CubicBezierCurve )*FilledCurve {_cdef ._dbdd =append (_cdef ._dbdd ,curve );return _cdef ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_bdbec float64 ;_fgbd float64 ;_faec float64 ;_abgf float64 ;_ddbb Color ;_edeg _ggb .LineStyle ;_acbgef float64 ;_cefb []int64 ;_cbaf int64 ;_ffae float64 ;_bfce Positioning ;_ccba FitMode ;_dfbfe Margins ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bbed *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbcea :=ctx ;_gbeb :=[]func (_daaa DrawContext )([]*Block ,DrawContext ,error ){_bbed .generateHeaderBlocks ,_bbed .generateInformationBlocks ,_bbed .generateLineBlocks ,_bbed .generateTotalBlocks ,_bbed .generateNoteBlocks };
var _bfgb []*Block ;for _ ,_cegg :=range _gbeb {_agdd ,_efgd ,_dbca :=_cegg (ctx );if _dbca !=nil {return _bfgb ,ctx ,_dbca ;};if len (_bfgb )==0{_bfgb =_agdd ;}else if len (_agdd )> 0{_bfgb [len (_bfgb )-1].mergeBlocks (_agdd [0]);_bfgb =append (_bfgb ,_agdd [1:]...);
};ctx =_efgd ;};if _bbed ._bfabb .IsRelative (){ctx .X =_bbcea .X ;};if _bbed ._bfabb .IsAbsolute (){return _bfgb ,_bbcea ,nil ;};return _bfgb ,ctx ,nil ;};func _abcg (_edac *_cc .ContentStreamOperations ,_eac *_ddb .PdfPageResources ,_beec *_cc .ContentStreamOperations ,_fde *_ddb .PdfPageResources )error {_aee :=map[_a .PdfObjectName ]_a .PdfObjectName {};
_ga :=map[_a .PdfObjectName ]_a .PdfObjectName {};_bgb :=map[_a .PdfObjectName ]_a .PdfObjectName {};_bdb :=map[_a .PdfObjectName ]_a .PdfObjectName {};_gbbf :=map[_a .PdfObjectName ]_a .PdfObjectName {};_geee :=map[_a .PdfObjectName ]_a .PdfObjectName {};
for _ ,_dcgc :=range *_beec {switch _dcgc .Operand {case "\u0044\u006f":if len (_dcgc .Params )==1{if _fdbe ,_fga :=_dcgc .Params [0].(*_a .PdfObjectName );_fga {if _ ,_ee :=_aee [*_fdbe ];!_ee {var _eea _a .PdfObjectName ;_dde ,_ :=_fde .GetXObjectByName (*_fdbe );
if _dde !=nil {_eea =*_fdbe ;for {_bfg ,_ :=_eac .GetXObjectByName (_eea );if _bfg ==nil ||_bfg ==_dde {break ;};_eea =_eea +"\u0030";};};_eac .SetXObjectByName (_eea ,_dde );_aee [*_fdbe ]=_eea ;};_cce :=_aee [*_fdbe ];_dcgc .Params [0]=&_cce ;};};case "\u0054\u0066":if len (_dcgc .Params )==2{if _cbgf ,_fae :=_dcgc .Params [0].(*_a .PdfObjectName );
_fae {if _ ,_ebd :=_ga [*_cbgf ];!_ebd {_fba ,_ddd :=_fde .GetFontByName (*_cbgf );_bae :=*_cbgf ;if _ddd &&_fba !=nil {_bae =_gcfg (_cbgf .String (),_fba ,_eac );};_eac .SetFontByName (_bae ,_fba );_ga [*_cbgf ]=_bae ;};_fbf :=_ga [*_cbgf ];_dcgc .Params [0]=&_fbf ;
};};case "\u0043\u0053","\u0063\u0073":if len (_dcgc .Params )==1{if _ggcg ,_dag :=_dcgc .Params [0].(*_a .PdfObjectName );_dag {if _ ,_afd :=_bgb [*_ggcg ];!_afd {var _agb _a .PdfObjectName ;_add ,_geb :=_fde .GetColorspaceByName (*_ggcg );if _geb {_agb =*_ggcg ;
for {_ac ,_cfca :=_eac .GetColorspaceByName (_agb );if !_cfca ||_add ==_ac {break ;};_agb =_agb +"\u0030";};_eac .SetColorspaceByName (_agb ,_add );_bgb [*_ggcg ]=_agb ;}else {_cf .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _feee ,_faa :=_bgb [*_ggcg ];_faa {_dcgc .Params [0]=&_feee ;}else {_cf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_ggcg );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_dcgc .Params )==1{if _bdc ,_gbdg :=_dcgc .Params [0].(*_a .PdfObjectName );_gbdg {if _ ,_bcb :=_bdb [*_bdc ];!_bcb {var _cd _a .PdfObjectName ;_bad ,_dbec :=_fde .GetPatternByName (*_bdc );if _dbec {_cd =*_bdc ;
for {_fge ,_edaf :=_eac .GetPatternByName (_cd );if !_edaf ||_fge ==_bad {break ;};_cd =_cd +"\u0030";};_dbf :=_eac .SetPatternByName (_cd ,_bad .ToPdfObject ());if _dbf !=nil {return _dbf ;};_bdb [*_bdc ]=_cd ;};};if _dgf ,_cge :=_bdb [*_bdc ];_cge {_dcgc .Params [0]=&_dgf ;
};};};case "\u0073\u0068":if len (_dcgc .Params )==1{if _ddef ,_feg :=_dcgc .Params [0].(*_a .PdfObjectName );_feg {if _ ,_ccag :=_gbbf [*_ddef ];!_ccag {var _agd _a .PdfObjectName ;_bdf ,_baef :=_fde .GetShadingByName (*_ddef );if _baef {_agd =*_ddef ;
for {_cda ,_fca :=_eac .GetShadingByName (_agd );if !_fca ||_bdf ==_cda {break ;};_agd =_agd +"\u0030";};_aae :=_eac .SetShadingByName (_agd ,_bdf .ToPdfObject ());if _aae !=nil {_cf .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_aae );
return _aae ;};_gbbf [*_ddef ]=_agd ;}else {_cf .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _efe ,_efc :=_gbbf [*_ddef ];_efc {_dcgc .Params [0]=&_efe ;}else {_cf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ddef );
};};};case "\u0067\u0073":if len (_dcgc .Params )==1{if _fegg ,_bge :=_dcgc .Params [0].(*_a .PdfObjectName );_bge {if _ ,_cbd :=_geee [*_fegg ];!_cbd {var _ce _a .PdfObjectName ;_bea ,_eacc :=_fde .GetExtGState (*_fegg );if _eacc {_ce =*_fegg ;_cee :=1;
for {_daf ,_cef :=_eac .GetExtGState (_ce );if !_cef ||_bea ==_daf {break ;};_ce =_a .PdfObjectName (_cb .Sprintf ("\u0047\u0053\u0025\u0064",_cee ));_cee ++;};};_eac .AddExtGState (_ce ,_bea );_geee [*_fegg ]=_ce ;};_gcf :=_geee [*_fegg ];_dcgc .Params [0]=&_gcf ;
};};};*_edac =append (*_edac ,_dcgc );};return nil ;};func _dddd (_bbced ,_ceaa ,_fdccc float64 )(_dcdfe ,_cgbcg ,_eabf ,_bdde float64 ){if _fdccc ==0{return 0,0,_bbced ,_ceaa ;};_abfga :=_ggb .Path {Points :[]_ggb .Point {_ggb .NewPoint (0,0).Rotate (_fdccc ),_ggb .NewPoint (_bbced ,0).Rotate (_fdccc ),_ggb .NewPoint (0,_ceaa ).Rotate (_fdccc ),_ggb .NewPoint (_bbced ,_ceaa ).Rotate (_fdccc )}}.GetBoundingBox ();
return _abfga .X ,_abfga .Y ,_abfga .Width ,_abfga .Height ;};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_bdad *Line )SetPositioning (positioning Positioning ){_bdad ._bfce =positioning };func (_gdc *pageTransformations )applyFlip (_dcba *_ddb .PdfPage )error {_dcef ,_ddc :=_gdc ._cec ,_gdc ._cdc ;if !_dcef &&!_ddc {return nil ;};if _dcba ==nil {return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_fce ,_babab :=_dcba .GetMediaBox ();if _babab !=nil {return _babab ;};_dbb ,_cecf :=_fce .Width (),_fce .Height ();_dggg ,_babab :=_dcba .GetRotate ();if _babab !=nil {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_babab .Error ());
};if _bggc :=_dggg %360!=0&&_dggg %90==0;_bggc {if _gdcb :=(360+_dggg %360)%360;_gdcb ==90||_gdcb ==270{_dcef ,_ddc =_ddc ,_dcef ;};};_bgac ,_bbc :=1.0,0.0;if _dcef {_bgac ,_bbc =-1.0,-_dbb ;};_eeca ,_cead :=1.0,0.0;if _ddc {_eeca ,_cead =-1.0,-_cecf ;
};_bbcf :=_cc .NewContentCreator ().Scale (_bgac ,_eeca ).Translate (_bbc ,_cead );_gfcg ,_babab :=_a .MakeStream (_bbcf .Bytes (),_a .NewFlateEncoder ());if _babab !=nil {return _babab ;};_fcfe :=_a .MakeArray (_gfcg );_fcfe .Append (_dcba .GetContentStreamObjs ()...);
_dcba .Contents =_fcfe ;return nil ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ebg *Block )Draw (d Drawable )error {_db :=DrawContext {};_db .Width =_ebg ._af ;_db .Height =_ebg ._eag ;_db .PageWidth =_ebg ._af ;_db .PageHeight =_ebg ._eag ;_db .X =0;_db .Y =0;_eced ,_ ,_fgc :=d .GeneratePageBlocks (_db );if _fgc !=nil {return _fgc ;
};if len (_eced )!=1{return _e .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ebb :=range _eced {if _abe :=_ebg .mergeBlocks (_ebb );_abe !=nil {return _abe ;};};
return nil ;};func (_fddcc *templateProcessor )parseBorderRadiusAttr (_gbca ,_face string )(_bafa ,_ggbe ,_aabg ,_egab float64 ){_cf .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_gbca ,_face );
switch _ccfc :=_gga .Fields (_face );len (_ccfc ){case 1:_bafa ,_ =_gg .ParseFloat (_ccfc [0],64);_ggbe =_bafa ;_aabg =_bafa ;_egab =_bafa ;case 2:_bafa ,_ =_gg .ParseFloat (_ccfc [0],64);_aabg =_bafa ;_ggbe ,_ =_gg .ParseFloat (_ccfc [1],64);_egab =_ggbe ;
case 3:_bafa ,_ =_gg .ParseFloat (_ccfc [0],64);_ggbe ,_ =_gg .ParseFloat (_ccfc [1],64);_egab =_ggbe ;_aabg ,_ =_gg .ParseFloat (_ccfc [2],64);case 4:_bafa ,_ =_gg .ParseFloat (_ccfc [0],64);_ggbe ,_ =_gg .ParseFloat (_ccfc [1],64);_aabg ,_ =_gg .ParseFloat (_ccfc [2],64);
_egab ,_ =_gg .ParseFloat (_ccfc [3],64);};return _bafa ,_ggbe ,_aabg ,_egab ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_ccfg *Creator )NewImage (img *_ddb .Image )(*Image ,error ){return _gebg (img )};

// CreateTableOfContents sets a function to generate table of contents.
func (_gceb *Creator )CreateTableOfContents (genTOCFunc func (_cdgg *TOC )error ){_gceb ._cgca =genTOCFunc ;};

// SetFillOpacity sets the fill opacity.
func (_fdbb *Rectangle )SetFillOpacity (opacity float64 ){_fdbb ._ccbd =opacity };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_cecg *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _fcdddf (number ,title ,page ,level ,style );};

// GeneratePageBlocks draws the chart onto a block.
func (_abcd *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcac :=ctx ;_gbbe :=_abcd ._egdc .IsRelative ();var _ecf []*Block ;if _gbbe {_bdbg :=1.0;_gbbd :=_abcd ._cfg .Top ;if float64 (_abcd ._eeaf .Height ())> ctx .Height -_abcd ._cfg .Top {_ecf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _fgd error ;if _ ,ctx ,_fgd =_ggcgd ().GeneratePageBlocks (ctx );_fgd !=nil {return nil ,ctx ,_fgd ;};_gbbd =0;};ctx .X +=_abcd ._cfg .Left +_bdbg ;ctx .Y +=_gbbd ;ctx .Width -=_abcd ._cfg .Left +_abcd ._cfg .Right +2*_bdbg ;ctx .Height -=_gbbd ;_abcd ._eeaf .SetWidth (int (ctx .Width ));
}else {ctx .X =_abcd ._eafe ;ctx .Y =_abcd ._bdgba ;};_bgec :=_cc .NewContentCreator ();_bgec .Translate (0,ctx .PageHeight );_bgec .Scale (1,-1);_bgec .Translate (ctx .X ,ctx .Y );_gafg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abcd ._eeaf .Render (_fdd .NewRenderer (_bgec ,_gafg ._ad ),nil );
if _aaeb :=_gafg .addContentsByString (_bgec .String ());_aaeb !=nil {return nil ,ctx ,_aaeb ;};if _gbbe {_bfdf :=_abcd .Height ()+_abcd ._cfg .Bottom ;ctx .Y +=_bfdf ;ctx .Height -=_bfdf ;}else {ctx =_bcac ;};_ecf =append (_ecf ,_gafg );return _ecf ,ctx ,nil ;
};

// SetPos sets absolute positioning with specified coordinates.
func (_degf *Paragraph )SetPos (x ,y float64 ){_degf ._dcbf =PositionAbsolute ;_degf ._dgcf =x ;_degf ._abga =y ;};func _ffcf (_abdcf string ,_fbgb TextStyle )*Paragraph {_fcde :=&Paragraph {_aadgg :_abdcf ,_bbea :_fbgb .Font ,_fabb :_fbgb .FontSize ,_gggdb :1.0,_ccad :true ,_fcdd :true ,_cccg :TextAlignmentLeft ,_afeg :0,_cfedb :1,_dfecc :1,_dcbf :PositionRelative };
_fcde .SetColor (_fbgb .Color );return _fcde ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_eagf *Chart )SetPos (x ,y float64 ){_eagf ._egdc =PositionAbsolute ;_eagf ._eafe =x ;_eagf ._bdgba =y ;};func (_begbe *StyledParagraph )wrapWordChunks (){if !_begbe ._gacgb {return ;};var _aacgfe []*TextChunk ;for _ ,_fgfce :=range _begbe ._fgbgc {_bgce :=[]rune (_fgfce .Text );
if len (_bgce )==1&&_ed .IsPunct (_bgce [0]){_ddabf :=[]rune (_aacgfe [len (_aacgfe )-1].Text );_aacgfe [len (_aacgfe )-1].Text =string (append (_ddabf ,_bgce [0]));continue ;}else {_ ,_cfaea :=_gg .Atoi (_fgfce .Text );if _cfaea ==nil {_caae :=[]rune (_aacgfe [len (_aacgfe )-1].Text );
_fccg :=len (_caae );_ ,_ebfa :=_gg .Atoi (string (_caae [_fccg -2]));if _ebfa ==nil &&_ed .IsPunct (_caae [_fccg -1]){_aacgfe [len (_aacgfe )-1].Text =string (append (_caae ,_bgce ...));continue ;};};};_abba ,_bbdc :=_abbcf (_fgfce .Text );if _bbdc !=nil {_cf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_bbdc );
_abba =[]string {_fgfce .Text };};for _ ,_egad :=range _abba {_cfcf :=NewTextChunk (_egad ,_fgfce .Style );_aacgfe =append (_aacgfe ,_cfcf );};};if len (_aacgfe )> 0{_begbe ._fgbgc =_aacgfe ;};};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ggee *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _ggee ._gcdg [0],_ggee ._gcdg [1]};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aacgg *Creator )NewStyledParagraph ()*StyledParagraph {return _fgee (_aacgg .NewTextStyle ())};func (_cdefb *templateProcessor )parseDivision (_aafb *templateNode )(interface{},error ){_adaeb :=_cdefb .creator .NewDivision ();for _ ,_edca :=range _aafb ._cgfe .Attr {_gdad :=_edca .Value ;
switch _eada :=_edca .Name .Local ;_eada {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_adaeb .EnablePageWrap (_cdefb .parseBoolAttr (_eada ,_gdad ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gdfd :=_cdefb .parseMarginAttr (_eada ,_gdad );
_adaeb .SetMargins (_gdfd .Left ,_gdfd .Right ,_gdfd .Top ,_gdfd .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_gebab :=_cdefb .parseMarginAttr (_eada ,_gdad );_adaeb .SetPadding (_gebab .Left ,_gebab .Right ,_gebab .Top ,_gebab .Bottom );default:_cf .Log .Debug ("U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_eada );
};};return _adaeb ,nil ;};

// Logo returns the logo of the invoice.
func (_gedfe *Invoice )Logo ()*Image {return _gedfe ._gagb };

// EnableWordWrap sets the paragraph word wrap flag.
func (_bgcb *StyledParagraph )EnableWordWrap (val bool ){_bgcb ._gacgb =val };func (_aebec *TOCLine )prepareParagraph (_ffbf *StyledParagraph ,_ecgag DrawContext ){_abdcg :=_aebec .Title .Text ;if _aebec .Number .Text !=""{_abdcg ="\u0020"+_abdcg ;};_abdcg +="\u0020";
_adebc :=_aebec .Page .Text ;if _adebc !=""{_adebc ="\u0020"+_adebc ;};_ffbf ._fgbgc =[]*TextChunk {{Text :_aebec .Number .Text ,Style :_aebec .Number .Style ,_acdb :_aebec .getLineLink ()},{Text :_abdcg ,Style :_aebec .Title .Style ,_acdb :_aebec .getLineLink ()},{Text :_adebc ,Style :_aebec .Page .Style ,_acdb :_aebec .getLineLink ()}};
_ffbf .wrapText ();_ggbd :=len (_ffbf ._fcddb );if _ggbd ==0{return ;};_cbgc :=_ecgag .Width *1000-_ffbf .getTextLineWidth (_ffbf ._fcddb [_ggbd -1]);_cgccd :=_ffbf .getTextLineWidth ([]*TextChunk {&_aebec .Separator });_cfcac :=int (_cbgc /_cgccd );_gggcc :=_gga .Repeat (_aebec .Separator .Text ,_cfcac );
_aafc :=_aebec .Separator .Style ;_gfecg :=_ffbf .Insert (2,_gggcc );_gfecg .Style =_aafc ;_gfecg ._acdb =_aebec .getLineLink ();_cbgc =_cbgc -float64 (_cfcac )*_cgccd ;if _cbgc > 500{_cbbfg ,_defgc :=_aafc .Font .GetRuneMetrics (' ');if _defgc &&_cbgc > _cbbfg .Wx {_ddca :=int (_cbgc /_cbbfg .Wx );
if _ddca > 0{_agcdc :=_aafc ;_agcdc .FontSize =1;_gfecg =_ffbf .Insert (2,_gga .Repeat ("\u0020",_ddca ));_gfecg .Style =_agcdc ;_gfecg ._acdb =_aebec .getLineLink ();};};};};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_affe *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_affe ._fdeb {_cf .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_affe ._fefbb =widths ;return nil ;};

// Height returns the height of the list.
func (_fbad *List )Height ()float64 {var _gdeb float64 ;for _ ,_fbdb :=range _fbad ._eefg {_gdeb +=_fbdb ._debeb .Height ();};return _gdeb ;};func _cbdf (_aebe *Table ,_dgfbe DrawContext )([]*Block ,DrawContext ,error ){var _fddee []*Block ;_gfecd :=NewBlock (_dgfbe .PageWidth ,_dgfbe .PageHeight );
_aebe .updateRowHeights (_dgfbe .Width -_aebe ._edcc .Left -_aebe ._edcc .Right );_ggeg :=_aebe ._edcc .Top ;if _aebe ._afbd .IsRelative ()&&!_aebe ._degff {_bbdcf :=_aebe .Height ();if _bbdcf > _dgfbe .Height -_aebe ._edcc .Top &&_bbdcf <=_dgfbe .PageHeight -_dgfbe .Margins .Top -_dgfbe .Margins .Bottom {_fddee =[]*Block {NewBlock (_dgfbe .PageWidth ,_dgfbe .PageHeight -_dgfbe .Y )};
var _ggbc error ;if _ ,_dgfbe ,_ggbc =_ggcgd ().GeneratePageBlocks (_dgfbe );_ggbc !=nil {return nil ,_dgfbe ,_ggbc ;};_ggeg =0;};};_cbdde :=_dgfbe ;if _aebe ._afbd .IsAbsolute (){_dgfbe .X =_aebe ._daaaa ;_dgfbe .Y =_aebe ._adgf ;}else {_dgfbe .X +=_aebe ._edcc .Left ;
_dgfbe .Y +=_ggeg ;_dgfbe .Width -=_aebe ._edcc .Left +_aebe ._edcc .Right ;_dgfbe .Height -=_ggeg ;};_ccabg :=_dgfbe .Width ;_ddce :=_dgfbe .X ;_bdeg :=_dgfbe .Y ;_ffcb :=_dgfbe .Height ;_gbfdg :=0;_ecbb ,_dbcac :=-1,-1;if _aebe ._eebfe {for _fefe ,_gfcd :=range _aebe ._edeebg {if _gfcd ._gdfb < _aebe ._bcge {continue ;
};if _gfcd ._gdfb > _aebe ._bgga {break ;};if _ecbb < 0{_ecbb =_fefe ;};_dbcac =_fefe ;};};if _dggfe :=_aebe .wrapContent (_dgfbe );_dggfe !=nil {return nil ,_dgfbe ,_dggfe ;};_aebe .updateRowHeights (_dgfbe .Width -_aebe ._edcc .Left -_aebe ._edcc .Right );
var (_bafb bool ;_edacc int ;_gccf int ;_gebce bool ;_ebeega int ;_cabf error ;);for _aaga :=0;_aaga < len (_aebe ._edeebg );_aaga ++{_edbcf :=_aebe ._edeebg [_aaga ];_fgeeb :=_edbcf .width (_aebe ._fefbb ,_ccabg );_gbaa :=float64 (0.0);for _aade :=0;_aade < _edbcf ._fbcc -1;
_aade ++{_gbaa +=_aebe ._fefbb [_aade ]*_ccabg ;};_bdfgae :=float64 (0.0);for _cbac :=_gbfdg ;_cbac < _edbcf ._gdfb -1;_cbac ++{_bdfgae +=_aebe ._fcga [_cbac ];};_dgfbe .Height =_ffcb -_bdfgae ;_ffdac :=float64 (0.0);for _bbbg :=0;_bbbg < _edbcf ._fgfbg ;
_bbbg ++{_ffdac +=_aebe ._fcga [_edbcf ._gdfb +_bbbg -1];};_ggda :=_gebce &&_edbcf ._gdfb !=_ebeega ;_ebeega =_edbcf ._gdfb ;if _ggda ||_ffdac > _dgfbe .Height {if _aebe ._fgge &&!_gebce {_gebce ,_cabf =_aebe .wrapRow (_aaga ,_dgfbe ,_ccabg );if _cabf !=nil {return nil ,_dgfbe ,_cabf ;
};if _gebce {_aaga --;continue ;};};_fddee =append (_fddee ,_gfecd );_gfecd =NewBlock (_dgfbe .PageWidth ,_dgfbe .PageHeight );_ddce =_dgfbe .Margins .Left +_aebe ._edcc .Left ;_bdeg =_dgfbe .Margins .Top ;_dgfbe .Height =_dgfbe .PageHeight -_dgfbe .Margins .Top -_dgfbe .Margins .Bottom ;
_dgfbe .Page ++;_ffcb =_dgfbe .Height ;_gbfdg =_edbcf ._gdfb -1;_bdfgae =0;_gebce =false ;if _aebe ._eebfe &&_ecbb >=0{_edacc =_aaga ;_aaga =_ecbb -1;_gccf =_gbfdg ;_gbfdg =_aebe ._bcge -1;_bafb =true ;if _edbcf ._fgfbg > (_aebe ._aceec -_ebeega )||(_edbcf ._fgfbg > 1&&_aaga < 0){_cf .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_bafb =false ;_ecbb ,_dbcac =-1,-1;};continue ;};if _ggda {_aaga --;continue ;};};_dgfbe .Width =_fgeeb ;_dgfbe .X =_ddce +_gbaa ;_dgfbe .Y =_bdeg +_bdfgae ;_dfcag :=_fdg (_dgfbe .X ,_dgfbe .Y ,_fgeeb ,_ffdac );if _edbcf ._dee !=nil {_dfcag .SetFillColor (_edbcf ._dee );
};_dfcag .LineStyle =_edbcf ._bcffc ;_dfcag ._bdfg =_edbcf ._fcbf ;_dfcag ._fdc =_edbcf ._dfdba ;_dfcag ._beag =_edbcf ._dcbb ;_dfcag ._dfd =_edbcf ._gbaf ;if _edbcf ._aggf !=nil {_dfcag .SetColorLeft (_edbcf ._aggf );};if _edbcf ._cdbab !=nil {_dfcag .SetColorBottom (_edbcf ._cdbab );
};if _edbcf ._ebfcg !=nil {_dfcag .SetColorRight (_edbcf ._ebfcg );};if _edbcf ._ddgga !=nil {_dfcag .SetColorTop (_edbcf ._ddgga );};_dfcag .SetWidthBottom (_edbcf ._ecaegf );_dfcag .SetWidthLeft (_edbcf ._aecd );_dfcag .SetWidthRight (_edbcf ._deff );
_dfcag .SetWidthTop (_edbcf ._caca );_bafdad :=_gfecd .Draw (_dfcag );if _bafdad !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bafdad );};if _edbcf ._ffbee !=nil {_gbeg :=_edbcf ._ffbee .Width ();_gede :=_edbcf ._ffbee .Height ();
_fdgc :=0.0;switch _egafg :=_edbcf ._ffbee .(type ){case *Paragraph :if _egafg ._ccad {_gbeg =_egafg .getMaxLineWidth ()/1000.0;};_gbeg +=_egafg ._ceadb .Left +_egafg ._ceadb .Right ;_gede +=_egafg ._ceadb .Top +_egafg ._ceadb .Bottom ;case *StyledParagraph :if _egafg ._bfba {_gbeg =_egafg .getMaxLineWidth ()/1000.0;
};_cdfa ,_bgcf ,_ggafd :=_egafg .getLineMetrics (0);_gedag ,_dgfbc :=_cdfa *_egafg ._ccfgg ,_bgcf *_egafg ._ccfgg ;if _egafg ._abffg ==TextVerticalAlignmentCenter {_fdgc =_dgfbc -(_bgcf +(_cdfa +_ggafd -_bgcf )/2+(_dgfbc -_bgcf )/2);};if len (_egafg ._fcddb )==1{_gede =_gedag ;
}else {_gede =_gede -_dgfbc +_gedag ;};_fdgc +=_gedag -_dgfbc ;switch _edbcf ._gdddf {case CellVerticalAlignmentTop :_fdgc +=_gedag *0.5;case CellVerticalAlignmentBottom :_fdgc -=_gedag *0.5;};_gbeg +=_egafg ._ebgb .Left +_egafg ._ebgb .Right ;_gede +=_egafg ._ebgb .Top +_egafg ._ebgb .Bottom ;
case *Table :_gbeg =_fgeeb ;case *List :_gbeg =_fgeeb ;case *Division :_gbeg =_fgeeb ;case *Chart :_gbeg =_fgeeb ;case *Line :_gede +=_egafg ._dfbfe .Top +_egafg ._dfbfe .Bottom ;_fdgc -=_egafg .Height ()/2;};switch _edbcf ._ggbg {case CellHorizontalAlignmentLeft :_dgfbe .X +=_edbcf ._geag ;
_dgfbe .Width -=_edbcf ._geag ;case CellHorizontalAlignmentCenter :if _efddc :=_fgeeb -_gbeg ;_efddc > 0{_dgfbe .X +=_efddc /2;_dgfbe .Width -=_efddc /2;};case CellHorizontalAlignmentRight :if _fgeeb > _gbeg {_dgfbe .X =_dgfbe .X +_fgeeb -_gbeg -_edbcf ._geag ;
_dgfbe .Width -=_edbcf ._geag ;};};_effd :=_dgfbe .Y ;_efbc :=_dgfbe .Height ;_dgfbe .Y +=_fdgc ;switch _edbcf ._gdddf {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _fedd :=_ffdac -_gede ;_fedd > 0{_dgfbe .Y +=_fedd /2;_dgfbe .Height -=_fedd /2;
};case CellVerticalAlignmentBottom :if _ffdac > _gede {_dgfbe .Y =_dgfbe .Y +_ffdac -_gede ;_dgfbe .Height =_ffdac ;};};_agedf :=_gfecd .DrawWithContext (_edbcf ._ffbee ,_dgfbe );if _agedf !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_agedf );
};_dgfbe .Y =_effd ;_dgfbe .Height =_efbc ;};_dgfbe .Y +=_ffdac ;_dgfbe .Height -=_ffdac ;if _bafb &&_aaga +1> _dbcac {_bdeg +=_bdfgae +_ffdac ;_ffcb -=_ffdac +_bdfgae ;_gbfdg =_gccf ;_aaga =_edacc -1;_bafb =false ;};};_fddee =append (_fddee ,_gfecd );
if _aebe ._afbd .IsAbsolute (){return _fddee ,_cbdde ,nil ;};_dgfbe .X =_cbdde .X ;_dgfbe .Width =_cbdde .Width ;_dgfbe .Y +=_aebe ._edcc .Bottom ;_dgfbe .Height -=_aebe ._edcc .Bottom ;return _fddee ,_dgfbe ,nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_daag *StyledParagraph )SetLineHeight (lineheight float64 ){_daag ._ccfgg =lineheight };

// SetText replaces all the text of the paragraph with the specified one.
func (_badc *StyledParagraph )SetText (text string )*TextChunk {_badc .Reset ();return _badc .Append (text );};

// DrawFooter sets a function to draw a footer on created output pages.
func (_fddb *Creator )DrawFooter (drawFooterFunc func (_dca *Block ,_fcb FooterFunctionArgs )){_fddb ._dcb =drawFooterFunc ;};

// SetInline sets the inline mode of the division.
func (_debda *Division )SetInline (inline bool ){_debda ._bbee =inline };

// InsertColumn inserts a column in the line items table at the specified index.
func (_faafb *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_ddeg :=uint (len (_faafb ._eeec ));if index > _ddeg {index =_ddeg ;};_ggf :=_faafb .NewColumn (description );_faafb ._eeec =append (_faafb ._eeec [:index ],append ([]*InvoiceCell {_ggf },_faafb ._eeec [index :]...)...);
return _ggf ;};func (_efff *StyledParagraph )wrapChunks (_afgbf bool )error {if !_efff ._bfba ||int (_efff ._ceec )<=0{_efff ._fcddb =[][]*TextChunk {_efff ._fgbgc };return nil ;};if _efff ._gacgb {_efff .wrapWordChunks ();};_efff ._fcddb =[][]*TextChunk {};
var _abde []*TextChunk ;var _ecac float64 ;_dabag :=_ed .IsSpace ;if !_afgbf {_dabag =func (rune )bool {return false };};_cgbg :=_bfbda (_efff ._ceec *1000.0,0.000001);for _ ,_baed :=range _efff ._fgbgc {_fgea :=_baed .Style ;_cbca :=_baed ._acdb ;var (_bffg []rune ;
_ecbd []float64 ;);_fcbg :=_abccd (_baed .Text );for _ ,_deggd :=range _baed .Text {if _deggd =='\u000A'{if !_afgbf {_bffg =append (_bffg ,_deggd );};_abde =append (_abde ,&TextChunk {Text :_gga .TrimRightFunc (string (_bffg ),_dabag ),Style :_fgea ,_acdb :_gbba (_cbca )});
_efff ._fcddb =append (_efff ._fcddb ,_abde );_abde =nil ;_ecac =0;_bffg =nil ;_ecbd =nil ;continue ;};_bdga :=_deggd ==' ';_bbdb ,_egecc :=_fgea .Font .GetRuneMetrics (_deggd );if !_egecc {_cf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_deggd );
return _e .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_dcffd :=_fgea .FontSize *_bbdb .Wx *_fgea .horizontalScale ();_bcff :=_dcffd ;if !_bdga {_bcff =_dcffd +_fgea .CharSpacing *1000.0;
};if _ecac +_dcffd > _cgbg {if _efff ._gacgb {if len (_abde )> 0{_efff ._fcddb =append (_efff ._fcddb ,_abde );_abde =[]*TextChunk {};};_bffg =append (_bffg ,_deggd );_ecbd =append (_ecbd ,_bcff );_agbd :=-1;if !_bdga {for _dffc :=len (_bffg )-1;_dffc >=0;
_dffc --{if _bffg [_dffc ]==' '{_agbd =_dffc ;break ;};};};if _agbd >=0{_bffg =_bffg [_agbd +1:];_ecbd =_ecbd [_agbd +1:];};_ecac =0;for _ ,_bbfgf :=range _ecbd {_ecac +=_bbfgf ;};continue ;};_fcgc :=-1;if !_bdga {for _fcfc :=len (_bffg )-1;_fcfc >=0;_fcfc --{if _bffg [_fcfc ]==' '{_fcgc =_fcfc ;
break ;};};};_eebbg :=string (_bffg );if _fcgc >=0{_eebbg =string (_bffg [0:_fcgc +1]);_bffg =_bffg [_fcgc +1:];_bffg =append (_bffg ,_deggd );_ecbd =_ecbd [_fcgc +1:];_ecbd =append (_ecbd ,_bcff );_ecac =0;for _ ,_cdcg :=range _ecbd {_ecac +=_cdcg ;};
}else {if _bdga {_ecac =0;_bffg =[]rune {};_ecbd =[]float64 {};}else {_ecac =_bcff ;_bffg =[]rune {_deggd };_ecbd =[]float64 {_bcff };};};_eebbg =_ggdd (_eebbg ,_fcbg );if !_afgbf &&_bdga {_eebbg +="\u0020";};_abde =append (_abde ,&TextChunk {Text :_gga .TrimRightFunc (_eebbg ,_dabag ),Style :_fgea ,_acdb :_gbba (_cbca )});
_efff ._fcddb =append (_efff ._fcddb ,_abde );_abde =[]*TextChunk {};}else {_ecac +=_bcff ;_bffg =append (_bffg ,_deggd );_ecbd =append (_ecbd ,_bcff );};};if len (_bffg )> 0{_ddfd :=_ggdd (string (_bffg ),_fcbg );_abde =append (_abde ,&TextChunk {Text :_ddfd ,Style :_fgea ,_acdb :_gbba (_cbca )});
};};if len (_abde )> 0{_efff ._fcddb =append (_efff ._fcddb ,_abde );};return nil ;};

// SetBackground sets the background properties of the component.
func (_ddgg *Division )SetBackground (background *Background ){_ddgg ._egfcb =background };

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_cgcad *List )Add (item VectorDrawable )(*TextChunk ,error ){_cddag :=&listItem {_debeb :item ,_dbed :_cgcad ._cfdc };switch _fcged :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _fcged ._dgbb {_fcged ._daedd =15;};default:return nil ,_e .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_cgcad ._eefg =append (_cgcad ._eefg ,_cddag );return &_cddag ._dbed ,nil ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_ddec *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_ddgdd :=&InvoiceCell {_ddec ._agedb ,desc };_bbdf :=&InvoiceCell {_ddec ._agedb ,value };_ddec ._fada =append (_ddec ._fada ,[2]*InvoiceCell {_ddgdd ,_bbdf });return _ddgdd ,_bbdf ;
};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_faded :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_cf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _faded ;
};var _bec ,_fab ,_fedff int ;if len (hexStr )==4{var _fbga ,_bfbd ,_ccb int ;_fgf ,_cfd :=_cb .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_fbga ,&_bfbd ,&_ccb );if _cfd !=nil {_cf .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_cfd );
return _faded ;};if _fgf !=3{_cf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _faded ;};_bec =_fbga *16+_fbga ;_fab =_bfbd *16+_bfbd ;_fedff =_ccb *16+_ccb ;}else {_aad ,_gfg :=_cb .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_bec ,&_fab ,&_fedff );
if _gfg !=nil {_cf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _faded ;};if _aad !=3{_cf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_aad );
return _faded ;};};_fabg :=float64 (_bec )/255.0;_eaged :=float64 (_fab )/255.0;_aeda :=float64 (_fedff )/255.0;_faded ._gafd =_fabg ;_faded ._gfa =_eaged ;_faded ._gcad =_aeda ;return _faded ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_cdb :_d .Min (float64 (c ),100)/100.0,_daeg :_d .Min (float64 (m ),100)/100.0,_fdefb :_d .Min (float64 (y ),100)/100.0,_aedd :_d .Min (float64 (k ),100)/100.0};};func (_gbdeb *templateProcessor )parseTextRenderingModeAttr (_deda ,_daaef string )TextRenderingMode {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_deda ,_daaef );
_ddeca :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_daaef ];
return _ddeca ;};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_ecagd *Table )MultiCell (rowspan ,colspan int )*TableCell {_ecagd ._bdaaf ++;_ffgd :=(_ecagd .moveToNextAvailableCell ()-1)%(_ecagd ._fdeb )+1;_eaccg :=(_ecagd ._bdaaf -1)/_ecagd ._fdeb +1;for _eaccg > _ecagd ._aceec {_ecagd ._aceec ++;_ecagd ._fcga =append (_ecagd ._fcga ,_ecagd ._baegf );
};_bcdg :=&TableCell {};_bcdg ._gdfb =_eaccg ;_bcdg ._fbcc =_ffgd ;_bcdg ._geag =5;_bcdg ._fcbf =CellBorderStyleNone ;_bcdg ._bcffc =_ggb .LineStyleSolid ;_bcdg ._ggbg =CellHorizontalAlignmentLeft ;_bcdg ._gdddf =CellVerticalAlignmentTop ;_bcdg ._aecd =0;
_bcdg ._ecaegf =0;_bcdg ._deff =0;_bcdg ._caca =0;_dgag :=ColorBlack ;_bcdg ._aggf =_dgag ;_bcdg ._cdbab =_dgag ;_bcdg ._ebfcg =_dgag ;_bcdg ._ddgga =_dgag ;if rowspan < 1{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_dffbe :=_ecagd ._aceec -(_bcdg ._gdfb -1);if rowspan > _dffbe {_cf .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_dffbe );
_ecagd ._aceec +=rowspan -1;for _fcbd :=0;_fcbd <=rowspan -_dffbe ;_fcbd ++{_ecagd ._fcga =append (_ecagd ._fcga ,_ecagd ._baegf );};};for _gdcce :=0;_gdcce < colspan &&_ffgd +_gdcce -1< len (_ecagd ._gbdd );_gdcce ++{_ecagd ._gbdd [_ffgd +_gdcce -1]=rowspan -1;
};_bcdg ._fgfbg =rowspan ;if colspan < 1{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_aegca :=_ecagd ._fdeb -(_bcdg ._fbcc -1);if colspan > _aegca {_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_aegca );
colspan =_aegca ;};_bcdg ._dagag =colspan ;_ecagd ._bdaaf +=colspan -1;_ecagd ._edeebg =append (_ecagd ._edeebg ,_bcdg );_bcdg ._bbccb =_ecagd ;return _bcdg ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_babe *Invoice )SetNoteHeadingStyle (style TextStyle ){_babe ._fbaa =style };

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_gedfg *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _gfgd (x ,y ,width ,height );};

// SetBorderColor sets the border color.
func (_abea *Ellipse )SetBorderColor (col Color ){_abea ._eefdg =col };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};func _abdc ()*FilledCurve {_afdf :=FilledCurve {};_afdf ._dbdd =[]_ggb .CubicBezierCurve {};return &_afdf ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_bd *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gf :=_cc .NewContentCreator ();_gee ,_dce :=_bd .Width (),_bd .Height ();if _bd ._bg .IsRelative (){_gf .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_dce );}else {_gf .Translate (_bd ._eda ,ctx .PageHeight -_bd ._cbb -_dce );
};_bc :=_dce ;if _bd ._bf !=0{_gf .Translate (_gee /2,_dce /2);_gf .RotateDeg (_bd ._bf );_gf .Translate (-_gee /2,-_dce /2);_ ,_bc =_bd .RotatedSize ();};if _bd ._bg .IsRelative (){ctx .Y +=_bc ;};_fe :=_bd .duplicate ();_be :=append (*_gf .Operations (),*_fe ._bb ...);
_be .WrapIfNeeded ();_fe ._bb =&_be ;return []*Block {_fe },ctx ,nil ;};

// SetAngle sets the rotation angle of the text.
func (_dagc *Paragraph )SetAngle (angle float64 ){_dagc ._afeg =angle };

// Inline returns whether the inline mode of the division is active.
func (_adae *Division )Inline ()bool {return _adae ._bbee };

// SetMargins sets the Paragraph's margins.
func (_ggdfe *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_ggdfe ._ceadb .Left =left ;_ggdfe ._ceadb .Right =right ;_ggdfe ._ceadb .Top =top ;_ggdfe ._ceadb .Bottom =bottom ;};

// Title returns the title of the invoice.
func (_ebff *Invoice )Title ()string {return _ebff ._caa };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func (_edcd *StyledParagraph )getMaxLineWidth ()float64 {if _edcd ._fcddb ==nil ||len (_edcd ._fcddb )==0{_edcd .wrapText ();};var _gfffb float64 ;for _ ,_bbbd :=range _edcd ._fcddb {_bdbc :=_edcd .getTextLineWidth (_bbbd );
if _bdbc > _gfffb {_gfffb =_bdbc ;};};return _gfffb ;};

// GetCoords returns coordinates of border.
func (_fgg *border )GetCoords ()(float64 ,float64 ){return _fgg ._fcda ,_fgg ._gcc };type templateTag struct{_bbebb map[string ]struct{};_gbadg func (*templateProcessor ,*templateNode )(interface{},error );};func (_eaccc *Table )clone ()*Table {_afea :=*_eaccc ;
_afea ._fcga =make ([]float64 ,len (_eaccc ._fcga ));copy (_afea ._fcga ,_eaccc ._fcga );_afea ._fefbb =make ([]float64 ,len (_eaccc ._fefbb ));copy (_afea ._fefbb ,_eaccc ._fefbb );_afea ._edeebg =make ([]*TableCell ,0,len (_eaccc ._edeebg ));for _ ,_fggfce :=range _eaccc ._edeebg {_abgdb :=*_fggfce ;
_abgdb ._bbccb =&_afea ;_afea ._edeebg =append (_afea ._edeebg ,&_abgdb );};return &_afea ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_fbffe *Paragraph )SetColor (col Color ){_fbffe ._aacbd =col };

// Height returns Rectangle's document height.
func (_ggca *Rectangle )Height ()float64 {return _ggca ._adfff };func _abeacc (_fgde int )*Table {_gffgc :=&Table {_fdeb :_fgde ,_baegf :10.0,_fefbb :[]float64 {},_fcga :[]float64 {},_edeebg :[]*TableCell {},_gbdd :make ([]int ,_fgde ),_degff :true };_gffgc .resetColumnWidths ();
return _gffgc ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func (_ebbab *templateProcessor )addNodeText (_fcdf *templateNode ,_agddfd string )error {_acfd :=_fcdf ._beabg ;if _acfd ==nil {return nil ;
};switch _gdaa :=_acfd .(type ){case *TextChunk :_gdaa .Text =_agddfd ;case *Paragraph :switch _fcdf ._cgfe .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _fcdf ._cfeb !=nil {if _bacd ,_fccec :=_fcdf ._cfeb ._beabg .(*Chapter );
_fccec {_bacd ._bege =_agddfd ;_gdaa .SetText (_bacd .headingText ());};};default:_gdaa .SetText (_agddfd );};};return nil ;};

// Angle returns the block rotation angle in degrees.
func (_gd *Block )Angle ()float64 {return _gd ._bf };func (_cad *Block )addContentsByString (_fcf string )error {_feb :=_cc .NewContentStreamParser (_fcf );_eff ,_fbb :=_feb .Parse ();if _fbb !=nil {return _fbb ;};_cad ._bb .WrapIfNeeded ();_eff .WrapIfNeeded ();
*_cad ._bb =append (*_cad ._bb ,*_eff ...);return nil ;};

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_abcc *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_efbgf []*Block ;_fcgg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_bgadb =ctx ;_afcg ,_ccfd =_abcc ._bdbec ,ctx .PageHeight -_abcc ._fgbd ;_eace ,_ccgga =_abcc ._faec ,ctx .PageHeight -_abcc ._abgf ;
);_gfgg :=_abcc ._bfce .IsRelative ();if _gfgg {ctx .X +=_abcc ._dfbfe .Left ;ctx .Y +=_abcc ._dfbfe .Top ;ctx .Width -=_abcc ._dfbfe .Left +_abcc ._dfbfe .Right ;ctx .Height -=_abcc ._dfbfe .Top +_abcc ._dfbfe .Bottom ;_afcg ,_ccfd ,_eace ,_ccgga =_abcc .computeCoords (ctx );
if _abcc .Height ()> ctx .Height {_efbgf =append (_efbgf ,_fcgg );_fcgg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dcge :=ctx ;_dcge .Y =ctx .Margins .Top +_abcc ._dfbfe .Top ;_dcge .X =ctx .Margins .Left +_abcc ._dfbfe .Left ;_dcge .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_abcc ._dfbfe .Top -_abcc ._dfbfe .Bottom ;
_dcge .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_abcc ._dfbfe .Left -_abcc ._dfbfe .Right ;ctx =_dcge ;_afcg ,_ccfd ,_eace ,_ccgga =_abcc .computeCoords (ctx );};};_dgae :=_ggb .BasicLine {X1 :_afcg ,Y1 :_ccfd ,X2 :_eace ,Y2 :_ccgga ,LineColor :_ffad (_abcc ._ddbb ),Opacity :_abcc ._acbgef ,LineWidth :_abcc ._ffae ,LineStyle :_abcc ._edeg ,DashArray :_abcc ._cefb ,DashPhase :_abcc ._cbaf };
_bdfe ,_eebg :=_fcgg .setOpacity (1.0,_abcc ._acbgef );if _eebg !=nil {return nil ,ctx ,_eebg ;};_bebfc ,_ ,_eebg :=_dgae .Draw (_bdfe );if _eebg !=nil {return nil ,ctx ,_eebg ;};if _eebg =_fcgg .addContentsByString (string (_bebfc ));_eebg !=nil {return nil ,ctx ,_eebg ;
};if _gfgg {ctx .X =_bgadb .X ;ctx .Width =_bgadb .Width ;_gcgfd :=_abcc .Height ();ctx .Y +=_gcgfd +_abcc ._dfbfe .Bottom ;ctx .Height -=_gcgfd ;}else {ctx =_bgadb ;};_efbgf =append (_efbgf ,_fcgg );return _efbgf ,ctx ,nil ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_caf *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_caf ._cefb =dashArray ;_caf ._cbaf =dashPhase ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_caeae *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_caeae .Text },nil ;};var _bfcf []string ;var _fbgff []rune ;var _ccege float64 ;var _cegf []float64 ;_bbcec :=_caeae .Style ;_baea :=_abccd (_caeae .Text );
for _ ,_bcdaa :=range _caeae .Text {if _bcdaa =='\u000A'{_acef :=_ggdd (string (_fbgff ),_baea );_bfcf =append (_bfcf ,_gga .TrimRightFunc (_acef ,_ed .IsSpace )+string (_bcdaa ));_fbgff =nil ;_ccege =0;_cegf =nil ;continue ;};_egecd :=_bcdaa ==' ';_gabcg ,_dgabf :=_bbcec .Font .GetRuneMetrics (_bcdaa );
if !_dgabf {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bcdaa ,_bcdaa ,_bbcec .Font .BaseFont (),_bbcec .Font .Subtype ());
_cf .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bbcec .Font );_cf .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bbcec .Font .Encoder ());return nil ,_e .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_aefd :=_bbcec .FontSize *_gabcg .Wx ;_aaecd :=_aefd ;if !_egecd {_aaecd =_aefd +_bbcec .CharSpacing *1000.0;};if _ccege +_aefd > width *1000.0{_gaead :=-1;if !_egecd {for _adbfg :=len (_fbgff )-1;_adbfg >=0;_adbfg --{if _fbgff [_adbfg ]==' '{_gaead =_adbfg ;
break ;};};};_aced :=string (_fbgff );if _gaead > 0{_aced =string (_fbgff [0:_gaead +1]);_fbgff =append (_fbgff [_gaead +1:],_bcdaa );_cegf =append (_cegf [_gaead +1:],_aaecd );_ccege =0;for _ ,_eacgc :=range _cegf {_ccege +=_eacgc ;};}else {if _egecd {_fbgff =[]rune {};
_cegf =[]float64 {};_ccege =0;}else {_fbgff =[]rune {_bcdaa };_cegf =[]float64 {_aaecd };_ccege =_aaecd ;};};_aced =_ggdd (_aced ,_baea );_bfcf =append (_bfcf ,_gga .TrimRightFunc (_aced ,_ed .IsSpace ));}else {_fbgff =append (_fbgff ,_bcdaa );_ccege +=_aaecd ;
_cegf =append (_cegf ,_aaecd );};};if len (_fbgff )> 0{_gabb :=string (_fbgff );_gabb =_ggdd (_gabb ,_baea );_bfcf =append (_bfcf ,_gabb );};return _bfcf ,nil ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _cggb ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_dfdge :=&Creator {};_dfdge ._gacf =[]*_ddb .PdfPage {};_dfdge ._dfg =map[*_ddb .PdfPage ]*Block {};_dfdge ._effb =map[*_ddb .PdfPage ]*pageTransformations {};
_dfdge .SetPageSize (PageSizeLetter );_cefc :=0.1*_dfdge ._bedd ;_dfdge ._aefe .Left =_cefc ;_dfdge ._aefe .Right =_cefc ;_dfdge ._aefe .Top =_cefc ;_dfdge ._aefe .Bottom =_cefc ;var _fbbb error ;_dfdge ._abcf ,_fbbb =_ddb .NewStandard14Font (_ddb .HelveticaName );
if _fbbb !=nil {_dfdge ._abcf =_ddb .DefaultFont ();};_dfdge ._bgee ,_fbbb =_ddb .NewStandard14Font (_ddb .HelveticaBoldName );if _fbbb !=nil {_dfdge ._abcf =_ddb .DefaultFont ();};_dfdge ._bcdf =_dfdge .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_dfdge .AddOutlines =true ;_dfdge ._dagd =_ddb .NewOutline ();_edc .TrackUse (_cggb );return _dfdge ;};

// NewInvoice returns an instance of an empty invoice.
func (_cade *Creator )NewInvoice ()*Invoice {_egba :=_cade .NewTextStyle ();_egba .Font =_cade ._bgee ;return _eaae (_cade .NewTextStyle (),_egba );};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_cfac *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cfac ._dfbfe .Left ,_cfac ._dfbfe .Right ,_cfac ._dfbfe .Top ,_cfac ._dfbfe .Bottom ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_dfgca DrawContext )([]*Block ,DrawContext ,error );};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_ecbc *Image )SetMargins (left ,right ,top ,bottom float64 ){_ecbc ._abbf .Left =left ;_ecbc ._abbf .Right =right ;_ecbc ._abbf .Top =top ;_ecbc ._abbf .Bottom =bottom ;};func (_affgd *Table )moveToNextAvailableCell ()int {_cebf :=(_affgd ._bdaaf -1)%(_affgd ._fdeb )+1;
for {if _cebf -1>=len (_affgd ._gbdd ){return _cebf ;}else if _affgd ._gbdd [_cebf -1]==0{return _cebf ;}else {_affgd ._bdaaf ++;_affgd ._gbdd [_cebf -1]--;};_cebf ++;};};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_befg *Invoice )AddressHeadingStyle ()TextStyle {return _befg ._gcfe };

// GeneratePageBlocks draws the curve onto page blocks.
func (_gafe *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdcd :=_cc .NewContentCreator ();_cdcd .Add_q ().Add_w (_gafe ._adecf ).SetStrokingColor (_ffad (_gafe ._bda )).Add_m (_gafe ._cdfg ,ctx .PageHeight -_gafe ._abcfd ).Add_v (_gafe ._gdcf ,ctx .PageHeight -_gafe ._dffa ,_gafe ._gebf ,ctx .PageHeight -_gafe ._afgge ).Add_S ().Add_Q ();
_efdf :=_aga .addContentsByString (_cdcd .String ());if _efdf !=nil {return nil ,ctx ,_efdf ;};return []*Block {_aga },ctx ,nil ;};

// NewCell returns a new invoice table cell.
func (_aeddf *Invoice )NewCell (value string )*InvoiceCell {return _aeddf .newCell (value ,_aeddf .NewCellProps ());};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_dbfb *TOCLine )SetLevelOffset (levelOffset float64 ){_dbfb ._eaede =levelOffset ;_dbfb ._aabbg ._ebgb .Left =_dbfb ._fcgb +float64 (_dbfb ._aaaa -1)*_dbfb ._eaede ;};

// Reset removes all the text chunks the paragraph contains.
func (_gcgg *StyledParagraph )Reset (){_gcgg ._fgbgc =[]*TextChunk {}};

// SetIndent sets the left offset of the list when nested into another list.
func (_gdcfe *List )SetIndent (indent float64 ){_gdcfe ._daedd =indent ;_gdcfe ._dgbb =false };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_cdfg float64 ;_abcfd float64 ;_gdcf float64 ;_dffa float64 ;_gebf float64 ;_afgge float64 ;_bda Color ;_adecf float64 ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_eagb *Creator )MoveDown (dy float64 ){_eagb ._fda .Y +=dy };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_dfaa *Creator )MoveRight (dx float64 ){_dfaa ._fda .X +=dx };func (_ecb *Creator )newPage ()*_ddb .PdfPage {_gbfb :=_ddb .NewPdfPage ();_befb :=_ecb ._ggbb [0];_feba :=_ecb ._ggbb [1];_edd :=_ddb .PdfRectangle {Llx :0,Lly :0,Urx :_befb ,Ury :_feba };
_gbfb .MediaBox =&_edd ;_ecb ._bedd =_befb ;_ecb ._edb =_feba ;_ecb .initContext ();return _gbfb ;};func (_gbddd *TableCell )width (_ecfa []float64 ,_gegde float64 )float64 {_bfgbd :=float64 (0.0);for _egeb :=0;_egeb < _gbddd ._dagag ;_egeb ++{_bfgbd +=_ecfa [_gbddd ._fbcc +_egeb -1];
};return _bfgbd *_gegde ;};func (_fgbee *StyledParagraph )split (_aedag DrawContext )(_ccbbb ,_ffcec *StyledParagraph ,_fffge error ){if _fffge =_fgbee .wrapChunks (false );_fffge !=nil {return nil ,nil ,_fffge ;};_acbd :=func (_dddb []*TextChunk ,_agfbb []*TextChunk )[]*TextChunk {if len (_agfbb )==0{return _dddb ;
};_abaddg :=len (_dddb );if _abaddg ==0{return append (_dddb ,_agfbb ...);};if _dddb [_abaddg -1].Style ==_agfbb [0].Style {_dddb [_abaddg -1].Text +=_agfbb [0].Text ;}else {_dddb =append (_dddb ,_agfbb [0]);};return append (_dddb ,_agfbb [1:]...);};_bfdg :=func (_fbgac *StyledParagraph ,_caad []*TextChunk )*StyledParagraph {if len (_caad )==0{return nil ;
};_fbdgg :=*_fbgac ;_fbdgg ._fgbgc =_caad ;return &_fbdgg ;};var (_gefb float64 ;_cfaf []*TextChunk ;_ccdf []*TextChunk ;);for _ ,_cedc :=range _fgbee ._fcddb {var _acgda float64 ;_egbb :=make ([]*TextChunk ,0,len (_cedc ));for _ ,_aead :=range _cedc {if _badcf :=_aead .Style .FontSize ;
_badcf > _acgda {_acgda =_badcf ;};_egbb =append (_egbb ,_aead .clone ());};_acgda *=_fgbee ._ccfgg ;if _fgbee ._egbce .IsRelative (){if _gefb +_acgda > _aedag .Height {_ccdf =_acbd (_ccdf ,_egbb );}else {_cfaf =_acbd (_cfaf ,_egbb );};};_gefb +=_acgda ;
};_fgbee ._fcddb =nil ;if len (_ccdf )==0{return _fgbee ,nil ,nil ;};return _bfdg (_fgbee ,_cfaf ),_bfdg (_fgbee ,_ccdf ),nil ;};

// SetWidthTop sets border width for top.
func (_bdgb *border )SetWidthTop (bw float64 ){_bdgb ._fcc =bw };func (_dfgad *StyledParagraph )wrapText ()error {return _dfgad .wrapChunks (true )};func (_eefe *Invoice )newColumn (_ffegg string ,_cbea CellHorizontalAlignment )*InvoiceCell {_ggga :=&InvoiceCell {_eefe ._aaa ,_ffegg };
_ggga .Alignment =_cbea ;return _ggga ;};func (_eaee *templateProcessor )parsePositioningAttr (_dcfb ,_debcc string )Positioning {_cf .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dcfb ,_debcc );
_ffee :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_debcc ];return _ffee ;};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_gebc *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gegd :=_gebc ;if _gebc ._fgge {_gegd =_gebc .clone ();};return _cbdf (_gegd ,ctx );};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// AddLine adds a new line with the provided style to the table of contents.
func (_eabb *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_eabb ._dacda =append (_eabb ._dacda ,line );return line ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_gfbf *Invoice )Notes ()(string ,string ){return _gfbf ._gade [0],_gfbf ._gade [1]};

// Context returns the current drawing context.
func (_aag *Creator )Context ()DrawContext {return _aag ._fda };const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// Lines returns all the rows of the invoice line items table.
func (_fcec *Invoice )Lines ()[][]*InvoiceCell {return _fcec ._baad };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ebbg *List )Marker ()*TextChunk {return &_ebbg ._cfdc };

// WriteToFile writes the Creator output to file specified by path.
func (_cbbf *Creator )WriteToFile (outputPath string )error {_adec ,_afe :=_c .Create (outputPath );if _afe !=nil {return _afe ;};defer _adec .Close ();return _cbbf .Write (_adec );};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_eagbe *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_cbdc :=&_eagbe ._aabbg ._ebgb ;return _eagbe ._fcgb ,_cbdc .Right ,_cbdc .Top ,_cbdc .Bottom ;};func _cdgba (_abef *Block ,_ddcbf *StyledParagraph ,_cgagb [][]*TextChunk ,_cfgc DrawContext )(DrawContext ,[][]*TextChunk ,error ){_gbac :=1;
_efad :=_a .PdfObjectName (_cb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gbac ));for _abef ._ad .HasFontByName (_efad ){_gbac ++;_efad =_a .PdfObjectName (_cb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gbac ));};_cgda :=_abef ._ad .SetFontByName (_efad ,_ddcbf ._aebg .Font .ToPdfObject ());
if _cgda !=nil {return _cfgc ,nil ,_cgda ;};_gbac ++;_adca :=_efad ;_accc :=_ddcbf ._aebg .FontSize ;_abfbb :=_ddcbf ._egbce .IsRelative ();var _fcddd [][]_a .PdfObjectName ;var _efee [][]*TextChunk ;var _ggea float64 ;for _dffag ,_aceg :=range _cgagb {var _eecd []_a .PdfObjectName ;
var _dcbg float64 ;if len (_aceg )> 0{_dcbg =_aceg [0].Style .FontSize ;};for _ ,_bdfgd :=range _aceg {_ecaeg :=_bdfgd .Style ;if _bdfgd .Text !=""&&_ecaeg .FontSize > _dcbg {_dcbg =_ecaeg .FontSize ;};_efad =_a .PdfObjectName (_cb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gbac ));
_eebc :=_abef ._ad .SetFontByName (_efad ,_ecaeg .Font .ToPdfObject ());if _eebc !=nil {return _cfgc ,nil ,_eebc ;};_eecd =append (_eecd ,_efad );_gbac ++;};_dcbg *=_ddcbf ._ccfgg ;if _abfbb &&_ggea +_dcbg > _cfgc .Height {_efee =_cgagb [_dffag :];_cgagb =_cgagb [:_dffag ];
break ;};_ggea +=_dcbg ;_fcddd =append (_fcddd ,_eecd );};_adegd ,_bcda ,_geea :=_ddcbf .getLineMetrics (0);_cbgda ,_edaed :=_adegd *_ddcbf ._ccfgg ,_bcda *_ddcbf ._ccfgg ;if len (_cgagb )==0{return _cfgc ,_efee ,nil ;};_fcef :=_cc .NewContentCreator ();
_fcef .Add_q ();_acgbc :=_edaed ;if _ddcbf ._abffg ==TextVerticalAlignmentCenter {_acgbc =_bcda +(_adegd +_geea -_bcda )/2+(_edaed -_bcda )/2;};_afbce :=_cfgc .PageHeight -_cfgc .Y -_acgbc ;_fcef .Translate (_cfgc .X ,_afbce );_baafa :=_afbce ;if _ddcbf ._edba !=0{_fcef .RotateDeg (_ddcbf ._edba );
};if _ddcbf ._cgge ==TextOverflowHidden {_fcef .Add_re (0,-_ggea +_cbgda +1,_ddcbf ._ceec ,_ggea ).Add_W ().Add_n ();};_fcef .Add_BT ();var _bdgac []*_ggb .BasicLine ;for _fega ,_dadc :=range _cgagb {_egaf :=_cfgc .X ;var _fefaf float64 ;if len (_dadc )> 0{_fefaf =_dadc [0].Style .FontSize ;
};_adegd ,_ ,_geea =_ddcbf .getLineMetrics (_fega );_edaed =(_adegd +_geea );for _ ,_gabga :=range _dadc {_eega :=&_gabga .Style ;if _gabga .Text !=""&&_eega .FontSize > _fefaf {_fefaf =_eega .FontSize ;};if _edaed > _fefaf {_fefaf =_edaed ;};};if _fega !=0{_fcef .Add_TD (0,-_fefaf *_ddcbf ._ccfgg );
_baafa -=_fefaf *_ddcbf ._ccfgg ;};_ddcg :=_fega ==len (_cgagb )-1;var (_gfgaf float64 ;_bdce float64 ;_afgbfe float64 ;_fcac uint ;);var _ebbgg []float64 ;for _ ,_bbeb :=range _dadc {_bfeg :=&_bbeb .Style ;if _bfeg .FontSize > _bdce {_bdce =_bfeg .FontSize ;
};if _edaed > _bdce {_bdce =_edaed ;};_fdadg ,_afaa :=_bfeg .Font .GetRuneMetrics (' ');if !_afaa {return _cfgc ,nil ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _ffbag uint ;var _ffadg float64 ;_fggg :=len (_bbeb .Text );for _gafga ,_egbe :=range _bbeb .Text {if _egbe ==' '{_ffbag ++;continue ;};if _egbe =='\u000A'{continue ;};_faafe ,_dbaf :=_bfeg .Font .GetRuneMetrics (_egbe );if !_dbaf {_cf .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_egbe );
return _cfgc ,nil ,_e .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_ffadg +=_bfeg .FontSize *_faafe .Wx *_bfeg .horizontalScale ();if _gafga !=_fggg -1{_ffadg +=_bfeg .CharSpacing *1000.0;
};};_ebbgg =append (_ebbgg ,_ffadg );_gfgaf +=_ffadg ;_afgbfe +=float64 (_ffbag )*_fdadg .Wx *_bfeg .FontSize *_bfeg .horizontalScale ();_fcac +=_ffbag ;};_bdce *=_ddcbf ._ccfgg ;var _cggf []_a .PdfObject ;_dgaee :=_ddcbf ._ceec *1000.0;if _ddcbf ._eadg ==TextAlignmentJustify {if _fcac > 0&&!_ddcg {_afgbfe =(_dgaee -_gfgaf )/float64 (_fcac )/_accc ;
};}else if _ddcbf ._eadg ==TextAlignmentCenter {_bdfb :=(_dgaee -_gfgaf -_afgbfe )/2;_affa :=_bdfb /_accc ;_cggf =append (_cggf ,_a .MakeFloat (-_affa ));_egaf +=_bdfb /1000.0;}else if _ddcbf ._eadg ==TextAlignmentRight {_ddcbfa :=(_dgaee -_gfgaf -_afgbfe );
_dfeb :=_ddcbfa /_accc ;_cggf =append (_cggf ,_a .MakeFloat (-_dfeb ));_egaf +=_ddcbfa /1000.0;};if len (_cggf )> 0{_fcef .Add_Tf (_adca ,_accc ).Add_TL (_accc *_ddcbf ._ccfgg ).Add_TJ (_cggf ...);};for _adgg ,_ffdad :=range _dadc {_dbbbg :=&_ffdad .Style ;
_gbfbc :=_adca ;_gfba :=_accc ;_dfaf :=_dbbbg .OutlineColor !=nil ;_adeb :=_dbbbg .HorizontalScaling !=DefaultHorizontalScaling ;_accd :=_dbbbg .OutlineSize !=1;if _accd {_fcef .Add_w (_dbbbg .OutlineSize );};_edde :=_dbbbg .RenderingMode !=TextRenderingModeFill ;
if _edde {_fcef .Add_Tr (int64 (_dbbbg .RenderingMode ));};_gbde :=_dbbbg .CharSpacing !=0;if _gbde {_fcef .Add_Tc (_dbbbg .CharSpacing );};_aefg :=_dbbbg .TextRise !=0;if _aefg {_fcef .Add_Ts (_dbbbg .TextRise );};if _ddcbf ._eadg !=TextAlignmentJustify ||_ddcg {_adbe ,_cgcg :=_dbbbg .Font .GetRuneMetrics (' ');
if !_cgcg {return _cfgc ,nil ,_e .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_gbfbc =_fcddd [_fega ][_adgg ];_gfba =_dbbbg .FontSize ;
_afgbfe =_adbe .Wx *_dbbbg .horizontalScale ();};_dbef :=_dbbbg .Font .Encoder ();var _bafda []byte ;for _ ,_eacd :=range _ffdad .Text {if _eacd =='\u000A'{continue ;};if _eacd ==' '{if len (_bafda )> 0{if _dfaf {_fcef .SetStrokingColor (_ffad (_dbbbg .OutlineColor ));
};if _adeb {_fcef .Add_Tz (_dbbbg .HorizontalScaling );};_fcef .SetNonStrokingColor (_ffad (_dbbbg .Color )).Add_Tf (_fcddd [_fega ][_adgg ],_dbbbg .FontSize ).Add_TJ ([]_a .PdfObject {_a .MakeStringFromBytes (_bafda )}...);_bafda =nil ;};if _adeb {_fcef .Add_Tz (DefaultHorizontalScaling );
};_fcef .Add_Tf (_gbfbc ,_gfba ).Add_TJ ([]_a .PdfObject {_a .MakeFloat (-_afgbfe )}...);_ebbgg [_adgg ]+=_afgbfe *_gfba ;}else {if _ ,_cgga :=_dbef .RuneToCharcode (_eacd );!_cgga {_cgda =UnsupportedRuneError {Message :_cb .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_eacd ,_eacd ),Rune :_eacd };
_cfgc ._ggcf =append (_cfgc ._ggcf ,_cgda );_cf .Log .Debug (_cgda .Error ());if _cfgc ._accf <=0{continue ;};_eacd =_cfgc ._accf ;};_bafda =append (_bafda ,_dbef .Encode (string (_eacd ))...);};};if len (_bafda )> 0{if _dfaf {_fcef .SetStrokingColor (_ffad (_dbbbg .OutlineColor ));
};if _adeb {_fcef .Add_Tz (_dbbbg .HorizontalScaling );};_fcef .SetNonStrokingColor (_ffad (_dbbbg .Color )).Add_Tf (_fcddd [_fega ][_adgg ],_dbbbg .FontSize ).Add_TJ ([]_a .PdfObject {_a .MakeStringFromBytes (_bafda )}...);};_afgbc :=_ebbgg [_adgg ]/1000.0;
if _dbbbg .Underline {_cgfg :=_dbbbg .UnderlineStyle .Color ;if _cgfg ==nil {_cgfg =_ffdad .Style .Color ;};_cccf ,_fbgbf ,_ggfa :=_cgfg .ToRGB ();_caea :=_egaf -_cfgc .X ;_dge :=_baafa -_afbce +_dbbbg .TextRise -_dbbbg .UnderlineStyle .Offset ;_bdgac =append (_bdgac ,&_ggb .BasicLine {X1 :_caea ,Y1 :_dge ,X2 :_caea +_afgbc ,Y2 :_dge ,LineWidth :_ffdad .Style .UnderlineStyle .Thickness ,LineColor :_ddb .NewPdfColorDeviceRGB (_cccf ,_fbgbf ,_ggfa )});
};if _ffdad ._acdb !=nil {var _ccecb *_a .PdfObjectArray ;if !_ffdad ._abcfg {switch _bdae :=_ffdad ._acdb .GetContext ().(type ){case *_ddb .PdfAnnotationLink :_ccecb =_a .MakeArray ();_bdae .Rect =_ccecb ;_febf ,_cbfd :=_bdae .Dest .(*_a .PdfObjectArray );
if _cbfd &&_febf .Len ()==5{_cacc ,_cbbca :=_febf .Get (1).(*_a .PdfObjectName );if _cbbca &&_cacc .String ()=="\u0058\u0059\u005a"{_bgafd ,_cdfd :=_a .GetNumberAsFloat (_febf .Get (3));if _cdfd ==nil {_febf .Set (3,_a .MakeFloat (_cfgc .PageHeight -_bgafd ));
};};};};_ffdad ._abcfg =true ;};if _ccecb !=nil {_bdba :=_ggb .NewPoint (_egaf -_cfgc .X ,_baafa +_dbbbg .TextRise -_afbce ).Rotate (_ddcbf ._edba );_bdba .X +=_cfgc .X ;_bdba .Y +=_afbce ;_ceeg ,_gddfc ,_gcdf ,_fgdf :=_dddd (_afgbc ,_bdce ,_ddcbf ._edba );
_bdba .X +=_ceeg ;_bdba .Y +=_gddfc ;_ccecb .Clear ();_ccecb .Append (_a .MakeFloat (_bdba .X ));_ccecb .Append (_a .MakeFloat (_bdba .Y ));_ccecb .Append (_a .MakeFloat (_bdba .X +_gcdf ));_ccecb .Append (_a .MakeFloat (_bdba .Y +_fgdf ));};_abef .AddAnnotation (_ffdad ._acdb );
};_egaf +=_afgbc ;if _accd {_fcef .Add_w (1.0);};if _dfaf {_fcef .Add_RG (0.0,0.0,0.0);};if _edde {_fcef .Add_Tr (int64 (TextRenderingModeFill ));};if _gbde {_fcef .Add_Tc (0);};if _aefg {_fcef .Add_Ts (0);};if _adeb {_fcef .Add_Tz (DefaultHorizontalScaling );
};};};_fcef .Add_ET ();for _ ,_ccac :=range _bdgac {_fcef .SetStrokingColor (_ccac .LineColor ).Add_w (_ccac .LineWidth ).Add_m (_ccac .X1 ,_ccac .Y1 ).Add_l (_ccac .X2 ,_ccac .Y2 ).Add_s ();};_fcef .Add_Q ();_fcfb :=_fcef .Operations ();_fcfb .WrapIfNeeded ();
_abef .addContents (_fcfb );if _abfbb {_fggdf :=_ggea ;_cfgc .Y +=_fggdf ;_cfgc .Height -=_fggdf ;if _cfgc .Inline {_cfgc .X +=_ddcbf .Width ()+_ddcbf ._ebgb .Right ;};};return _cfgc ,_efee ,nil ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_dfbg *Ellipse )GetCoords ()(float64 ,float64 ){return _dfbg ._gdge ,_dfbg ._befbf };

// Scale scales Image by a constant factor, both width and height.
func (_ceda *Image )Scale (xFactor ,yFactor float64 ){_ceda ._ddac =xFactor *_ceda ._ddac ;_ceda ._fdca =yFactor *_ceda ._fdca ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_dbdd []_ggb .CubicBezierCurve ;FillEnabled bool ;_fefb Color ;BorderEnabled bool ;BorderWidth float64 ;_aged Color ;};var _efbd =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_agfg },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_bbebb :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_gbadg :_eaab },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_abede },"\u0074\u0061\u0062l\u0065":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_cefg },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_bbebb :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_gbadg :_gagd },"\u006c\u0069\u006e\u0065":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_bcbfg },"\u0069\u006d\u0061g\u0065":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_gded },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_eagfa },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_bbebb :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_gcaf },"\u0063\u0068\u0061r\u0074":&templateTag {_bbebb :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_gbadg :_dgbf },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_bbebb :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_gbadg :_cbce }};


// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_ffbe *Division )Width ()float64 {return 0};func (_bbbb *templateProcessor )parseCellAlignmentAttr (_feggc ,_fbgf string )CellHorizontalAlignment {_cf .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_feggc ,_fbgf );
_aadf :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_fbgf ];return _aadf ;
};func (_cbgga *Division )drawBackground (_fbff []*Block ,_feffe ,_cdag DrawContext ,_gdfa bool )([]*Block ,error ){_febb :=len (_fbff );if _febb ==0||_cbgga ._egfcb ==nil {return _fbff ,nil ;};_afbga :=make ([]*Block ,0,len (_fbff ));for _gfga ,_eegg :=range _fbff {var (_abadd =_cbgga ._egfcb .BorderRadiusTopLeft ;
_geedc =_cbgga ._egfcb .BorderRadiusTopRight ;_eacgd =_cbgga ._egfcb .BorderRadiusBottomLeft ;_gcadc =_cbgga ._egfcb .BorderRadiusBottomRight ;);_afggg :=_feffe ;_afggg .Page +=_gfga ;if _gfga ==0{if _gdfa {_afbga =append (_afbga ,_eegg );continue ;};if _febb ==1{_afggg .Height =_cdag .Y -_feffe .Y ;
};}else {_afggg .X =_afggg .Margins .Left +_cbgga ._acdf .Left ;_afggg .Y =_afggg .Margins .Top ;_afggg .Width =_afggg .PageWidth -_afggg .Margins .Left -_afggg .Margins .Right -_cbgga ._acdf .Left -_cbgga ._acdf .Right ;if _gfga ==_febb -1{_afggg .Height =_cdag .Y -_afggg .Margins .Top -_cbgga ._acdf .Top ;
}else {_afggg .Height =_afggg .PageHeight -_afggg .Margins .Top -_afggg .Margins .Bottom ;};if !_gdfa {_abadd =0;_geedc =0;};};if _febb > 1&&_gfga !=_febb -1{_eacgd =0;_gcadc =0;};_dfee :=_gfgd (_afggg .X ,_afggg .Y ,_afggg .Width ,_afggg .Height );_dfee .SetFillColor (_cbgga ._egfcb .FillColor );
_dfee .SetBorderColor (_cbgga ._egfcb .BorderColor );_dfee .SetBorderWidth (_cbgga ._egfcb .BorderSize );_dfee .SetBorderRadius (_abadd ,_geedc ,_eacgd ,_gcadc );_defa ,_ ,_edfe :=_dfee .GeneratePageBlocks (_afggg );if _edfe !=nil {return nil ,_edfe ;};
if len (_defa )==0{continue ;};_bcga :=_defa [0];if _edfe =_bcga .mergeBlocks (_eegg );_edfe !=nil {return nil ,_edfe ;};_afbga =append (_afbga ,_bcga );};return _afbga ,nil ;};func (_bbe *Creator )getActivePage ()*_ddb .PdfPage {if _bbe ._ecfb ==nil {if len (_bbe ._gacf )==0{return nil ;
};return _bbe ._gacf [len (_bbe ._gacf )-1];};return _bbe ._ecfb ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cbfb *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _cbfb ._fegd [0],_cbfb ._fegd [1]};func (_daca *Creator )initContext (){_daca ._fda .X =_daca ._aefe .Left ;_daca ._fda .Y =_daca ._aefe .Top ;_daca ._fda .Width =_daca ._bedd -_daca ._aefe .Right -_daca ._aefe .Left ;
_daca ._fda .Height =_daca ._edb -_daca ._aefe .Bottom -_daca ._aefe .Top ;_daca ._fda .PageHeight =_daca ._edb ;_daca ._fda .PageWidth =_daca ._bedd ;_daca ._fda .Margins =_daca ._aefe ;_daca ._fda ._accf =_daca .UnsupportedCharacterReplacement ;};func (_acaa *Table )updateRowHeights (_gbab float64 ){for _ ,_dffae :=range _acaa ._edeebg {_ecfbc :=_dffae .width (_acaa ._fefbb ,_gbab );
_dbab :=_acaa ._fcga [_dffae ._gdfb +_dffae ._fgfbg -2];if _gcfge :=_dffae .height (_ecfbc );_gcfge > _dbab {_fdea :=_gcfge /float64 (_dffae ._fgfbg );for _fadba :=1;_fadba <=_dffae ._fgfbg ;_fadba ++{if _fdea > _acaa ._fcga [_dffae ._gdfb +_fadba -2]{_acaa ._fcga [_dffae ._gdfb +_fadba -2]=_fdea ;
};};};};};

// SetMargins sets the margins of the chart component.
func (_eage *Chart )SetMargins (left ,right ,top ,bottom float64 ){_eage ._cfg .Left =left ;_eage ._cfg .Right =right ;_eage ._cfg .Top =top ;_eage ._cfg .Bottom =bottom ;};

// SkipOver skips over a specified number of rows and cols.
func (_baee *Table )SkipOver (rows ,cols int ){_fgad :=rows *_baee ._fdeb +cols -1;if _fgad < 0{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_baee ._bdaaf +=_fgad ;};func (_egeec *templateProcessor )parseLineStyleAttr (_debgd ,_ccga string )_ggb .LineStyle {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_debgd ,_ccga );
_beca :=map[string ]_ggb .LineStyle {"\u0073\u006f\u006ci\u0064":_ggb .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_ggb .LineStyleDashed }[_ccga ];return _beca ;};func (_gfef *Invoice )generateNoteBlocks (_gedg DrawContext )([]*Block ,DrawContext ,error ){_bcee :=_dbg ();
_abadb :=append ([][2]string {_gfef ._gade ,_gfef ._dbdf },_gfef ._fdbc ...);for _ ,_geedb :=range _abadb {if _geedb [1]!=""{_cfed :=_gfef .drawSection (_geedb [0],_geedb [1]);for _ ,_beebe :=range _cfed {_bcee .Add (_beebe );};_bgaf :=_fgee (_gfef ._dbecf );
_bgaf .SetMargins (0,0,10,0);_bcee .Add (_bgaf );};};return _bcee .GeneratePageBlocks (_gedg );};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_ecfd *_ggb .Polyline ;_dcdff float64 ;};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_adbdd *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcbff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdgb ,_dgdf :=_dcbff .setOpacity (_adbdd ._fabae ,_adbdd ._adbf );if _dgdf !=nil {return nil ,ctx ,_dgdf ;
};_aaab :=_adbdd ._gcga ;_aaab .FillEnabled =_aaab .FillColor !=nil ;_aaab .BorderEnabled =_aaab .BorderColor !=nil &&_aaab .BorderWidth > 0;_dcgeg :=_aaab .Points ;for _gddg :=range _dcgeg {for _fbae :=range _dcgeg [_gddg ]{_ecdc :=&_dcgeg [_gddg ][_fbae ];
_ecdc .Y =ctx .PageHeight -_ecdc .Y ;};};_daeb ,_ ,_dgdf :=_aaab .Draw (_cdgb );if _dgdf !=nil {return nil ,ctx ,_dgdf ;};if _dgdf =_dcbff .addContentsByString (string (_daeb ));_dgdf !=nil {return nil ,ctx ,_dgdf ;};return []*Block {_dcbff },ctx ,nil ;
};

// SetBorderColor sets the border color for the path.
func (_cbgfd *FilledCurve )SetBorderColor (color Color ){_cbgfd ._aged =color };

// SetBorderWidth sets the border width.
func (_bfab *Ellipse )SetBorderWidth (bw float64 ){_bfab ._baeb =bw };func _ffeb (_bdaa []_ggb .Point )*Polyline {return &Polyline {_ecfd :&_ggb .Polyline {Points :_bdaa ,LineColor :_ddb .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_dcdff :1.0};};func (_adfc *Image )applyFitMode (_ddcb float64 ){_ddcb -=_adfc ._abbf .Left +_adfc ._abbf .Right ;
switch _adfc ._cagg {case FitModeFillWidth :_adfc .ScaleToWidth (_ddcb );};};func (_gdefa *StyledParagraph )getTextWidth ()float64 {var _gbg float64 ;_ddabd :=len (_gdefa ._fgbgc );for _agfdg ,_cabc :=range _gdefa ._fgbgc {_cbedc :=&_cabc .Style ;_ccdef :=len (_cabc .Text );
for _adeg ,_bdda :=range _cabc .Text {if _bdda =='\u000A'{continue ;};_feggf ,_afae :=_cbedc .Font .GetRuneMetrics (_bdda );if !_afae {_cf .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bdda );
return -1;};_gbg +=_cbedc .FontSize *_feggf .Wx *_cbedc .horizontalScale ();if _bdda !=' '&&(_agfdg !=_ddabd -1||_adeg !=_ccdef -1){_gbg +=_cbedc .CharSpacing *1000.0;};};};return _gbg ;};func (_ffcg *Paragraph )wrapText ()error {if !_ffcg ._ccad ||int (_ffcg ._aeea )<=0{_ffcg ._bfbc =[]string {_ffcg ._aadgg };
return nil ;};_cdcc :=NewTextChunk (_ffcg ._aadgg ,TextStyle {Font :_ffcg ._bbea ,FontSize :_ffcg ._fabb });_abfb ,_bgfb :=_cdcc .Wrap (_ffcg ._aeea );if _bgfb !=nil {return _bgfb ;};if _ffcg ._dcad > 0&&len (_abfb )> _ffcg ._dcad {_abfb =_abfb [:_ffcg ._dcad ];
};_ffcg ._bfbc =_abfb ;return nil ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_gead *Table )MultiRowCell (rowspan int )*TableCell {return _gead .MultiCell (rowspan ,1)};func _adbd (_dfec string )(*Image ,error ){_bbce ,_ddfa :=_c .Open (_dfec );if _ddfa !=nil {return nil ,_ddfa ;};defer _bbce .Close ();_dgcb ,_ddfa :=_ddb .ImageHandling .Read (_bbce );
if _ddfa !=nil {_cf .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ddfa );return nil ,_ddfa ;};return _gebg (_dgcb );};func (_gccbd *templateProcessor )parseTextAlignmentAttr (_geada ,_gafbb string )TextAlignment {_cf .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_geada ,_gafbb );
_bfdeg :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_gafbb ];
return _bfdeg ;};

// SetBorderOpacity sets the border opacity.
func (_afba *Rectangle )SetBorderOpacity (opacity float64 ){_afba ._dcdd =opacity };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);
ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_edbc *Creator )AddPage (page *_ddb .PdfPage )error {_fabd ,_gbe :=page .GetMediaBox ();if _gbe !=nil {_cf .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_gbe );
return _gbe ;};_fabd .Normalize ();_egb ,_def :=_fabd .Llx ,_fabd .Lly ;_afbcd :=_faf .IdentityMatrix ();_ddgd ,_gbe :=page .GetRotate ();if _gbe !=nil {_cf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_gbe .Error ());
};_bdcb :=_ddgd %360!=0&&_ddgd %90==0;if _bdcb {_gdfc :=float64 ((360+_ddgd %360)%360);if _gdfc ==90{_afbcd =_afbcd .Translate (_fabd .Width (),0);}else if _gdfc ==180{_afbcd =_afbcd .Translate (_fabd .Width (),_fabd .Height ());}else if _gdfc ==270{_afbcd =_afbcd .Translate (0,_fabd .Height ());
};_afbcd =_afbcd .Mult (_faf .RotationMatrix (_gdfc *_d .Pi /180));_afbcd =_afbcd .Round (0.000001);_ffc :=_ffcbe (_fabd ,_afbcd );_fabd =_ffc ;_fabd .Normalize ();};if _egb !=0||_def !=0{_afbcd =_faf .TranslationMatrix (_egb ,_def ).Mult (_afbcd );};if !_afbcd .Identity (){_afbcd =_afbcd .Round (0.000001);
_edbc ._effb [page ]=&pageTransformations {_befe :&_afbcd };};_edbc ._bedd =_fabd .Width ();_edbc ._edb =_fabd .Height ();_edbc .initContext ();_edbc ._gacf =append (_edbc ._gacf ,page );_edbc ._fda .Page ++;return nil ;};

// NewCellProps returns the default properties of an invoice cell.
func (_agdf *Invoice )NewCellProps ()InvoiceCellProps {_fbdaf :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_agdf ._dbecf ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_fbdaf ,BorderColor :_fbdaf ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_eacg *Creator )Flip (flipH ,flipV bool )error {_gde :=_eacg .getActivePage ();if _gde ==nil {return _e .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_gaa ,_agf :=_eacg ._effb [_gde ];if !_agf {_gaa =&pageTransformations {};
_eacg ._effb [_gde ]=_gaa ;};_gaa ._cec =flipH ;_gaa ._cdc =flipV ;return nil ;};var (_dega =_gb .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");_dagdb =_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");
_cbbfe =_e .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");_aaedd =_e .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");
_accac =_e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e"););

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_eadf *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eadf ._ebgb .Left ,_eadf ._ebgb .Right ,_eadf ._ebgb .Top ,_eadf ._ebgb .Bottom ;};type templateNode struct{_beabg interface{};_cgfe _fg .StartElement ;_cfeb *templateNode ;
};func _fead (_daba []_ggb .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bddf :&_ggb .PolyBezierCurve {Curves :_daba ,BorderColor :_ddb .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_fggfc :1.0,_babf :1.0};};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_cdab *Creator )NewPage ()*_ddb .PdfPage {_abgb :=_cdab .newPage ();_cdab ._gacf =append (_cdab ._gacf ,_abgb );_cdab ._fda .Page ++;return _abgb ;};

// GetRowHeight returns the height of the specified row.
func (_fgfd *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_fgfd ._fcga ){return 0,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _fgfd ._fcga [row -1],nil ;
};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ddee *Creator )SetPageLabels (pageLabels _a .PdfObject ){_ddee ._ecef =pageLabels };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_acbge *Division )Height ()float64 {var _ccfe float64 ;for _ ,_adea :=range _acbge ._bfcd {switch _aeag :=_adea .(type ){case marginDrawable :_ ,_ ,_gfdg ,_fcg :=_aeag .GetMargins ();_ccfe +=_aeag .Height ()+_gfdg +_fcg ;default:_ccfe +=_aeag .Height ();
};};return _ccfe ;};

// SetBackgroundColor sets the cell's background color.
func (_eaed *TableCell )SetBackgroundColor (col Color ){_eaed ._dee =col };

// SetBorderWidth sets the border width.
func (_caaa *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_caaa ._bddf .BorderWidth =borderWidth ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_gcga *_ggb .Polygon ;_fabae float64 ;_adbf float64 ;};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_cbde *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gaba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ggbag ,_afaf :=_gaba .setOpacity (_cbde ._afgd ,_cbde ._cdaaa );if _afaf !=nil {return nil ,ctx ,_afaf ;
};_dfga :=_cbde ._efdg ;_dfga .FillEnabled =_dfga .FillColor !=nil ;_dfga .BorderEnabled =_dfga .BorderColor !=nil &&_dfga .BorderWidth > 0;var (_gbbda =ctx .PageHeight ;_fgce =_dfga .Rings ;_gbbed =make ([][]_ggb .CubicBezierCurve ,0,len (_dfga .Rings ));
);for _ ,_fbfb :=range _fgce {_cbee :=make ([]_ggb .CubicBezierCurve ,0,len (_fbfb ));for _ ,_gcgf :=range _fbfb {_ddaf :=_gcgf ;_ddaf .P0 .Y =_gbbda -_ddaf .P0 .Y ;_ddaf .P1 .Y =_gbbda -_ddaf .P1 .Y ;_ddaf .P2 .Y =_gbbda -_ddaf .P2 .Y ;_ddaf .P3 .Y =_gbbda -_ddaf .P3 .Y ;
_cbee =append (_cbee ,_ddaf );};_gbbed =append (_gbbed ,_cbee );};_dfga .Rings =_gbbed ;defer func (){_dfga .Rings =_fgce }();_aacbe ,_ ,_afaf :=_dfga .Draw (_ggbag );if _afaf !=nil {return nil ,ctx ,_afaf ;};if _afaf =_gaba .addContentsByString (string (_aacbe ));
_afaf !=nil {return nil ,ctx ,_afaf ;};return []*Block {_gaba },ctx ,nil ;};

// GeneratePageBlocks implements drawable interface.
func (_feca *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egac :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_de :=_feca ._fcda ;_bged :=ctx .PageHeight -_feca ._gcc ;if _feca ._dda !=nil {_aef :=_ggb .Rectangle {Opacity :1.0,X :_feca ._fcda ,Y :ctx .PageHeight -_feca ._gcc -_feca ._cbdd ,Height :_feca ._cbdd ,Width :_feca ._ebba };
_aef .FillEnabled =true ;_aef .FillColor =_ffad (_feca ._dda );_aef .BorderEnabled =false ;_dfcb ,_ ,_bgfe :=_aef .Draw ("");if _bgfe !=nil {return nil ,ctx ,_bgfe ;};_bgfe =_egac .addContentsByString (string (_dfcb ));if _bgfe !=nil {return nil ,ctx ,_bgfe ;
};};_edee :=_feca ._fcc ;_ggac :=_feca ._ede ;_bfe :=_feca ._ebf ;_adcb :=_feca ._eec ;_bfdd :=_feca ._fcc ;if _feca ._beag ==CellBorderStyleDouble {_bfdd +=2*_edee ;};_bgde :=_feca ._ede ;if _feca ._dfd ==CellBorderStyleDouble {_bgde +=2*_ggac ;};_aeef :=_feca ._ebf ;
if _feca ._bdfg ==CellBorderStyleDouble {_aeef +=2*_bfe ;};_fdef :=_feca ._eec ;if _feca ._fdc ==CellBorderStyleDouble {_fdef +=2*_adcb ;};_gefe :=(_bfdd -_aeef )/2;_acd :=(_bfdd -_fdef )/2;_caba :=(_bgde -_aeef )/2;_ggd :=(_bgde -_fdef )/2;if _feca ._fcc !=0{_bdd :=_de ;
_ccd :=_bged ;if _feca ._beag ==CellBorderStyleDouble {_ccd -=_edee ;_bfb :=_ggb .BasicLine {LineColor :_ffad (_feca ._gdb ),Opacity :1.0,LineWidth :_feca ._fcc ,LineStyle :_feca .LineStyle ,X1 :_bdd -_bfdd /2+_gefe ,Y1 :_ccd +2*_edee ,X2 :_bdd +_bfdd /2-_acd +_feca ._ebba ,Y2 :_ccd +2*_edee };
_dbee ,_ ,_bfddd :=_bfb .Draw ("");if _bfddd !=nil {return nil ,ctx ,_bfddd ;};_bfddd =_egac .addContentsByString (string (_dbee ));if _bfddd !=nil {return nil ,ctx ,_bfddd ;};};_ebe :=_ggb .BasicLine {LineWidth :_feca ._fcc ,Opacity :1.0,LineColor :_ffad (_feca ._gdb ),LineStyle :_feca .LineStyle ,X1 :_bdd -_bfdd /2+_gefe +(_aeef -_feca ._ebf ),Y1 :_ccd ,X2 :_bdd +_bfdd /2-_acd +_feca ._ebba -(_fdef -_feca ._eec ),Y2 :_ccd };
_abac ,_ ,_cfef :=_ebe .Draw ("");if _cfef !=nil {return nil ,ctx ,_cfef ;};_cfef =_egac .addContentsByString (string (_abac ));if _cfef !=nil {return nil ,ctx ,_cfef ;};};if _feca ._ede !=0{_fgec :=_de ;_cefa :=_bged -_feca ._cbdd ;if _feca ._dfd ==CellBorderStyleDouble {_cefa +=_ggac ;
_cdda :=_ggb .BasicLine {LineWidth :_feca ._ede ,Opacity :1.0,LineColor :_ffad (_feca ._gac ),LineStyle :_feca .LineStyle ,X1 :_fgec -_bgde /2+_caba ,Y1 :_cefa -2*_ggac ,X2 :_fgec +_bgde /2-_ggd +_feca ._ebba ,Y2 :_cefa -2*_ggac };_feeg ,_ ,_bba :=_cdda .Draw ("");
if _bba !=nil {return nil ,ctx ,_bba ;};_bba =_egac .addContentsByString (string (_feeg ));if _bba !=nil {return nil ,ctx ,_bba ;};};_bcbf :=_ggb .BasicLine {LineWidth :_feca ._ede ,Opacity :1.0,LineColor :_ffad (_feca ._gac ),LineStyle :_feca .LineStyle ,X1 :_fgec -_bgde /2+_caba +(_aeef -_feca ._ebf ),Y1 :_cefa ,X2 :_fgec +_bgde /2-_ggd +_feca ._ebba -(_fdef -_feca ._eec ),Y2 :_cefa };
_aeg ,_ ,_efb :=_bcbf .Draw ("");if _efb !=nil {return nil ,ctx ,_efb ;};_efb =_egac .addContentsByString (string (_aeg ));if _efb !=nil {return nil ,ctx ,_efb ;};};if _feca ._ebf !=0{_dec :=_de ;_fed :=_bged ;if _feca ._bdfg ==CellBorderStyleDouble {_dec +=_bfe ;
_agc :=_ggb .BasicLine {LineWidth :_feca ._ebf ,Opacity :1.0,LineColor :_ffad (_feca ._adb ),LineStyle :_feca .LineStyle ,X1 :_dec -2*_bfe ,Y1 :_fed +_aeef /2+_gefe ,X2 :_dec -2*_bfe ,Y2 :_fed -_aeef /2-_caba -_feca ._cbdd };_ddae ,_ ,_effa :=_agc .Draw ("");
if _effa !=nil {return nil ,ctx ,_effa ;};_effa =_egac .addContentsByString (string (_ddae ));if _effa !=nil {return nil ,ctx ,_effa ;};};_feff :=_ggb .BasicLine {LineWidth :_feca ._ebf ,Opacity :1.0,LineColor :_ffad (_feca ._adb ),LineStyle :_feca .LineStyle ,X1 :_dec ,Y1 :_fed +_aeef /2+_gefe -(_bfdd -_feca ._fcc ),X2 :_dec ,Y2 :_fed -_aeef /2-_caba -_feca ._cbdd +(_bgde -_feca ._ede )};
_dgc ,_ ,_ddab :=_feff .Draw ("");if _ddab !=nil {return nil ,ctx ,_ddab ;};_ddab =_egac .addContentsByString (string (_dgc ));if _ddab !=nil {return nil ,ctx ,_ddab ;};};if _feca ._eec !=0{_aff :=_de +_feca ._ebba ;_ceg :=_bged ;if _feca ._fdc ==CellBorderStyleDouble {_aff -=_adcb ;
_gabf :=_ggb .BasicLine {LineWidth :_feca ._eec ,Opacity :1.0,LineColor :_ffad (_feca ._bfd ),LineStyle :_feca .LineStyle ,X1 :_aff +2*_adcb ,Y1 :_ceg +_fdef /2+_acd ,X2 :_aff +2*_adcb ,Y2 :_ceg -_fdef /2-_ggd -_feca ._cbdd };_gda ,_ ,_bgg :=_gabf .Draw ("");
if _bgg !=nil {return nil ,ctx ,_bgg ;};_bgg =_egac .addContentsByString (string (_gda ));if _bgg !=nil {return nil ,ctx ,_bgg ;};};_efa :=_ggb .BasicLine {LineWidth :_feca ._eec ,Opacity :1.0,LineColor :_ffad (_feca ._bfd ),LineStyle :_feca .LineStyle ,X1 :_aff ,Y1 :_ceg +_fdef /2+_acd -(_bfdd -_feca ._fcc ),X2 :_aff ,Y2 :_ceg -_fdef /2-_ggd -_feca ._cbdd +(_bgde -_feca ._ede )};
_dac ,_ ,_fegb :=_efa .Draw ("");if _fegb !=nil {return nil ,ctx ,_fegb ;};_fegb =_egac .addContentsByString (string (_dac ));if _fegb !=nil {return nil ,ctx ,_fegb ;};};return []*Block {_egac },ctx ,nil ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_egaa *TOC )SetLineSeparatorStyle (style TextStyle ){_egaa ._dgbba =style };func (_ccbg *Paragraph )getMaxLineWidth ()float64 {if _ccbg ._bfbc ==nil ||len (_ccbg ._bfbc )==0{_ccbg .wrapText ();};var _ddbd float64 ;for _ ,_ggbf :=range _ccbg ._bfbc {_cgd :=_ccbg .getTextLineWidth (_ggbf );
if _cgd > _ddbd {_ddbd =_cgd ;};};return _ddbd ;};func _ecage (_cfeff *_ddb .PdfAnnotationLink )*_ddb .PdfAnnotationLink {if _cfeff ==nil {return nil ;};_caceg :=_ddb .NewPdfAnnotationLink ();_caceg .BS =_cfeff .BS ;_caceg .A =_cfeff .A ;if _gbcbe ,_ccdag :=_cfeff .GetAction ();
_ccdag ==nil &&_gbcbe !=nil {_caceg .SetAction (_gbcbe );};if _cdde ,_fdffd :=_cfeff .Dest .(*_a .PdfObjectArray );_fdffd {_caceg .Dest =_a .MakeArray (_cdde .Elements ()...);};return _caceg ;};

// SkipRows skips over a specified number of rows in the table.
func (_gaea *Table )SkipRows (num int ){_ebffb :=num *_gaea ._fdeb -1;if _ebffb < 0{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gaea ._bdaaf +=_ebffb ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_fadgf *Creator )MoveTo (x ,y float64 ){_fadgf ._fda .X =x ;_fadgf ._fda .Y =y };func (_cfeg *templateProcessor )run ()error {_agec :=_fg .NewDecoder (_ea .NewReader (_cfeg ._bcbe ));var _abca *templateNode ;for {_fgga ,_ggccg :=_agec .Token ();if _ggccg !=nil {if _ggccg ==_dd .EOF {return nil ;
};return _ggccg ;};if _fgga ==nil {break ;};switch _adac :=_fgga .(type ){case _fg .StartElement :_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_adac .Name .Local );
_ccfdc ,_efef :=_efbd [_adac .Name .Local ];if !_efef {_cf .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074a\u0067\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075t\u0070\u0075t\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_adac .Name .Local );
continue ;};_abca =&templateNode {_cgfe :_adac ,_cfeb :_abca };if _gbagg :=_ccfdc ._gbadg ;_gbagg !=nil {_abca ._beabg ,_ggccg =_gbagg (_cfeg ,_abca );if _ggccg !=nil {return _ggccg ;};};case _fg .EndElement :_cf .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_adac .Name .Local );
if _abca !=nil {if _abca ._beabg !=nil {if _ecee :=_cfeg .renderNode (_abca );_ecee !=nil {return _ecee ;};};_abca =_abca ._cfeb ;};case _fg .CharData :if _abca !=nil &&_abca ._beabg !=nil {if _gacgg :=_cfeg .addNodeText (_abca ,string (_adac ));_gacgg !=nil {return _gacgg ;
};};case _fg .Comment :_cf .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_adac ));};};return nil ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_cag *Creator )DrawTemplate (r _dd .Reader ,data interface{},options *TemplateOptions )error {return _cagc (_cag ,r ,data ,options ,_cag );};func (_ecagde *templateProcessor )parseLine (_adegef *templateNode )(interface{},error ){_cbcg :=_ecagde .creator .NewLine (0,0,0,0);
for _ ,_eccb :=range _adegef ._cgfe .Attr {_abbb :=_eccb .Value ;switch _cedg :=_eccb .Name .Local ;_cedg {case "\u0078\u0031":_cbcg ._bdbec =_ecagde .parseFloatAttr (_cedg ,_abbb );case "\u0079\u0031":_cbcg ._fgbd =_ecagde .parseFloatAttr (_cedg ,_abbb );
case "\u0078\u0032":_cbcg ._faec =_ecagde .parseFloatAttr (_cedg ,_abbb );case "\u0079\u0032":_cbcg ._abgf =_ecagde .parseFloatAttr (_cedg ,_abbb );case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_cbcg .SetLineWidth (_ecagde .parseFloatAttr (_cedg ,_abbb ));
case "\u0063\u006f\u006co\u0072":_cbcg .SetColor (_ecagde .parseColorAttr (_cedg ,_abbb ));case "\u0073\u0074\u0079l\u0065":_cbcg .SetStyle (_ecagde .parseLineStyleAttr (_cedg ,_abbb ));case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_cbcg .SetDashPattern (_ecagde .parseInt64Array (_cedg ,_abbb ),_cbcg ._cbaf );
case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_cbcg .SetDashPattern (_cbcg ._cefb ,_ecagde .parseInt64Attr (_cedg ,_abbb ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_cbcg .SetOpacity (_ecagde .parseFloatAttr (_cedg ,_abbb ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_cbcg .SetPositioning (_ecagde .parsePositioningAttr (_cedg ,_abbb ));
case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_cbcg .SetFitMode (_ecagde .parseFitModeAttr (_cedg ,_abbb ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_egag :=_ecagde .parseMarginAttr (_cedg ,_abbb );_cbcg .SetMargins (_egag .Left ,_egag .Right ,_egag .Top ,_egag .Bottom );
default:_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cedg );
};};return _cbcg ,nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dgagf *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dgagf ._ggbg =halign ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_bdcd *Image )SetPos (x ,y float64 ){_bdcd ._bfee =PositionAbsolute ;_bdcd ._afcd =x ;_bdcd ._begb =y ;};

// Width returns Image's document width.
func (_aeee *Image )Width ()float64 {return _aeee ._ddac };

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_dbd *Creator )SetOptimizer (optimizer _ddb .Optimizer ){_dbd ._gbfd =optimizer };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gadg *Invoice )SetAddressStyle (style TextStyle ){_gadg ._dcaa =style };func (_bdaae *templateProcessor )parseMarginAttr (_efed ,_abdcb string )Margins {_cf .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_efed ,_abdcb );
_cffab :=Margins {};switch _fafgg :=_gga .Fields (_abdcb );len (_fafgg ){case 1:_cffab .Top ,_ =_gg .ParseFloat (_fafgg [0],64);_cffab .Bottom =_cffab .Top ;_cffab .Left =_cffab .Top ;_cffab .Right =_cffab .Top ;case 2:_cffab .Top ,_ =_gg .ParseFloat (_fafgg [0],64);
_cffab .Bottom =_cffab .Top ;_cffab .Left ,_ =_gg .ParseFloat (_fafgg [1],64);_cffab .Right =_cffab .Left ;case 3:_cffab .Top ,_ =_gg .ParseFloat (_fafgg [0],64);_cffab .Left ,_ =_gg .ParseFloat (_fafgg [1],64);_cffab .Right =_cffab .Left ;_cffab .Bottom ,_ =_gg .ParseFloat (_fafgg [2],64);
case 4:_cffab .Top ,_ =_gg .ParseFloat (_fafgg [0],64);_cffab .Right ,_ =_gg .ParseFloat (_fafgg [1],64);_cffab .Bottom ,_ =_gg .ParseFloat (_fafgg [2],64);_cffab .Left ,_ =_gg .ParseFloat (_fafgg [3],64);};return _cffab ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_aadgg string ;_bbea *_ddb .PdfFont ;_fabb float64 ;_gggdb float64 ;_aacbd Color ;_cccg TextAlignment ;_ccad bool ;_aeea float64 ;_dcad int ;_fcdd bool ;_afeg float64 ;_ceadb Margins ;_dcbf Positioning ;_dgcf float64 ;_abga float64 ;
_cfedb ,_dfecc float64 ;_bfbc []string ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_gbea *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_geac :=[2]*InvoiceCell {_gbea .newCell (description ,_gbea ._aca ),_gbea .newCell (value ,_gbea ._aca )};_gbea ._baeg =append (_gbea ._baeg ,_geac );return _geac [0],_geac [1];
};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_fbbd *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gdccc :=_ggb .Circle {X :_fbbd ._gdge -_fbbd ._afbgf /2,Y :ctx .PageHeight -_fbbd ._befbf -_fbbd ._cdbg /2,Width :_fbbd ._afbgf ,Height :_fbbd ._cdbg ,Opacity :1.0,BorderWidth :_fbbd ._baeb };
if _fbbd ._aedaf ==PositionRelative {_gdccc .X =ctx .X ;_gdccc .Y =ctx .PageHeight -ctx .Y -_fbbd ._cdbg ;};if _fbbd ._gdac !=nil {_gdccc .FillEnabled =true ;_gdccc .FillColor =_ffad (_fbbd ._gdac );};if _fbbd ._eefdg !=nil {_gdccc .BorderEnabled =false ;
if _fbbd ._baeb > 0{_gdccc .BorderEnabled =true ;};_gdccc .BorderColor =_ffad (_fbbd ._eefdg );_gdccc .BorderWidth =_fbbd ._baeb ;};_bbgf ,_ ,_ecgff :=_gdccc .Draw ("");if _ecgff !=nil {return nil ,ctx ,_ecgff ;};_ecgff =_bdff .addContentsByString (string (_bbgf ));
if _ecgff !=nil {return nil ,ctx ,_ecgff ;};return []*Block {_bdff },ctx ,nil ;};

// SetRowHeight sets the height for a specified row.
func (_fdgd *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_fdgd ._fcga ){return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdgd ._fcga [row -1]=h ;return nil ;
};func (_ecde *templateProcessor )parseBoolAttr (_deffe ,_gedfag string )bool {_cf .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_deffe ,_gedfag );
_baff ,_ :=_gg .ParseBool (_gedfag );return _gedfag ==""||_baff ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_gdd *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gdd ._cfg .Left ,_gdd ._cfg .Right ,_gdd ._cfg .Top ,_gdd ._cfg .Bottom ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_bfdb *Line )Width ()float64 {return _d .Abs (_bfdb ._faec -_bfdb ._bdbec )};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_fgfge *Rectangle )GetCoords ()(float64 ,float64 ){return _fgfge ._eedg ,_fgfge ._gfea };

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _becf (_fdff string )*_ddb .PdfAnnotation {_fgfbfc :=_ddb .NewPdfAnnotationLink ();_ddbab :=_ddb .NewBorderStyle ();_ddbab .SetBorderWidth (0);_fgfbfc .BS =_ddbab .ToPdfObject ();_dcaec :=_ddb .NewPdfActionURI ();_dcaec .URI =_a .MakeString (_fdff );
_fgfbfc .SetAction (_dcaec .PdfAction );return _fgfbfc .PdfAnnotation ;};func (_ecbcd *templateProcessor )parseTable (_cadf *templateNode )(interface{},error ){var _bgdb int64 ;for _ ,_cfga :=range _cadf ._cgfe .Attr {_faeg :=_cfga .Value ;switch _aeaee :=_cfga .Name .Local ;
_aeaee {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_bgdb =_ecbcd .parseInt64Attr (_aeaee ,_faeg );};};if _bgdb <=0{_cf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_bgdb );
_bgdb =1;};_cbdg :=_ecbcd .creator .NewTable (int (_bgdb ));for _ ,_fbea :=range _cadf ._cgfe .Attr {_ddde :=_fbea .Value ;switch _edaa :=_fbea .Name .Local ;_edaa {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_cbdg .SetColumnWidths (_ecbcd .parseFloatArray (_edaa ,_ddde )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_bgeg :=_ecbcd .parseMarginAttr (_edaa ,_ddde );_cbdg .SetMargins (_bgeg .Left ,_bgeg .Right ,_bgeg .Top ,_bgeg .Bottom );case "\u0078":_cbdg .SetPos (_ecbcd .parseFloatAttr (_edaa ,_ddde ),_cbdg ._adgf );case "\u0079":_cbdg .SetPos (_cbdg ._daaaa ,_ecbcd .parseFloatAttr (_edaa ,_ddde ));
case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_cbdg ._bcge =int (_ecbcd .parseInt64Attr (_edaa ,_ddde ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_cbdg ._bgga =int (_ecbcd .parseInt64Attr (_edaa ,_ddde ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_cbdg .EnableRowWrap (_ecbcd .parseBoolAttr (_edaa ,_ddde ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_cbdg .EnablePageWrap (_ecbcd .parseBoolAttr (_edaa ,_ddde ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_cf .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_edaa );
};};if _cbdg ._bcge !=0&&_cbdg ._bgga !=0{_edfb :=_cbdg .SetHeaderRows (_cbdg ._bcge ,_cbdg ._bgga );if _edfb !=nil {_cf .Log .Debug ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_edfb );
};}else {_cbdg ._bcge =0;_cbdg ._bgga =0;};return _cbdg ,nil ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_fbcb *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _e .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _e .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _e .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_fbcb ._eebfe =true ;_fbcb ._bcge =startRow ;_fbcb ._bgga =endRow ;return nil ;};

// Write output of creator to io.Writer interface.
func (_cdaa *Creator )Write (ws _dd .Writer )error {if _gdef :=_cdaa .Finalize ();_gdef !=nil {return _gdef ;};_debd :=_ddb .NewPdfWriter ();_debd .SetOptimizer (_cdaa ._gbfd );if _cdaa ._cdg !=nil {_adce :=_debd .SetForms (_cdaa ._cdg );if _adce !=nil {_cf .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_adce );
return _adce ;};};if _cdaa ._bedc !=nil {_debd .AddOutlineTree (_cdaa ._bedc );}else if _cdaa ._dagd !=nil &&_cdaa .AddOutlines {_debd .AddOutlineTree (&_cdaa ._dagd .ToPdfOutline ().PdfOutlineTreeNode );};if _cdaa ._ecef !=nil {if _gfab :=_debd .SetPageLabels (_cdaa ._ecef );
_gfab !=nil {_cf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_gfab );return _gfab ;};};if _cdaa ._ebec !=nil {for _ ,_aec :=range _cdaa ._ebec {_febee :=_aec .SubsetRegistered ();
if _febee !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_febee );return _febee ;};};};if _cdaa ._ebbd !=nil {_gadb :=_cdaa ._ebbd (&_debd );
if _gadb !=nil {_cf .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gadb );return _gadb ;};};for _ ,_dea :=range _cdaa ._gacf {_caeb :=_debd .AddPage (_dea );if _caeb !=nil {_cf .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_caeb );
return _caeb ;};};_fdgeb :=_debd .Write (ws );if _fdgeb !=nil {return _fdgeb ;};return nil ;};func (_daff *Invoice )generateLineBlocks (_ecad DrawContext )([]*Block ,DrawContext ,error ){_ebfg :=_abeacc (len (_daff ._eeec ));_ebfg .SetMargins (0,0,25,0);
for _ ,_cbcc :=range _daff ._eeec {_bgab :=_fgee (_cbcc .TextStyle );_bgab .SetMargins (0,0,1,0);_bgab .Append (_cbcc .Value );_daaf :=_ebfg .NewCell ();_daaf .SetHorizontalAlignment (_cbcc .Alignment );_daaf .SetBackgroundColor (_cbcc .BackgroundColor );
_daff .setCellBorder (_daaf ,_cbcc );_daaf .SetContent (_bgab );};for _ ,_afca :=range _daff ._baad {for _ ,_bffea :=range _afca {_fdefe :=_fgee (_bffea .TextStyle );_fdefe .SetMargins (0,0,3,2);_fdefe .Append (_bffea .Value );_caee :=_ebfg .NewCell ();
_caee .SetHorizontalAlignment (_bffea .Alignment );_caee .SetBackgroundColor (_bffea .BackgroundColor );_daff .setCellBorder (_caee ,_bffea );_caee .SetContent (_fdefe );};};return _ebfg .GeneratePageBlocks (_ecad );};

// DrawWithContext draws the Block using the specified drawing context.
func (_dae *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_dg ,_ ,_dbc :=d .GeneratePageBlocks (ctx );if _dbc !=nil {return _dbc ;};if len (_dg )!=1{return _e .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_dfc :=range _dg {if _egf :=_dae .mergeBlocks (_dfc );_egf !=nil {return _egf ;};};return nil ;};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_gbad *Table )EnablePageWrap (enable bool ){_gbad ._degff =enable };

// NewDivision returns a new Division container component.
func (_feda *Creator )NewDivision ()*Division {return _dbg ()};func (_bdcf *Table )resetColumnWidths (){_bdcf ._fefbb =[]float64 {};_gaab :=float64 (1.0)/float64 (_bdcf ._fdeb );for _afcce :=0;_afcce < _bdcf ._fdeb ;_afcce ++{_bdcf ._fefbb =append (_bdcf ._fefbb ,_gaab );
};};func (_gcde *TextChunk )clone ()*TextChunk {_addad :=*_gcde ;_addad ._acdb =_gbba (_gcde ._acdb );return &_addad ;};func _fcdddf (_bfgf ,_bafe ,_egga TextChunk ,_gdgcc uint ,_bffga TextStyle )*TOCLine {_dgcfe :=_fgee (_bffga );_dgcfe .SetEnableWrap (true );
_dgcfe .SetTextAlignment (TextAlignmentLeft );_dgcfe .SetMargins (0,0,2,2);_ccae :=&TOCLine {_aabbg :_dgcfe ,Number :_bfgf ,Title :_bafe ,Page :_egga ,Separator :TextChunk {Text :"\u002e",Style :_bffga },_fcgb :0,_aaaa :_gdgcc ,_eaede :10,_caga :PositionRelative };
_dgcfe ._ebgb .Left =_ccae ._fcgb +float64 (_ccae ._aaaa -1)*_ccae ._eaede ;_dgcfe ._abgbd =_ccae .prepareParagraph ;return _ccae ;};func (_bebc cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_fdgf :=_bebc ._aedd ;return 1-(_bebc ._cdb *(1-_fdgf )+_fdgf ),1-(_bebc ._daeg *(1-_fdgf )+_fdgf ),1-(_bebc ._fdefb *(1-_fdgf )+_fdgf );
};func (_bagf *templateProcessor )parseChart (_bgcff *templateNode )(interface{},error ){var _dedge string ;for _ ,_faagg :=range _bgcff ._cgfe .Attr {_cdee :=_faagg .Value ;switch _aggc :=_faagg .Name .Local ;_aggc {case "\u0073\u0072\u0063":_dedge =_cdee ;
};};if _dedge ==""{_cf .Log .Error ("\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_accac ;};_dccgd ,_bbebf :=_bagf ._adfg .ChartMap [_dedge ];if !_bbebf {_cf .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_dedge );
return nil ,_accac ;};_fgag :=NewChart (_dccgd );for _ ,_cfcc :=range _bgcff ._cgfe .Attr {_ecdcb :=_cfcc .Value ;switch _ffde :=_cfcc .Name .Local ;_ffde {case "\u0078":_fgag .SetPos (_bagf .parseFloatAttr (_ffde ,_ecdcb ),_fgag ._bdgba );case "\u0079":_fgag .SetPos (_fgag ._eafe ,_bagf .parseFloatAttr (_ffde ,_ecdcb ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ebaf :=_bagf .parseMarginAttr (_ffde ,_ecdcb );_fgag .SetMargins (_ebaf .Left ,_ebaf .Right ,_ebaf .Top ,_ebaf .Bottom );case "\u0077\u0069\u0064t\u0068":_fgag ._eeaf .SetWidth (int (_bagf .parseFloatAttr (_ffde ,_ecdcb )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_fgag ._eeaf .SetHeight (int (_bagf .parseFloatAttr (_ffde ,_ecdcb )));case "\u0073\u0072\u0063":break ;default:_cf .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_ffde );
};};return _fgag ,nil ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_facd *Creator )NewChapter (title string )*Chapter {_facd ._dcf ++;_aegf :=_facd .NewTextStyle ();_aegf .FontSize =16;return _eed (nil ,_facd ._bcdf ,_facd ._dagd ,title ,_facd ._dcf ,_aegf );};

// AddSection adds a new content section at the end of the invoice.
func (_ded *Invoice )AddSection (title ,content string ){_ded ._fdbc =append (_ded ._fdbc ,[2]string {title ,content });};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func _degg (_afee TextStyle )*List {return &List {_cfdc :TextChunk {Text :"\u2022\u0020",Style :_afee },_daedd :0,_dgbb :true ,_bfda :PositionRelative ,_fgbe :_afee };
};

// NewPolyline creates a new polyline.
func (_aage *Creator )NewPolyline (points []_ggb .Point )*Polyline {return _ffeb (points )};func _cdea (_aedae VectorDrawable ,_becc float64 )float64 {switch _eafb :=_aedae .(type ){case *Paragraph :if _eafb ._ccad {_eafb .SetWidth (_becc -_eafb ._ceadb .Left -_eafb ._ceadb .Right );
};return _eafb .Height ()+_eafb ._ceadb .Top +_eafb ._ceadb .Bottom ;case *StyledParagraph :if _eafb ._bfba {_eafb .SetWidth (_becc -_eafb ._ebgb .Left -_eafb ._ebgb .Right );};return _eafb .Height ()+_eafb ._ebgb .Top +_eafb ._ebgb .Bottom ;case *Image :_eafb .applyFitMode (_becc );
return _eafb .Height ()+_eafb ._abbf .Top +_eafb ._abbf .Bottom ;case marginDrawable :_ ,_ ,_bddc ,_ddf :=_eafb .GetMargins ();return _eafb .Height ()+_bddc +_ddf ;default:return _eafb .Height ();};};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;
TextAlignmentCenter ;TextAlignmentJustify ;);

// DashPattern returns the dash pattern of the line.
func (_cfda *Line )DashPattern ()(_agde []int64 ,_fbe int64 ){return _cfda ._cefb ,_cfda ._cbaf };

// Text sets the text content of the Paragraph.
func (_bfad *Paragraph )Text ()string {return _bfad ._aadgg };func _gfec (_dfdb *Block ,_ccc *Image ,_eeff DrawContext )(DrawContext ,error ){_bcdc :=_eeff ;_dabg :=1;_abcff :=_a .PdfObjectName (_cb .Sprintf ("\u0049\u006d\u0067%\u0064",_dabg ));for _dfdb ._ad .HasXObjectByName (_abcff ){_dabg ++;
_abcff =_a .PdfObjectName (_cb .Sprintf ("\u0049\u006d\u0067%\u0064",_dabg ));};_eeeb :=_dfdb ._ad .SetXObjectImageByName (_abcff ,_ccc ._gebaa );if _eeeb !=nil {return _eeff ,_eeeb ;};_aaed :=0;_ddefd :=_a .PdfObjectName (_cb .Sprintf ("\u0047\u0053\u0025\u0064",_aaed ));
for _dfdb ._ad .HasExtGState (_ddefd ){_aaed ++;_ddefd =_a .PdfObjectName (_cb .Sprintf ("\u0047\u0053\u0025\u0064",_aaed ));};_bgecc :=_a .MakeDict ();_bgecc .Set ("\u0042\u004d",_a .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _ccc ._geedcc < 1.0{_bgecc .Set ("\u0043\u0041",_a .MakeFloat (_ccc ._geedcc ));
_bgecc .Set ("\u0063\u0061",_a .MakeFloat (_ccc ._geedcc ));};_eeeb =_dfdb ._ad .AddExtGState (_ddefd ,_a .MakeIndirectObject (_bgecc ));if _eeeb !=nil {return _eeff ,_eeeb ;};_cefdd :=_ccc .Width ();_baf :=_ccc .Height ();_ ,_bdbe :=_ccc .rotatedSize ();
_ceca :=_eeff .X ;_fcabg :=_eeff .PageHeight -_eeff .Y -_baf ;if _ccc ._bfee .IsRelative (){_fcabg -=(_bdbe -_baf )/2;switch _ccc ._egg {case HorizontalAlignmentCenter :_ceca +=(_eeff .Width -_cefdd )/2;case HorizontalAlignmentRight :_ceca =_eeff .PageWidth -_eeff .Margins .Right -_ccc ._abbf .Right -_cefdd ;
};};_dbff :=_ccc ._ddggf ;_fafc :=_cc .NewContentCreator ();_fafc .Add_gs (_ddefd );_fafc .Translate (_ceca ,_fcabg );if _dbff !=0{_fafc .Translate (_cefdd /2,_baf /2);_fafc .RotateDeg (_dbff );_fafc .Translate (-_cefdd /2,-_baf /2);};_fafc .Scale (_cefdd ,_baf ).Add_Do (_abcff );
_facf :=_fafc .Operations ();_facf .WrapIfNeeded ();_dfdb .addContents (_facf );if _ccc ._bfee .IsRelative (){_eeff .Y +=_bdbe ;_eeff .Height -=_bdbe ;return _eeff ,nil ;};return _bcdc ,nil ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_dcdf *Invoice )SetColumns (cols []*InvoiceCell ){_dcdf ._eeec =cols };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_ggdf *Creator )NewImageFromGoImage (goimg _fa .Image )(*Image ,error ){return _bfed (goimg )};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_eecc *Paragraph )SetTextAlignment (align TextAlignment ){_eecc ._cccg =align };func (_becg *Division )ctxHeight (_agee float64 )float64 {_agee -=_becg ._acdf .Left +_becg ._acdf .Right +_becg ._acbg .Left +_becg ._acbg .Right ;var _edacf float64 ;
for _ ,_fcge :=range _becg ._bfcd {_edacf +=_cdea (_fcge ,_agee );};return _edacf ;};

// SetWidthLeft sets border width for left.
func (_bgbf *border )SetWidthLeft (bw float64 ){_bgbf ._ebf =bw };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_adff *Invoice )TotalLines ()[][2]*InvoiceCell {_agcd :=[][2]*InvoiceCell {_adff ._gcdg };_agcd =append (_agcd ,_adff ._fada ...);return append (_agcd ,_adff ._fddd );};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// Positioning returns the type of positioning the line is set to use.
func (_dade *Line )Positioning ()Positioning {return _dade ._bfce };func (_daegef *templateProcessor )parseInt64Attr (_geacd ,_fece string )int64 {_cf .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_geacd ,_fece );
_deee ,_ :=_gg .ParseInt (_fece ,10,64);return _deee ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ddb .PdfPage )(*Block ,error ){_ca :=&Block {};_ece ,_bbf :=page .GetAllContentStreams ();if _bbf !=nil {return nil ,_bbf ;};_afg :=_cc .NewContentStreamParser (_ece );_gcg ,_bbf :=_afg .Parse ();if _bbf !=nil {return nil ,_bbf ;
};_gcg .WrapIfNeeded ();_ca ._bb =_gcg ;if page .Resources !=nil {_ca ._ad =page .Resources ;}else {_ca ._ad =_ddb .NewPdfPageResources ();};_dc ,_bbf :=page .GetMediaBox ();if _bbf !=nil {return nil ,_bbf ;};if _dc .Llx !=0||_dc .Lly !=0{_ca .translate (-_dc .Llx ,_dc .Lly );
};_ca ._af =_dc .Urx -_dc .Llx ;_ca ._eag =_dc .Ury -_dc .Lly ;if page .Rotate !=nil {_ca ._bf =-float64 (*page .Rotate );};return _ca ,nil ;};

// SetLineWidth sets the line width.
func (_ebdc *Polyline )SetLineWidth (lineWidth float64 ){_ebdc ._ecfd .LineWidth =lineWidth };func (_dfdbd *templateProcessor )parseFitModeAttr (_aecb ,_cgfad string )FitMode {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_aecb ,_cgfad );
_gccc :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_cgfad ];return _gccc ;};func _abede (_ccegg *templateProcessor ,_bggbd *templateNode )(interface{},error ){return _ccegg .parseDivision (_bggbd );
};

// String implements error interface.
func (_bfbde UnsupportedRuneError )Error ()string {return _bfbde .Message };func (_fbbc *templateProcessor )parseChapter (_cbbac *templateNode )(interface{},error ){_egfe :=_fbbc .creator .NewChapter ;if _cbbac ._cfeb !=nil {if _cecfb ,_fcba :=_cbbac ._cfeb ._beabg .(*Chapter );
_fcba {_egfe =_cecfb .NewSubchapter ;};};_cafd :=_egfe ("");for _ ,_fadeg :=range _cbbac ._cgfe .Attr {_ccgf :=_fadeg .Value ;switch _ffgc :=_fadeg .Name .Local ;_ffgc {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_cafd .SetShowNumbering (_fbbc .parseBoolAttr (_ffgc ,_ccgf ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_cafd .SetIncludeInTOC (_fbbc .parseBoolAttr (_ffgc ,_ccgf ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_fgeag :=_fbbc .parseMarginAttr (_ffgc ,_ccgf );_cafd .SetMargins (_fgeag .Left ,_fgeag .Right ,_fgeag .Top ,_fgeag .Bottom );
default:_cf .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_ffgc );
};};return _cafd ,nil ;};

// IsRelative checks if the positioning is relative.
func (_gdgc Positioning )IsRelative ()bool {return _gdgc ==PositionRelative };

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_dedg *Line )SetColor (color Color ){_dedg ._ddbb =color };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_acc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_acc ._eeb .Left =left ;_acc ._eeb .Right =right ;_acc ._eeb .Top =top ;_acc ._eeb .Bottom =bottom ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetColorBottom sets border color for bottom.
func (_fef *border )SetColorBottom (col Color ){_fef ._gac =col };

// MoveX moves the drawing context to absolute position x.
func (_ccab *Creator )MoveX (x float64 ){_ccab ._fda .X =x };func (_cabd *templateProcessor )parseColorAttr (_aecab ,_ddadd string )Color {_cf .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_aecab ,_ddadd );
_dfcab :=ColorBlack ;if _ddadd ==""{return _dfcab ;};_adbg ,_dagf :=_cabd ._adfg .ColorMap [_ddadd ];if _dagf {return _adbg ;};if _ddadd [0]=='#'{return ColorRGBFromHex (_ddadd );};return _dfcab ;};

// SetBorderColor sets the border color.
func (_bbeaf *Polygon )SetBorderColor (color Color ){_bbeaf ._gcga .BorderColor =_ffad (color )};

// SetFillColor sets the fill color.
func (_daege *Ellipse )SetFillColor (col Color ){_daege ._gdac =col };

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_daae *Invoice )SetNoteStyle (style TextStyle ){_daae ._egfb =style };func _gded (_cadfa *templateProcessor ,_gabee *templateNode )(interface{},error ){return _cadfa .parseImage (_gabee );};func (_abfd *FilledCurve )draw (_dgd string )([]byte ,*_ddb .PdfRectangle ,error ){_afgc :=_ggb .NewCubicBezierPath ();
for _ ,_acg :=range _abfd ._dbdd {_afgc =_afgc .AppendCurve (_acg );};creator :=_cc .NewContentCreator ();creator .Add_q ();if _abfd .FillEnabled &&_abfd ._fefb !=nil {creator .SetNonStrokingColor (_ffad (_abfd ._fefb ));};if _abfd .BorderEnabled {if _abfd ._aged !=nil {creator .SetStrokingColor (_ffad (_abfd ._aged ));
};creator .Add_w (_abfd .BorderWidth );};if len (_dgd )> 1{creator .Add_gs (_a .PdfObjectName (_dgd ));};_ggb .DrawBezierPathWithCreator (_afgc ,creator );creator .Add_h ();if _abfd .FillEnabled &&_abfd .BorderEnabled {creator .Add_B ();}else if _abfd .FillEnabled {creator .Add_f ();
}else if _abfd .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_eagd :=_afgc .GetBoundingBox ();if _abfd .BorderEnabled {_eagd .Height +=_abfd .BorderWidth ;_eagd .Width +=_abfd .BorderWidth ;_eagd .X -=_abfd .BorderWidth /2;_eagd .Y -=_abfd .BorderWidth /2;
};_eeeec :=&_ddb .PdfRectangle {};_eeeec .Llx =_eagd .X ;_eeeec .Lly =_eagd .Y ;_eeeec .Urx =_eagd .X +_eagd .Width ;_eeeec .Ury =_eagd .Y +_eagd .Height ;return creator .Bytes (),_eeeec ,nil ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_adg *Block )DrawTemplate (c *Creator ,r _dd .Reader ,data interface{},options *TemplateOptions )error {return _cagc (c ,r ,data ,options ,_adg );};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_gbda *Block )SetMargins (left ,right ,top ,bottom float64 ){_gbda ._bgd .Left =left ;_gbda ._bgd .Right =right ;_gbda ._bgd .Top =top ;_gbda ._bgd .Bottom =bottom ;};

// SetBorderColor sets the border color.
func (_adbc *CurvePolygon )SetBorderColor (color Color ){_adbc ._efdg .BorderColor =_ffad (color )};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_ecga *TOC )SetLinePageStyle (style TextStyle ){_ecga ._fdccf =style };

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_bgad *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _bgad ._gebaa ==nil {if _daed :=_bgad .makeXObject ();_daed !=nil {return nil ,ctx ,_daed ;};};var _bdbf []*Block ;_fedc :=ctx ;_egdea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _bgad ._bfee .IsRelative (){_bgad .applyFitMode (ctx .Width );ctx .X +=_bgad ._abbf .Left ;ctx .Y +=_bgad ._abbf .Top ;ctx .Width -=_bgad ._abbf .Left +_bgad ._abbf .Right ;ctx .Height -=_bgad ._abbf .Top +_bgad ._abbf .Bottom ;if _bgad ._fdca > ctx .Height {_bdbf =append (_bdbf ,_egdea );
_egdea =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bgfea :=ctx ;_bgfea .Y =ctx .Margins .Top +_bgad ._abbf .Top ;_bgfea .X =ctx .Margins .Left +_bgad ._abbf .Left ;_bgfea .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bgad ._abbf .Top -_bgad ._abbf .Bottom ;
_bgfea .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bgad ._abbf .Left -_bgad ._abbf .Right ;ctx =_bgfea ;};}else {ctx .X =_bgad ._afcd ;ctx .Y =_bgad ._begb ;};ctx ,_cefd :=_gfec (_egdea ,_bgad ,ctx );if _cefd !=nil {return nil ,ctx ,_cefd ;
};_bdbf =append (_bdbf ,_egdea );if _bgad ._bfee .IsAbsolute (){ctx =_fedc ;}else {ctx .X =_fedc .X ;ctx .Width =_fedc .Width ;ctx .Y +=_bgad ._abbf .Bottom ;};return _bdbf ,ctx ,nil ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_dbafb *TableCell )SetContent (vd VectorDrawable )error {switch _cdbc :=vd .(type ){case *Paragraph :if _cdbc ._fcdd {_cdbc ._ccad =true ;};_dbafb ._ffbee =vd ;case *StyledParagraph :if _cdbc ._bfcg {_cdbc ._bfba =true ;};_dbafb ._ffbee =vd ;case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_dbafb ._ffbee =vd ;
default:_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _a .ErrTypeError ;};return nil ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_fggd *Creator )SetOutlineTree (outlineTree *_ddb .PdfOutlineTreeNode ){_fggd ._bedc =outlineTree };var PPI float64 =72;

// LevelOffset returns the amount of space an indentation level occupies.
func (_cebbc *TOCLine )LevelOffset ()float64 {return _cebbc ._eaede };

// NewList creates a new list.
func (_ebge *Creator )NewList ()*List {return _degg (_ebge .NewTextStyle ())};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_efdd *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _efdd ._ceadb .Left ,_efdd ._ceadb .Right ,_efdd ._ceadb .Top ,_efdd ._ceadb .Bottom ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_bcdb *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bde *_ddb .PdfWriter )error ){_bcdb ._ebbd =pdfWriterAccessFunc ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_ddggb *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_ddggb ._egg =alignment };func (_ebdgc *templateProcessor )loadImageFromSrc (_dddc string )(*Image ,error ){if _dddc ==""{_cf .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_accac ;};_bbgfe :=_gga .Split (_dddc ,"\u002c");for _ ,_cgac :=range _bbgfe {_cgac =_gga .TrimSpace (_cgac );if _cgac ==""{continue ;};_decc ,_agbfa :=_ebdgc ._adfg .ImageMap [_cgac ];if _agbfa {return _gebg (_decc );};if _fecae :=_ebdgc .parseAttrPropList (_cgac );
len (_fecae )> 0{if _geca ,_gcef :=_fecae ["\u0070\u0061\u0074\u0068"];_gcef {if _ggcac ,_eddea :=_adbd (_geca );_eddea !=nil {_cf .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_geca ,_eddea );
}else {return _ggcac ,nil ;};};};};_cf .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_dddc );return nil ,_accac ;};

// Width returns the width of the Paragraph.
func (_abgc *StyledParagraph )Width ()float64 {if _abgc ._bfba &&int (_abgc ._ceec )> 0{return _abgc ._ceec ;};return _abgc .getTextWidth ()/1000.0;};func _ggcgd ()*PageBreak {return &PageBreak {}};

// SetStyleLeft sets border style for left side.
func (_gaf *border )SetStyleLeft (style CellBorderStyle ){_gaf ._bdfg =style };

// SetMargins sets the margins TOC line.
func (_gddgg *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_gddgg ._fcgb =left ;_bagg :=&_gddgg ._aabbg ._ebgb ;_bagg .Left =_gddgg ._fcgb +float64 (_gddgg ._aaaa -1)*_gddgg ._eaede ;_bagg .Right =right ;_bagg .Top =top ;_bagg .Bottom =bottom ;
};func _cbce (_adbcb *templateProcessor ,_bggda *templateNode )(interface{},error ){return _adbcb .parseBackground (_bggda );};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_aceec int ;_fdeb int ;_bdaaf int ;_fefbb []float64 ;_fcga []float64 ;_baegf float64 ;_edeebg []*TableCell ;_gbdd []int ;_afbd Positioning ;_daaaa ,_adgf float64 ;_edcc Margins ;_eebfe bool ;_bcge int ;_bgga int ;_fgge bool ;_degff bool ;
};

// Indent returns the left offset of the list when nested into another list.
func (_fecd *List )Indent ()float64 {return _fecd ._daedd };

// SetBorder sets the cell's border style.
func (_cdfdd *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_cdfdd ._fcbf =CellBorderStyleSingle ;_cdfdd ._aecd =width ;_cdfdd ._gbaf =CellBorderStyleSingle ;
_cdfdd ._ecaegf =width ;_cdfdd ._dfdba =CellBorderStyleSingle ;_cdfdd ._deff =width ;_cdfdd ._dcbb =CellBorderStyleSingle ;_cdfdd ._caca =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_cdfdd ._fcbf =CellBorderStyleDouble ;_cdfdd ._aecd =width ;
_cdfdd ._gbaf =CellBorderStyleDouble ;_cdfdd ._ecaegf =width ;_cdfdd ._dfdba =CellBorderStyleDouble ;_cdfdd ._deff =width ;_cdfdd ._dcbb =CellBorderStyleDouble ;_cdfdd ._caca =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_cdfdd ._fcbf =style ;
_cdfdd ._aecd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_cdfdd ._gbaf =style ;_cdfdd ._ecaegf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_cdfdd ._dfdba =style ;
_cdfdd ._deff =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_cdfdd ._dcbb =style ;_cdfdd ._caca =width ;};};

// SetFillColor sets the fill color.
func (_dgdc *PolyBezierCurve )SetFillColor (color Color ){_dgdc ._bddf .FillColor =_ffad (color )};func _cefg (_ffbcad *templateProcessor ,_acdcb *templateNode )(interface{},error ){return _ffbcad .parseTable (_acdcb );};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// Helper functions map.
HelperFuncMap _g .FuncMap ;

// Named resource maps.
FontMap map[string ]*_ddb .PdfFont ;ImageMap map[string ]*_ddb .Image ;ColorMap map[string ]Color ;ChartMap map[string ]_ec .ChartRenderable ;};func _deca (_dagg _ec .ChartRenderable )*Chart {return &Chart {_eeaf :_dagg ,_egdc :PositionRelative ,_cfg :Margins {Top :10,Bottom :10}};
};

// SetBorderRadius sets the radius of the background corners.
func (_gc *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_gc .BorderRadiusTopLeft =topLeft ;_gc .BorderRadiusTopRight =topRight ;_gc .BorderRadiusBottomLeft =bottomLeft ;_gc .BorderRadiusBottomRight =bottomRight ;};func (_bdbd *Table )wrapContent (_ddbc DrawContext )error {if _bdbd ._fgge {return nil ;
};_ffdaa :=func (_cabaf *TableCell ,_ddabe int ,_ecc int ,_adfcf int )(_eegab int ){if _adfcf < 1{return -1;};_ageeg :=0;for _gdab :=_ecc +1;_gdab < len (_bdbd ._edeebg )-1;_gdab ++{_agef :=_bdbd ._edeebg [_gdab ];if _agef ._gdfb ==_adfcf {_ageeg =_gdab ;
if (_agef ._fbcc < _cabaf ._fbcc &&_bdbd ._fdeb > _agef ._fbcc )||_cabaf ._fbcc < _bdbd ._fdeb {continue ;};break ;};};_abefb :=float64 (0.0);for _aegaf :=0;_aegaf < _cabaf ._fgfbg ;_aegaf ++{_abefb +=_bdbd ._fcga [_cabaf ._gdfb +_aegaf -1];};_gcdc :=float64 (0.0);
for _gcdde :=0;_gcdde < _cabaf ._dagag ;_gcdde ++{_gcdc +=_bdbd ._fefbb [_cabaf ._fbcc +_gcdde -1];};var (_gfade VectorDrawable ;_gfbaa =false ;);switch _dfcage :=_cabaf ._ffbee .(type ){case *StyledParagraph :_fabag :=_ddbc ;_fabag .Height =_d .Floor (_abefb -_dfcage ._ebgb .Top -_dfcage ._ebgb .Bottom -0.5*_dfcage .getTextHeight ());
_fabag .Width =_gcdc ;_adbcf ,_baebb ,_bdgg :=_dfcage .split (_fabag );if _bdgg !=nil {_cf .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_bdgg .Error ());
};if _adbcf !=nil &&_baebb !=nil {_bdbd ._edeebg [_ecc ]._ffbee =_adbcf ;_gfade =_baebb ;_gfbaa =true ;};};_bdbd ._edeebg [_ecc ]._fgfbg =_cabaf ._fgfbg ;_ddbc .Height =_ddbc .PageHeight -_ddbc .Margins .Top -_ddbc .Margins .Bottom ;_bfbef :=_cabaf .cloneProps (nil );
if _gfbaa {_bfbef ._ffbee =_gfade ;};_bfbef ._fgfbg =_ddabe -1;_bfbef ._gdfb =_adfcf +1;_bfbef ._fbcc =_cabaf ._fbcc ;_bdbd ._edeebg =append (_bdbd ._edeebg [:_ageeg +1],append ([]*TableCell {_bfbef },_bdbd ._edeebg [_ageeg +1:]...)...);return _ageeg +1;
};_addb :=float64 (0.0);_fcee :=0;_afbe :=-1;for _fcce ,_cgfd :=range _bdbd ._edeebg {if _afbe ==_fcce {_fcee =_cgfd ._gdfb ;_addb =0.0;};if _cgfd ._fgfbg < 2{if _fcee < _cgfd ._gdfb &&_fcce > _afbe &&_addb < _ddbc .Height {_addb +=_bdbd ._fcga [_cgfd ._gdfb -1];
};_fcee =_cgfd ._gdfb ;continue ;};if _addb < 1&&_fcce ==_afbe {_addb +=_bdbd ._fcga [_cgfd ._gdfb -1];};_fgbdga :=float64 (0.0);_fgeg :=-1;_cbcac :=-1;_cebfa :=0;for _cbded :=0;_cbded < _cgfd ._fgfbg ;_cbded ++{if (_fgbdga +_bdbd ._fcga [_cgfd ._gdfb +_cbded -1])> (_ddbc .Height -_addb ){break ;
};_fgbdga +=_bdbd ._fcga [_cgfd ._gdfb +_cbded -1];_cbcac =_cgfd ._gdfb +_cbded ;_fgeg =_cgfd ._fgfbg -_cbded ;_cebfa ++;};if _fgeg > 0&&_cgfd ._fgfbg > _cebfa {_cgfd ._fgfbg =_cebfa ;_afbe =_ffdaa (_cgfd ,_fgeg ,_fcce ,_cbcac );_fcee =_cbcac ;};};return nil ;
};func (_gfeea *templateProcessor )parseFontAttr (_fggdd ,_cebad string )*_ddb .PdfFont {_cf .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_fggdd ,_cebad );
_bdgdf :=_gfeea .creator ._abcf ;if _cebad ==""{return _bdgdf ;};_fdgdg :=_gga .Split (_cebad ,"\u002c");for _ ,_fefd :=range _fdgdg {_fefd =_gga .TrimSpace (_fefd );if _fefd ==""{continue ;};_dace ,_acdaa :=_gfeea ._adfg .FontMap [_cebad ];if _acdaa {return _dace ;
};_geggd ,_acdaa :=map[string ]_ddb .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_ddb .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_ddb .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_ddb .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_ddb .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_ddb .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_ddb .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_ddb .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_ddb .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_ddb .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_ddb .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_ddb .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_ddb .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_ddb .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_ddb .TimesBoldItalicName }[_cebad ];
if _acdaa {if _gdfcb ,_bbdg :=_ddb .NewStandard14Font (_geggd );_bbdg ==nil {return _gdfcb ;};};if _ccgbb :=_gfeea .parseAttrPropList (_fefd );len (_ccgbb )> 0{if _cafe ,_bdbb :=_ccgbb ["\u0070\u0061\u0074\u0068"];_bdbb {_fgdgb :=_ddb .NewPdfFontFromTTFFile ;
if _gdgf ,_fcaa :=_ccgbb ["\u0074\u0079\u0070\u0065"];_fcaa &&_gdgf =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_fgdgb =_ddb .NewCompositePdfFontFromTTFFile ;};if _efac ,_bdbbb :=_fgdgb (_cafe );_bdbbb !=nil {_cf .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_cafe ,_bdbbb );
}else {return _efac ;};};};};return _bdgdf ;};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_abee *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_abee ._bcdf =toc ;};

// Padding returns the padding of the component.
func (_debe *Division )Padding ()(_agfb ,_ggdb ,_bdeb ,_dcac float64 ){return _debe ._acbg .Left ,_debe ._acbg .Right ,_debe ._acbg .Top ,_debe ._acbg .Bottom ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_cffc *TOC )SetLineTitleStyle (style TextStyle ){_cffc ._dddg =style };func (_acdc *templateProcessor )parseAttrPropList (_ebdg string )map[string ]string {_cbge :=_gga .Fields (_ebdg );if len (_cbge )==0{return nil ;};_feege :=map[string ]string {};
for _ ,_afde :=range _cbge {_gfcf :=_dega .FindStringSubmatch (_afde );if len (_gfcf )< 3{continue ;};_fccag ,_gdacb :=_gga .TrimSpace (_gfcf [1]),_gfcf [2];if _fccag ==""{continue ;};_feege [_fccag ]=_gdacb ;};return _feege ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_eafa *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _beeb (xc ,yc ,width ,height );};func _fabgd (_bfc ,_gdbeb ,_gffg ,_eacae ,_cbgg ,_cefcb float64 )*Curve {_egde :=&Curve {};_egde ._cdfg =_bfc ;_egde ._abcfd =_gdbeb ;_egde ._gdcf =_gffg ;
_egde ._dffa =_eacae ;_egde ._gebf =_cbgg ;_egde ._afgge =_cefcb ;_egde ._bda =ColorBlack ;_egde ._adecf =1.0;return _egde ;};

// Opacity returns the opacity of the line.
func (_bfabf *Line )Opacity ()float64 {return _bfabf ._acbgef };

// AppendColumn appends a column to the line items table.
func (_gffe *Invoice )AppendColumn (description string )*InvoiceCell {_afbgb :=_gffe .NewColumn (description );_gffe ._eeec =append (_gffe ._eeec ,_afbgb );return _afbgb ;};

// SetFont sets the Paragraph's font.
func (_fgdg *Paragraph )SetFont (font *_ddb .PdfFont ){_fgdg ._bbea =font };

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_fdfcg *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgdg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ggdef :=_ggb .Rectangle {Opacity :1.0,X :_fdfcg ._eedg ,Y :ctx .PageHeight -_fdfcg ._gfea -_fdfcg ._adfff ,Height :_fdfcg ._adfff ,Width :_fdfcg ._bfde ,BorderRadiusTopLeft :_fdfcg ._abcgb ,BorderRadiusTopRight :_fdfcg ._aaedc ,BorderRadiusBottomLeft :_fdfcg ._abcdf ,BorderRadiusBottomRight :_fdfcg ._febab };
if _fdfcg ._abgg ==PositionRelative {_ggdef .X =ctx .X ;_ggdef .Y =ctx .PageHeight -ctx .Y -_fdfcg ._adfff ;};if _fdfcg ._aeddb !=nil {_ggdef .FillEnabled =true ;_ggdef .FillColor =_ffad (_fdfcg ._aeddb );};if _fdfcg ._ebdcg !=nil &&_fdfcg ._debge > 0{_ggdef .BorderEnabled =true ;
_ggdef .BorderColor =_ffad (_fdfcg ._ebdcg );_ggdef .BorderWidth =_fdfcg ._debge ;};_efegf ,_fcdc :=_bgdg .setOpacity (_fdfcg ._ccbd ,_fdfcg ._dcdd );if _fcdc !=nil {return nil ,ctx ,_fcdc ;};_acba ,_ ,_fcdc :=_ggdef .Draw (_efegf );if _fcdc !=nil {return nil ,ctx ,_fcdc ;
};if _fcdc =_bgdg .addContentsByString (string (_acba ));_fcdc !=nil {return nil ,ctx ,_fcdc ;};return []*Block {_bgdg },ctx ,nil ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fad *Block )SetPos (x ,y float64 ){_fad ._bg =PositionAbsolute ;_fad ._eda =x ;_fad ._cbb =y };

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_abff *Invoice )SetAddressHeadingStyle (style TextStyle ){_abff ._bdec =style };func (_cddcc *templateProcessor )parseTableCell (_dgda *templateNode )(interface{},error ){if _dgda ._cfeb ==nil {_cf .Log .Error ("\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_cbbfe ;};_faabf ,_bcgc :=_dgda ._cfeb ._beabg .(*Table );if !_bcgc {_cf .Log .Error ("\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_dgda ._cfeb ._beabg );
return nil ,_cbbfe ;};var _ceba ,_gefc int64 ;for _ ,_efbdb :=range _dgda ._cgfe .Attr {_efaa :=_efbdb .Value ;switch _adege :=_efbdb .Name .Local ;_adege {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_ceba =_cddcc .parseInt64Attr (_adege ,_efaa );case "\u0072o\u0077\u0073\u0070\u0061\u006e":_gefc =_cddcc .parseInt64Attr (_adege ,_efaa );
};};if _ceba <=0{_ceba =1;};if _gefc <=0{_gefc =1;};_fbadb :=_faabf .MultiCell (int (_gefc ),int (_ceba ));for _ ,_aabb :=range _dgda ._cgfe .Attr {_fggad :=_aabb .Value ;switch _dgage :=_aabb .Name .Local ;_dgage {case "\u0069\u006e\u0064\u0065\u006e\u0074":_fbadb .SetIndent (_cddcc .parseFloatAttr (_dgage ,_fggad ));
case "\u0061\u006c\u0069g\u006e":_fbadb .SetHorizontalAlignment (_cddcc .parseCellAlignmentAttr (_dgage ,_fggad ));case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_fbadb .SetVerticalAlignment (_cddcc .parseCellVerticalAlignmentAttr (_dgage ,_fggad ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_fbadb .SetSideBorderStyle (CellBorderSideAll ,_cddcc .parseCellBorderStyleAttr (_dgage ,_fggad ));case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_fbadb .SetSideBorderStyle (CellBorderSideTop ,_cddcc .parseCellBorderStyleAttr (_dgage ,_fggad ));
case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_fbadb .SetSideBorderStyle (CellBorderSideBottom ,_cddcc .parseCellBorderStyleAttr (_dgage ,_fggad ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_fbadb .SetSideBorderStyle (CellBorderSideLeft ,_cddcc .parseCellBorderStyleAttr (_dgage ,_fggad ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_fbadb .SetSideBorderStyle (CellBorderSideRight ,_cddcc .parseCellBorderStyleAttr (_dgage ,_fggad ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_fbadb .SetSideBorderWidth (CellBorderSideAll ,_cddcc .parseFloatAttr (_dgage ,_fggad ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_fbadb .SetSideBorderWidth (CellBorderSideTop ,_cddcc .parseFloatAttr (_dgage ,_fggad ));case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_fbadb .SetSideBorderWidth (CellBorderSideBottom ,_cddcc .parseFloatAttr (_dgage ,_fggad ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_fbadb .SetSideBorderWidth (CellBorderSideLeft ,_cddcc .parseFloatAttr (_dgage ,_fggad ));case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_fbadb .SetSideBorderWidth (CellBorderSideRight ,_cddcc .parseFloatAttr (_dgage ,_fggad ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fbadb .SetSideBorderColor (CellBorderSideAll ,_cddcc .parseColorAttr (_dgage ,_fggad ));case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_fbadb .SetSideBorderColor (CellBorderSideTop ,_cddcc .parseColorAttr (_dgage ,_fggad ));
case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_fbadb .SetSideBorderColor (CellBorderSideBottom ,_cddcc .parseColorAttr (_dgage ,_fggad ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_fbadb .SetSideBorderColor (CellBorderSideLeft ,_cddcc .parseColorAttr (_dgage ,_fggad ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_fbadb .SetSideBorderColor (CellBorderSideRight ,_cddcc .parseColorAttr (_dgage ,_fggad ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_fbadb .SetBorderLineStyle (_cddcc .parseLineStyleAttr (_dgage ,_fggad ));
case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_fbadb .SetBackgroundColor (_cddcc .parseColorAttr (_dgage ,_fggad ));case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;
default:_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_dgage );
};};return _fbadb ,nil ;};func (_bee *Block )transform (_fee _faf .Matrix ){_abc :=_cc .NewContentCreator ().Add_cm (_fee [0],_fee [1],_fee [3],_fee [4],_fee [6],_fee [7]).Operations ();*_bee ._bb =append (*_abc ,*_bee ._bb ...);_bee ._bb .WrapIfNeeded ();
};

// SkipCells skips over a specified number of cells in the table.
func (_fgfdg *Table )SkipCells (num int ){if num < 0{_cf .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_fgfdg ._bdaaf +=num ;};

// SetFillOpacity sets the fill opacity.
func (_egfc *CurvePolygon )SetFillOpacity (opacity float64 ){_egfc ._afgd =opacity };func (_baega *templateProcessor )renderNode (_aeddec *templateNode )error {_abdf :=_aeddec ._beabg ;if _abdf ==nil {return nil ;};_ccfff :=_aeddec ._cgfe .Name .Local ;
_cfgd ,_agdfc :=_efbd [_ccfff ];if !_agdfc {_cf .Log .Debug ("\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025s\u0060.\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_ccfff );return nil ;};var _dfcff interface{};
if _aeddec ._cfeb !=nil &&_aeddec ._cfeb ._beabg !=nil {_gcbg :=_aeddec ._cfeb ._cgfe .Name .Local ;if _ ,_agdfc =_cfgd ._bbebb [_gcbg ];!_agdfc {_cf .Log .Debug ("\u0060%\u0073\u0060 \u0069\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020`\u0025\u0073\u0060\u0020\u006e\u006f\u0064\u0065\u002e",_gcbg ,_ccfff );
return _cbbfe ;};_dfcff =_aeddec ._cfeb ._beabg ;}else {_acbbb :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _baega ._acad .(type ){case *Block :_acbbb ="\u0062\u006c\u006fc\u006b";};if _ ,_agdfc =_cfgd ._bbebb [_acbbb ];!_agdfc {_cf .Log .Debug ("\u0060%\u0073\u0060 \u0069\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020`\u0025\u0073\u0060\u0020\u006e\u006f\u0064\u0065\u002e",_acbbb ,_ccfff );
return _cbbfe ;};_dfcff =_baega ._acad ;};switch _bfbab :=_dfcff .(type ){case componentRenderer :_gaca ,_gffd :=_abdf .(Drawable );if !_gffd {_cf .Log .Error ("\u0043\u006f\u006d\u0070\u006f\u006ee\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_abdf );
return _aaedd ;};return _bfbab .Draw (_gaca );case *Division :switch _dfed :=_abdf .(type ){case *Background :_bfbab .SetBackground (_dfed );case VectorDrawable :return _bfbab .Add (_dfed );};case *TableCell :_gfbc ,_bcag :=_abdf .(VectorDrawable );if !_bcag {_cf .Log .Error ("C\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006eo\u0074\u0020\u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072 d\u0072\u0061\u0077a\u0062l\u0065\u002e",_abdf );
return _aaedd ;};return _bfbab .SetContent (_gfbc );case *StyledParagraph :_aaad ,_cgbc :=_abdf .(*TextChunk );if !_cgbc {_cf .Log .Error ("C\u006f\u006d\u0070\u006f\u006e\u0065n\u0074\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006ek\u002e",_abdf );
return _aaedd ;};_bfbab .appendChunk (_aaad );case *Chapter :switch _fdbbb :=_abdf .(type ){case *Chapter :return nil ;case *Paragraph :if _aeddec ._cgfe .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};return _bfbab .Add (_fdbbb );case Drawable :return _bfbab .Add (_fdbbb );};};return nil ;};

// SetText sets the text content of the Paragraph.
func (_cbfg *Paragraph )SetText (text string ){_cbfg ._aadgg =text };

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_ebdec *List )Width ()float64 {return 0};func (_geba *Chapter )headingText ()string {_aeec :=_geba ._bege ;if _bcaf :=_geba .headingNumber ();_bcaf !=""{_aeec =_cb .Sprintf ("\u0025\u0073\u0020%\u0073",_bcaf ,_aeec );};return _aeec ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_cfgg *Image )ScaleToHeight (h float64 ){_ffbg :=_cfgg ._ddac /_cfgg ._fdca ;_cfgg ._fdca =h ;_cfgg ._ddac =h *_ffbg ;};func (_bbeca *TableCell )height (_cgde float64 )float64 {var _geaga float64 ;switch _cebb :=_bbeca ._ffbee .(type ){case *Paragraph :if _cebb ._ccad {_cebb .SetWidth (_cgde -_bbeca ._geag -_cebb ._ceadb .Left -_cebb ._ceadb .Right );
};_geaga =_cebb .Height ()+_cebb ._ceadb .Top +_cebb ._ceadb .Bottom +0.5*_cebb ._fabb *_cebb ._gggdb ;case *StyledParagraph :if _cebb ._bfba {_cebb .SetWidth (_cgde -_bbeca ._geag -_cebb ._ebgb .Left -_cebb ._ebgb .Right );};_geaga =_cebb .Height ()+_cebb ._ebgb .Top +_cebb ._ebgb .Bottom +0.5*_cebb .getTextHeight ();
case *Image :_cebb .applyFitMode (_cgde -_bbeca ._geag );_geaga =_cebb .Height ()+_cebb ._abbf .Top +_cebb ._abbf .Bottom ;case *Table :_cebb .updateRowHeights (_cgde -_bbeca ._geag -_cebb ._edcc .Left -_cebb ._edcc .Right );_geaga =_cebb .Height ()+_cebb ._edcc .Top +_cebb ._edcc .Bottom ;
case *List :_geaga =_cebb .tableHeight (_cgde -_bbeca ._geag )+_cebb ._fgfbf .Top +_cebb ._fgfbf .Bottom ;case *Division :_geaga =_cebb .ctxHeight (_cgde -_bbeca ._geag )+_cebb ._acdf .Top +_cebb ._acdf .Bottom ;case *Chart :_geaga =_cebb .Height ()+_cebb ._cfg .Top +_cebb ._cfg .Bottom ;
case *Rectangle :_geaga =_cebb .Height ();case *Ellipse :_geaga =_cebb .Height ();case *Line :_geaga =_cebb .Height ()+_cebb ._dfbfe .Top +_cebb ._dfbfe .Bottom ;};return _geaga ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_gfff *StyledParagraph )Height ()float64 {_gfff .wrapText ();var _dfgg float64 ;for _ ,_feffeg :=range _gfff ._fcddb {var _gcadf float64 ;for _ ,_gece :=range _feffeg {_cedf :=_gfff ._ccfgg *_gece .Style .FontSize ;if _cedf > _gcadf {_gcadf =_cedf ;
};};_dfgg +=_gcadf ;};return _dfgg ;};

// SetPositioning sets Ellipse's position attribute.
func (_cbed *Ellipse )SetPositioning (position Positioning ){_cbed ._aedaf =position };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_ebdf *Image )ScaleToWidth (w float64 ){_aacd :=_ebdf ._fdca /_ebdf ._ddac ;_ebdf ._ddac =w ;_ebdf ._fdca =w *_aacd ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// TextAlignment options for paragraph.
type TextAlignment int ;

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_cgg *Chart )Width ()float64 {return float64 (_cgg ._eeaf .Width ())};func _cagc (_dfcad *Creator ,_eebe _dd .Reader ,_cbff interface{},_geedccd *TemplateOptions ,_ddda componentRenderer )error {if _dfcad ==nil {_cf .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _dagdb ;};_egge :=_ea .NewBuffer (nil );if _ ,_fcddc :=_dd .Copy (_egge ,_eebe );_fcddc !=nil {return _fcddc ;};_cgfgd :=_g .FuncMap {"\u0064\u0069\u0063\u0074":_aefbg };if _geedccd !=nil &&_geedccd .HelperFuncMap !=nil {for _dcbege ,_eddee :=range _geedccd .HelperFuncMap {if _ ,_fcbed :=_cgfgd [_dcbege ];
_fcbed {_cf .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_dcbege );
continue ;};_cgfgd [_dcbege ]=_eddee ;};};_gdaef ,_bcdfd :=_g .New ("").Funcs (_cgfgd ).Parse (_egge .String ());if _bcdfd !=nil {return _bcdfd ;};_egge .Reset ();if _fcae :=_gdaef .Execute (_egge ,_cbff );_fcae !=nil {return _fcae ;};return _eaba (_dfcad ,_egge .Bytes (),_geedccd ,_ddda ).run ();
};

// Lines returns all the lines the table of contents has.
func (_feed *TOC )Lines ()[]*TOCLine {return _feed ._dacda };func (_adbff *TemplateOptions )init (){if _adbff .FontMap ==nil {_adbff .FontMap =map[string ]*_ddb .PdfFont {};};if _adbff .ImageMap ==nil {_adbff .ImageMap =map[string ]*_ddb .Image {};};if _adbff .ColorMap ==nil {_adbff .ColorMap =map[string ]Color {};
};if _adbff .ChartMap ==nil {_adbff .ChartMap =map[string ]_ec .ChartRenderable {};};};func (_adcd *templateProcessor )parseTextVerticalAlignmentAttr (_dagdc ,_bcbea string )TextVerticalAlignment {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dagdc ,_bcbea );
_abgdbc :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_bcbea ];return _abgdbc ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _ec .ChartRenderable )*Chart {return _deca (chart )};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func _abge (_aecbd *_ddb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_aecbd ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetColorLeft sets border color for left.
func (_cba *border )SetColorLeft (col Color ){_cba ._adb =col };func (_cfag *Invoice )setCellBorder (_cgedb *TableCell ,_gddd *InvoiceCell ){for _ ,_gafgc :=range _gddd .BorderSides {_cgedb .SetBorder (_gafgc ,CellBorderStyleSingle ,_gddd .BorderWidth );
};_cgedb .SetBorderColor (_gddd .BorderColor );};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_acdb *_ddb .PdfAnnotation ;_abcfg bool ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_ggded *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _fgdeg (number ,title ,page ,level ,_ggded .NewTextStyle ());};

// Rows returns the total number of rows the table has.
func (_dccg *Table )Rows ()int {return _dccg ._aceec };type border struct{_fcda float64 ;_gcc float64 ;_ebba float64 ;_cbdd float64 ;_dda Color ;_adb Color ;_ebf float64 ;_gac Color ;_ede float64 ;_bfd Color ;_eec float64 ;_gdb Color ;_fcc float64 ;LineStyle _ggb .LineStyle ;
_bdfg CellBorderStyle ;_fdc CellBorderStyle ;_beag CellBorderStyle ;_dfd CellBorderStyle ;};

// Heading returns the heading component of the table of contents.
func (_cfabgb *TOC )Heading ()*StyledParagraph {return _cfabgb ._dacd };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dfcc *TOC )SetHeading (text string ,style TextStyle ){_facg :=_dfcc .Heading ();_facg .Reset ();_cbeae :=_facg .Append (text );_cbeae .Style =style ;};

// SetLogo sets the logo of the invoice.
func (_bfbg *Invoice )SetLogo (logo *Image ){_bfbg ._gagb =logo };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_egbc *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _fabgd (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func _fdg (_gbdge ,_cfe ,_fcab ,_gae float64 )*border {_gggg :=&border {};_gggg ._fcda =_gbdge ;_gggg ._gcc =_cfe ;_gggg ._ebba =_fcab ;_gggg ._cbdd =_gae ;
_gggg ._gdb =ColorBlack ;_gggg ._gac =ColorBlack ;_gggg ._adb =ColorBlack ;_gggg ._bfd =ColorBlack ;_gggg ._fcc =0;_gggg ._ede =0;_gggg ._ebf =0;_gggg ._eec =0;_gggg .LineStyle =_ggb .LineStyleSolid ;return _gggg ;};func (_cbg *Block )mergeBlocks (_bca *Block )error {_adc :=_abcg (_cbg ._bb ,_cbg ._ad ,_bca ._bb ,_bca ._ad );
if _adc !=nil {return _adc ;};for _ ,_dbe :=range _bca ._fb {_cbg .AddAnnotation (_dbe );};return nil ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_gbfc *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_bdaeg :=&_gbfc ._eadae ;_bdaeg .Left =left ;_bdaeg .Right =right ;_bdaeg .Top =top ;_bdaeg .Bottom =bottom ;};

// Height returns the Block's height.
func (_efd *Block )Height ()float64 {return _efd ._eag };

// SetLineOpacity sets the line opacity.
func (_ccea *Polyline )SetLineOpacity (opacity float64 ){_ccea ._dcdff =opacity };

// TOC returns the table of contents component of the creator.
func (_dgge *Creator )TOC ()*TOC {return _dgge ._bcdf };func _dgafe (_gdgcf *_c .File )([]*_ddb .PdfPage ,error ){_cafdb ,_efedc :=_ddb .NewPdfReader (_gdgcf );if _efedc !=nil {return nil ,_efedc ;};_gfcb ,_efedc :=_cafdb .GetNumPages ();if _efedc !=nil {return nil ,_efedc ;
};var _ceae []*_ddb .PdfPage ;for _fadgd :=0;_fadgd < _gfcb ;_fadgd ++{_fcfbe ,_gfeaf :=_cafdb .GetPage (_fadgd +1);if _gfeaf !=nil {return nil ,_gfeaf ;};_ceae =append (_ceae ,_fcfbe );};return _ceae ,nil ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_cfabg *Line )SetMargins (left ,right ,top ,bottom float64 ){_cfabg ._dfbfe .Left =left ;_cfabg ._dfbfe .Right =right ;_cfabg ._dfbfe .Top =top ;_cfabg ._dfbfe .Bottom =bottom ;};

// Add adds a new line with the default style to the table of contents.
func (_baag *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_eebdg :=_baag .AddLine (_fcdddf (TextChunk {Text :number ,Style :_baag ._aebeg },TextChunk {Text :title ,Style :_baag ._dddg },TextChunk {Text :page ,Style :_baag ._fdccf },level ,_baag ._efdcb ));
if _eebdg ==nil {return nil ;};_affdd :=&_baag ._eadae ;_eebdg .SetMargins (_affdd .Left ,_affdd .Right ,_affdd .Top ,_affdd .Bottom );_eebdg .SetLevelOffset (_baag ._dcace );_eebdg .Separator .Text =_baag ._fcfcg ;_eebdg .Separator .Style =_baag ._dgbba ;
return _eebdg ;};func _aefbg (_ebcg ...interface{})(map[string ]interface{},error ){_decac :=len (_ebcg );if _decac %2!=0{_cf .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_decac );
return nil ,_a .ErrRangeError ;};_begc :=map[string ]interface{}{};for _efcfa :=0;_efcfa < _decac ;_efcfa +=2{_bfcb ,_gacfe :=_ebcg [_efcfa ].(string );if !_gacfe {_cf .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_ebcg [_efcfa ]);
return nil ,_a .ErrTypeError ;};_begc [_bfcb ]=_ebcg [_efcfa +1];};return _begc ,nil ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_ggggf *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcfff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abeac ,_faecf :=_gcfff .setOpacity (_ggggf ._fggfc ,_ggggf ._babf );if _faecf !=nil {return nil ,ctx ,_faecf ;
};_bdge :=_ggggf ._bddf ;_bdge .FillEnabled =_bdge .FillColor !=nil ;var (_aacgc =ctx .PageHeight ;_efgde =_bdge .Curves ;_fdcda =make ([]_ggb .CubicBezierCurve ,0,len (_bdge .Curves )););for _bgfec :=range _bdge .Curves {_cace :=_efgde [_bgfec ];_cace .P0 .Y =_aacgc -_cace .P0 .Y ;
_cace .P1 .Y =_aacgc -_cace .P1 .Y ;_cace .P2 .Y =_aacgc -_cace .P2 .Y ;_cace .P3 .Y =_aacgc -_cace .P3 .Y ;_fdcda =append (_fdcda ,_cace );};_bdge .Curves =_fdcda ;defer func (){_bdge .Curves =_efgde }();_cbba ,_ ,_faecf :=_bdge .Draw (_abeac );if _faecf !=nil {return nil ,ctx ,_faecf ;
};if _faecf =_gcfff .addContentsByString (string (_cbba ));_faecf !=nil {return nil ,ctx ,_faecf ;};return []*Block {_gcfff },ctx ,nil ;};

// AddLine appends a new line to the invoice line items table.
func (_gbbg *Invoice )AddLine (values ...string )[]*InvoiceCell {_cefae :=len (_gbbg ._eeec );var _dcbe []*InvoiceCell ;for _gfad ,_gge :=range values {_bbge :=_gbbg .newCell (_gge ,_gbbg ._cbc );if _gfad < _cefae {_bbge .Alignment =_gbbg ._eeec [_gfad ].Alignment ;
};_dcbe =append (_dcbe ,_bbge );};_gbbg ._baad =append (_gbbg ._baad ,_dcbe );return _dcbe ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dfbb *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bbedc float64 ;var _efgg []*StyledParagraph ;for _ ,_ccde :=range _dfbb ._eefg {_dfca :=_fgee (_dfbb ._fgbe );_dfca .SetEnableWrap (false );_dfca .SetTextAlignment (TextAlignmentRight );
_dfca .Append (_ccde ._dbed .Text ).Style =_ccde ._dbed .Style ;_cbadg :=_dfca .getTextWidth ()/1000.0/ctx .Width ;if _bbedc < _cbadg {_bbedc =_cbadg ;};_efgg =append (_efgg ,_dfca );};_gacg :=_abeacc (2);_gacg .SetColumnWidths (_bbedc ,1-_bbedc );_gacg .SetMargins (_dfbb ._daedd ,0,0,0);
for _ebeeg ,_dbeb :=range _dfbb ._eefg {_affd :=_gacg .NewCell ();_affd .SetIndent (0);_affd .SetContent (_efgg [_ebeeg ]);_affd =_gacg .NewCell ();_affd .SetIndent (0);_affd .SetContent (_dbeb ._debeb );};return _gacg .GeneratePageBlocks (ctx );};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_eef *Division )EnablePageWrap (enable bool ){_eef ._aeae =enable };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetAnnotation sets a annotation on a TextChunk.
func (_dddf *TextChunk )SetAnnotation (annotation *_ddb .PdfAnnotation ){_dddf ._acdb =annotation };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// Color returns the color of the line.
func (_acee *Line )Color ()Color {return _acee ._ddbb };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_gbagb *TOC )SetLineLevelOffset (levelOffset float64 ){_gbagb ._dcace =levelOffset };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_fegbf *Image )ConvertToBinary ()error {return _fegbf ._aeaed .ConvertToBinary ()};

// SetEnableWrap sets the line wrapping enabled flag.
func (_ffcc *StyledParagraph )SetEnableWrap (enableWrap bool ){_ffcc ._bfba =enableWrap ;_ffcc ._bfcg =false ;};

// Width returns the width of the Paragraph.
func (_cadd *Paragraph )Width ()float64 {if _cadd ._ccad &&int (_cadd ._aeea )> 0{return _cadd ._aeea ;};return _cadd .getTextWidth ()/1000.0;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_fegef *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_efec ,_fgbeeb :=_fegef .Wrap (width );if _fgbeeb !=nil {return nil ,_fgbeeb ;};_ccedf :=int (height /_fegef .Style .FontSize );if _ccedf >=len (_efec ){return nil ,nil ;};_eceeg :="\u000a";
_fegef .Text =_gga .Replace (_gga .Join (_efec [:_ccedf ],"\u0020"),_eceeg +"\u0020",_eceeg ,-1);_bagad :=_gga .Replace (_gga .Join (_efec [_ccedf :],"\u0020"),_eceeg +"\u0020",_eceeg ,-1);return NewTextChunk (_bagad ,_fegef .Style ),nil ;};

// Width returns the Block's width.
func (_eca *Block )Width ()float64 {return _eca ._af };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_gedf *Creator )Finalize ()error {if _gedf ._ged {return nil ;};_dfda :=len (_gedf ._gacf );_fffg :=0;if _gedf ._gfd !=nil {_fdbd :=*_gedf ;_gedf ._gacf =nil ;_gedf ._ecfb =nil ;_gedf .initContext ();_beab :=FrontpageFunctionArgs {PageNum :1,TotalPages :_dfda };
_gedf ._gfd (_beab );_fffg +=len (_gedf ._gacf );_gedf ._gacf =_fdbd ._gacf ;_gedf ._ecfb =_fdbd ._ecfb ;};if _gedf .AddTOC {_gedf .initContext ();_gedf ._fda .Page =_fffg +1;if _gedf ._cgca !=nil {if _facb :=_gedf ._cgca (_gedf ._bcdf );_facb !=nil {return _facb ;
};};_bfa ,_ ,_edg :=_gedf ._bcdf .GeneratePageBlocks (_gedf ._fda );if _edg !=nil {_cf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_edg );
return _edg ;};_fffg +=len (_bfa );_bdcg :=_gedf ._bcdf .Lines ();for _ ,_ffg :=range _bdcg {_gedfa ,_aacb :=_gg .Atoi (_ffg .Page .Text );if _aacb !=nil {continue ;};_ffg .Page .Text =_gg .Itoa (_gedfa +_fffg );};};_fgfg :=false ;var _bbef []*_ddb .PdfPage ;
if _gedf ._gfd !=nil {_aeb :=*_gedf ;_gedf ._gacf =nil ;_gedf ._ecfb =nil ;_bead :=FrontpageFunctionArgs {PageNum :1,TotalPages :_dfda };_gedf ._gfd (_bead );_dfda +=len (_gedf ._gacf );_bbef =_gedf ._gacf ;_gedf ._gacf =append (_gedf ._gacf ,_aeb ._gacf ...);
_gedf ._ecfb =_aeb ._ecfb ;_fgfg =true ;};var _febe []*_ddb .PdfPage ;if _gedf .AddTOC {_gedf .initContext ();if _gedf ._cgca !=nil {if _fbdg :=_gedf ._cgca (_gedf ._bcdf );_fbdg !=nil {_cf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_fbdg );
return _fbdg ;};};_aea :=_gedf ._bcdf .Lines ();for _ ,_bebd :=range _aea {_bebd ._efgbg +=int64 (_fffg );};_cgff ,_ ,_ :=_gedf ._bcdf .GeneratePageBlocks (_gedf ._fda );for _ ,_egdba :=range _cgff {_egdba .SetPos (0,0);_dfda ++;_ffeg :=_gedf .newPage ();
_febe =append (_febe ,_ffeg );_gedf .setActivePage (_ffeg );_gedf .Draw (_egdba );};if _fgfg {_bgfc :=_bbef ;_egda :=_gedf ._gacf [len (_bbef ):];_gedf ._gacf =append ([]*_ddb .PdfPage {},_bgfc ...);_gedf ._gacf =append (_gedf ._gacf ,_febe ...);_gedf ._gacf =append (_gedf ._gacf ,_egda ...);
}else {_gedf ._gacf =append (_febe ,_gedf ._gacf ...);};};if _gedf ._dagd !=nil &&_gedf .AddOutlines {var _dff func (_dded *_ddb .OutlineItem );_dff =func (_fdge *_ddb .OutlineItem ){_fdge .Dest .Page +=int64 (_fffg );if _afa :=int (_fdge .Dest .Page );
_afa >=0&&_afa < len (_gedf ._gacf ){_fdge .Dest .PageObj =_gedf ._gacf [_afa ].GetPageAsIndirectObject ();}else {_cf .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_afa );
};_fdge .Dest .Y =_gedf ._edb -_fdge .Dest .Y ;_fag :=_fdge .Items ();for _ ,_bcdfe :=range _fag {_dff (_bcdfe );};};_dadf :=_gedf ._dagd .Items ();for _ ,_acf :=range _dadf {_dff (_acf );};if _gedf .AddTOC {var _ebea int ;if _fgfg {_ebea =len (_bbef );
};_efda :=_ddb .NewOutlineDest (int64 (_ebea ),0,_gedf ._edb );if _ebea >=0&&_ebea < len (_gedf ._gacf ){_efda .PageObj =_gedf ._gacf [_ebea ].GetPageAsIndirectObject ();}else {_cf .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ebea );
};_gedf ._dagd .Insert (0,_ddb .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_efda ));};};for _gadc ,_bff :=range _gedf ._gacf {_gedf .setActivePage (_bff );if _gedf ._ada !=nil {_dfe ,_aefb ,_dgfb :=_bff .Size ();
if _dgfb !=nil {return _dgfb ;};_ffba :=PageFinalizeFunctionArgs {PageNum :_gadc +1,PageWidth :_dfe ,PageHeight :_aefb ,TOCPages :len (_febe ),TotalPages :_dfda };if _agg :=_gedf ._ada (_ffba );_agg !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_agg );
return _agg ;};};if _gedf ._cbdb !=nil {_decd :=NewBlock (_gedf ._bedd ,_gedf ._aefe .Top );_gfde :=HeaderFunctionArgs {PageNum :_gadc +1,TotalPages :_dfda };_gedf ._cbdb (_decd ,_gfde );_decd .SetPos (0,0);if _beabf :=_gedf .Draw (_decd );_beabf !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_beabf );
return _beabf ;};};if _gedf ._dcb !=nil {_gba :=NewBlock (_gedf ._bedd ,_gedf ._aefe .Bottom );_edec :=FooterFunctionArgs {PageNum :_gadc +1,TotalPages :_dfda };_gedf ._dcb (_gba ,_edec );_gba .SetPos (0,_gedf ._edb -_gba ._eag );if _dfgc :=_gedf .Draw (_gba );
_dfgc !=nil {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_dfgc );return _dfgc ;};};_bfddf ,_cceg :=_gedf ._effb [_bff ];if _gdcc ,_bece :=_gedf ._dfg [_bff ];
_bece {if _cceg {_bfddf .transformBlock (_gdcc );};if _bgdf :=_gdcc .drawToPage (_bff );_bgdf !=nil {_cf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_gadc +1,_bgdf );
return _bgdf ;};};if _cceg {if _fbfe :=_bfddf .transformPage (_bff );_fbfe !=nil {_cf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_fbfe );
return _fbfe ;};};};_gedf ._ged =true ;return nil ;};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_acfa *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_acfa ._abffg =align ;};

// SetIndent sets the cell's left indent.
func (_effec *TableCell )SetIndent (indent float64 ){_effec ._geag =indent };

// SetColor sets the line color.
func (_bbeff *Curve )SetColor (col Color ){_bbeff ._bda =col };

// Height returns the height of the chart.
func (_cde *Chart )Height ()float64 {return float64 (_cde ._eeaf .Height ())};

// SetStyle sets the style of the line (solid or dashed).
func (_ceb *Line )SetStyle (style _ggb .LineStyle ){_ceb ._edeg =style };

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;func (_gffc *templateProcessor )parseParagraph (_eadfg *templateNode ,_cdgc *Paragraph )(interface{},error ){if _cdgc ==nil {_cdgc =_gffc .creator .NewParagraph ("");};for _ ,_acda :=range _eadfg ._cgfe .Attr {_fdbbd :=_acda .Value ;
switch _bbfec :=_acda .Name .Local ;_bbfec {case "\u0066\u006f\u006e\u0074":_cdgc .SetFont (_gffc .parseFontAttr (_bbfec ,_fdbbd ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_cdgc .SetFontSize (_gffc .parseFloatAttr (_bbfec ,_fdbbd ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_cdgc .SetTextAlignment (_gffc .parseTextAlignmentAttr (_bbfec ,_fdbbd ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_cdgc .SetLineHeight (_gffc .parseFloatAttr (_bbfec ,_fdbbd ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_cdgc .SetEnableWrap (_gffc .parseBoolAttr (_bbfec ,_fdbbd ));
case "\u0063\u006f\u006co\u0072":_cdgc .SetColor (_gffc .parseColorAttr (_bbfec ,_fdbbd ));case "\u0078":_cdgc .SetPos (_gffc .parseFloatAttr (_bbfec ,_fdbbd ),_cdgc ._abga );case "\u0079":_cdgc .SetPos (_cdgc ._dgcf ,_gffc .parseFloatAttr (_bbfec ,_fdbbd ));
case "\u0061\u006e\u0067l\u0065":_cdgc .SetAngle (_gffc .parseFloatAttr (_bbfec ,_fdbbd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_eefa :=_gffc .parseMarginAttr (_bbfec ,_fdbbd );_cdgc .SetMargins (_eefa .Left ,_eefa .Right ,_eefa .Top ,_eefa .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_cdgc .SetMaxLines (int (_gffc .parseInt64Attr (_bbfec ,_fdbbd )));default:_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_bbfec );
};};return _cdgc ,nil ;};func _bfed (_beba _fa .Image )(*Image ,error ){_ggdedf ,_fcca :=_ddb .ImageHandling .NewImageFromGoImage (_beba );if _fcca !=nil {return nil ,_fcca ;};return _gebg (_ggdedf );};func _bfbda (_bgae float64 ,_afbed float64 )float64 {return _d .Round (_bgae /_afbed )*_afbed };
func _dgeg (_edfc string ,_fbggb ,_cedb TextStyle )*TOC {_fabab :=_cedb ;_fabab .FontSize =14;_facbe :=_fgee (_fabab );_facbe .SetEnableWrap (true );_facbe .SetTextAlignment (TextAlignmentLeft );_facbe .SetMargins (0,0,0,5);_bffd :=_facbe .Append (_edfc );
_bffd .Style =_fabab ;return &TOC {_dacd :_facbe ,_dacda :[]*TOCLine {},_aebeg :_fbggb ,_dddg :_fbggb ,_dgbba :_fbggb ,_fdccf :_fbggb ,_fcfcg :"\u002e",_dcace :10,_eadae :Margins {0,0,2,2},_bcgcg :PositionRelative ,_efdcb :_fbggb ,_gggcb :true };};

// SetStyleRight sets border style for right side.
func (_cbbd *border )SetStyleRight (style CellBorderStyle ){_cbbd ._fdc =style };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_accf rune ;_ggcf []error ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_ebfd *Table )SetMargins (left ,right ,top ,bottom float64 ){_ebfd ._edcc .Left =left ;_ebfd ._edcc .Right =right ;_ebfd ._edcc .Top =top ;_ebfd ._edcc .Bottom =bottom ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_acbb *Invoice )NoteHeadingStyle ()TextStyle {return _acbb ._fbaa };

// NewTable create a new Table with a specified number of columns.
func (_edcec *Creator )NewTable (cols int )*Table {return _abeacc (cols )};func _gagd (_dafc *templateProcessor ,_bagb *templateNode )(interface{},error ){return _dafc .parseTableCell (_bagb );};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_cdbgf *Table )Width ()float64 {return 0};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_abdcfb *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bddce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bbfe ,_efea :=_bddce .setOpacity (_abdcfb ._dcdff ,_abdcfb ._dcdff );if _efea !=nil {return nil ,ctx ,_efea ;
};_defg :=_abdcfb ._ecfd .Points ;for _cecag :=range _defg {_baga :=&_defg [_cecag ];_baga .Y =ctx .PageHeight -_baga .Y ;};_gdbc ,_ ,_efea :=_abdcfb ._ecfd .Draw (_bbfe );if _efea !=nil {return nil ,ctx ,_efea ;};if _efea =_bddce .addContentsByString (string (_gdbc ));
_efea !=nil {return nil ,ctx ,_efea ;};return []*Block {_bddce },ctx ,nil ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_aaef *StyledParagraph )SetTextAlignment (align TextAlignment ){_aaef ._eadg =align };

// NewColumn returns a new column for the line items invoice table.
func (_cbgd *Invoice )NewColumn (description string )*InvoiceCell {return _cbgd .newColumn (description ,CellHorizontalAlignmentLeft );};

// NewTOC creates a new table of contents.
func (_acde *Creator )NewTOC (title string )*TOC {_adde :=_acde .NewTextStyle ();_adde .Font =_acde ._bgee ;return _dgeg (title ,_acde .NewTextStyle (),_adde );};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_aab *Division )SetMargins (left ,right ,top ,bottom float64 ){_aab ._acdf .Left =left ;_aab ._acdf .Right =right ;_aab ._acdf .Top =top ;_aab ._acdf .Bottom =bottom ;};

// NewPolygon creates a new polygon.
func (_afec *Creator )NewPolygon (points [][]_ggb .Point )*Polygon {return _eafg (points )};func (_daab *Invoice )generateTotalBlocks (_acae DrawContext )([]*Block ,DrawContext ,error ){_bbaa :=_abeacc (4);_bbaa .SetMargins (0,0,10,10);_ace :=[][2]*InvoiceCell {_daab ._gcdg };
_ace =append (_ace ,_daab ._fada ...);_ace =append (_ace ,_daab ._fddd );for _ ,_gfdea :=range _ace {_eaag ,_cbggd :=_gfdea [0],_gfdea [1];if _cbggd .Value ==""{continue ;};_bbaa .SkipCells (2);_eebf :=_bbaa .NewCell ();_eebf .SetBackgroundColor (_eaag .BackgroundColor );
_eebf .SetHorizontalAlignment (_cbggd .Alignment );_daab .setCellBorder (_eebf ,_eaag );_cac :=_fgee (_eaag .TextStyle );_cac .SetMargins (0,0,2,1);_cac .Append (_eaag .Value );_eebf .SetContent (_cac );_eebf =_bbaa .NewCell ();_eebf .SetBackgroundColor (_cbggd .BackgroundColor );
_eebf .SetHorizontalAlignment (_cbggd .Alignment );_daab .setCellBorder (_eebf ,_eaag );_cac =_fgee (_cbggd .TextStyle );_cac .SetMargins (0,0,2,1);_cac .Append (_cbggd .Value );_eebf .SetContent (_cac );};return _bbaa .GeneratePageBlocks (_acae );};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_aabbg *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_fcgb float64 ;_aaaa uint ;_eaede float64 ;_caga Positioning ;_added float64 ;_ecdf float64 ;_efgbg int64 ;};func (_cggc *Invoice )drawAddress (_ccbb *InvoiceAddress )[]*StyledParagraph {var _bgecb []*StyledParagraph ;if _ccbb .Heading !=""{_fdgg :=_fgee (_cggc ._bdec );
_fdgg .SetMargins (0,0,0,7);_fdgg .Append (_ccbb .Heading );_bgecb =append (_bgecb ,_fdgg );};_dgab :=_fgee (_cggc ._dcaa );_dgab .SetLineHeight (1.2);_gaef :=_ccbb .Separator ;if _gaef ==""{_gaef =_cggc ._ebefe ;};_cfbc :=_ccbb .City ;if _ccbb .State !=""{if _cfbc !=""{_cfbc +=_gaef ;
};_cfbc +=_ccbb .State ;};if _ccbb .Zip !=""{if _cfbc !=""{_cfbc +=_gaef ;};_cfbc +=_ccbb .Zip ;};if _ccbb .Name !=""{_dgab .Append (_ccbb .Name +"\u000a");};if _ccbb .Street !=""{_dgab .Append (_ccbb .Street +"\u000a");};if _ccbb .Street2 !=""{_dgab .Append (_ccbb .Street2 +"\u000a");
};if _cfbc !=""{_dgab .Append (_cfbc +"\u000a");};if _ccbb .Country !=""{_dgab .Append (_ccbb .Country +"\u000a");};_gbbb :=_fgee (_cggc ._dcaa );_gbbb .SetLineHeight (1.2);_gbbb .SetMargins (0,0,7,0);if _ccbb .Phone !=""{_gbbb .Append (_ccbb .fmtLine (_ccbb .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_ccbb .HidePhoneLabel ));
};if _ccbb .Email !=""{_gbbb .Append (_ccbb .fmtLine (_ccbb .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_ccbb .HideEmailLabel ));};_bgecb =append (_bgecb ,_dgab ,_gbbb );return _bgecb ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_egff *Creator )NewParagraph (text string )*Paragraph {return _ffcf (text ,_egff .NewTextStyle ())};

// NewSubchapter creates a new child chapter with the specified title.
func (_fac *Chapter )NewSubchapter (title string )*Chapter {_dcd :=_abge (_fac ._edf ._bbea );_dcd .FontSize =14;_fac ._ffe ++;_cbf :=_eed (_fac ,_fac ._gccb ,_fac ._age ,title ,_fac ._ffe ,_dcd );_fac .Add (_cbf );return _cbf ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// Margins returns the margins of the component.
func (_gebfd *Division )Margins ()(_dfgag ,_ccda ,_afbg ,_acbc float64 ){return _gebfd ._acdf .Left ,_gebfd ._acdf .Right ,_gebfd ._acdf .Top ,_gebfd ._acdf .Bottom ;};var PPMM =float64 (72*1.0/25.4);func (_faabff *templateProcessor )parseCellVerticalAlignmentAttr (_baab ,_dccff string )CellVerticalAlignment {_cf .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_baab ,_dccff );
_fdafc :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_dccff ];return _fdafc ;
};func (_fdb *Block )addContents (_bef *_cc .ContentStreamOperations ){_fdb ._bb .WrapIfNeeded ();_bef .WrapIfNeeded ();*_fdb ._bb =append (*_fdb ._bb ,*_bef ...);};

// SetHeight sets the Image's document height to specified h.
func (_fbgd *Image )SetHeight (h float64 ){_fbgd ._fdca =h };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_efdg *_ggb .CurvePolygon ;_afgd float64 ;_cdaaa float64 ;};func (_bcdd *templateProcessor )parseTextChunk (_deac *templateNode )(interface{},error ){_fbgdg :=NewTextChunk ("",_bcdd .creator .NewTextStyle ());for _ ,_dgff :=range _deac ._cgfe .Attr {_cecae :=_dgff .Value ;
switch _dfafc :=_dgff .Name .Local ;_dfafc {case "\u0063\u006f\u006co\u0072":_fbgdg .Style .Color =_bcdd .parseColorAttr (_dfafc ,_cecae );case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_fbgdg .Style .OutlineColor =_bcdd .parseColorAttr (_dfafc ,_cecae );
case "\u0066\u006f\u006e\u0074":_fbgdg .Style .Font =_bcdd .parseFontAttr (_dfafc ,_cecae );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_fbgdg .Style .FontSize =_bcdd .parseFloatAttr (_dfafc ,_cecae );case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_fbgdg .Style .OutlineSize =_bcdd .parseFloatAttr (_dfafc ,_cecae );
case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_fbgdg .Style .CharSpacing =_bcdd .parseFloatAttr (_dfafc ,_cecae );case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_fbgdg .Style .HorizontalScaling =_bcdd .parseFloatAttr (_dfafc ,_cecae );
case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_fbgdg .Style .RenderingMode =_bcdd .parseTextRenderingModeAttr (_dfafc ,_cecae );case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_fbgdg .Style .Underline =_bcdd .parseBoolAttr (_dfafc ,_cecae );
case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_fbgdg .Style .UnderlineStyle .Color =_bcdd .parseColorAttr (_dfafc ,_cecae );case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_fbgdg .Style .UnderlineStyle .Offset =_bcdd .parseFloatAttr (_dfafc ,_cecae );
case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_fbgdg .Style .UnderlineStyle .Thickness =_bcdd .parseFloatAttr (_dfafc ,_cecae );case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_fbgdg .Style .TextRise =_bcdd .parseFloatAttr (_dfafc ,_cecae );
default:_cf .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_dfafc );
};};return _fbgdg ,nil ;};

// SetBorderOpacity sets the border opacity.
func (_fcgd *Polygon )SetBorderOpacity (opacity float64 ){_fcgd ._adbf =opacity };type cmykColor struct{_cdb ,_daeg ,_fdefb ,_aedd float64 };

// Level returns the indentation level of the TOC line.
func (_dagba *TOCLine )Level ()uint {return _dagba ._aaaa };

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_bfcd []VectorDrawable ;_effbb Positioning ;_acdf Margins ;_acbg Margins ;_bbee bool ;_aeae bool ;_egfcb *Background ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_gaaad *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_gaaad ._abcgb =topLeft ;_gaaad ._aaedc =topRight ;_gaaad ._abcdf =bottomLeft ;_gaaad ._febab =bottomRight ;};func (_gdae *Invoice )generateHeaderBlocks (_cfbb DrawContext )([]*Block ,DrawContext ,error ){_gcea :=_fgee (_gdae ._fea );
_gcea .SetEnableWrap (true );_gcea .Append (_gdae ._caa );_fdfc :=_abeacc (2);if _gdae ._gagb !=nil {_cbgb :=_fdfc .NewCell ();_cbgb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_cbgb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cbgb .SetIndent (0);
_cbgb .SetContent (_gdae ._gagb );_gdae ._gagb .ScaleToHeight (_gcea .Height ()+20);}else {_fdfc .SkipCells (1);};_ccgg :=_fdfc .NewCell ();_ccgg .SetHorizontalAlignment (CellHorizontalAlignmentRight );_ccgg .SetVerticalAlignment (CellVerticalAlignmentMiddle );
_ccgg .SetContent (_gcea );return _fdfc .GeneratePageBlocks (_cfbb );};func _eaba (_ggae *Creator ,_feffb []byte ,_ggbbe *TemplateOptions ,_cddc componentRenderer )*templateProcessor {if _ggbbe ==nil {_ggbbe =&TemplateOptions {};};_ggbbe .init ();if _cddc ==nil {_cddc =_ggae ;
};return &templateProcessor {creator :_ggae ,_bcbe :_feffb ,_adfg :_ggbbe ,_acad :_cddc };};func _fgee (_bfaa TextStyle )*StyledParagraph {return &StyledParagraph {_fgbgc :[]*TextChunk {},_aebg :_bfaa ,_bgafb :_bggad (_bfaa .Font ),_ccfgg :1.0,_eadg :TextAlignmentLeft ,_bfba :true ,_bfcg :true ,_gacgb :false ,_edba :0,_ceeb :1,_gabcb :1,_egbce :PositionRelative };
};

// Width returns the current page width.
func (_ffaf *Creator )Width ()float64 {return _ffaf ._bedd };func _bggad (_eadga *_ddb .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_eadga ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);func _fgdeg (_abcgc ,_fbfbb ,_defe string ,_bbfee uint ,_cebdg TextStyle )*TOCLine {return _fcdddf (TextChunk {Text :_abcgc ,Style :_cebdg },TextChunk {Text :_fbfbb ,Style :_cebdg },TextChunk {Text :_defe ,Style :_cebdg },_bbfee ,_cebdg );
};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_abb *Chapter )Add (d Drawable )error {if Drawable (_abb )==d {_cf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _geed :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_abb ._fade =append (_abb ._fade ,d );case containerDrawable :_bcg ,_fbab :=_geed .ContainerComponent (_abb );
if _fbab !=nil {return _fbab ;};_abb ._fade =append (_abb ._fade ,_bcg );default:_cf .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func (_aa *Block )setOpacity (_ge float64 ,_ef float64 )(string ,error ){if (_ge < 0||_ge >=1.0)&&(_ef < 0||_ef >=1.0){return "",nil ;};_ccg :=0;_gcgb :=_cb .Sprintf ("\u0047\u0053\u0025\u0064",_ccg );for _aa ._ad .HasExtGState (_a .PdfObjectName (_gcgb )){_ccg ++;
_gcgb =_cb .Sprintf ("\u0047\u0053\u0025\u0064",_ccg );};_ade :=_a .MakeDict ();if _ge >=0&&_ge < 1.0{_ade .Set ("\u0063\u0061",_a .MakeFloat (_ge ));};if _ef >=0&&_ef < 1.0{_ade .Set ("\u0043\u0041",_a .MakeFloat (_ef ));};_cca :=_aa ._ad .AddExtGState (_a .PdfObjectName (_gcgb ),_ade );
if _cca !=nil {return "",_cca ;};return _gcgb ,nil ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_fbd int ;_bege string ;_edf *Paragraph ;_fade []Drawable ;_ffe int ;_bab bool ;_fedf bool ;_fbc Positioning ;_cfa ,_ggaca float64 ;_eeb Margins ;_dgg *Chapter ;_gccb *TOC ;_age *_ddb .Outline ;_afbc *_ddb .OutlineItem ;_gagf uint ;
};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_gbb *Block )ScaleToHeight (h float64 ){_fec :=h /_gbb ._eag ;_gbb .Scale (_fec ,_fec )};

// SetSideBorderWidth sets the cell's side border width.
func (_fcfee *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_fcfee ._caca =width ;_fcfee ._ecaegf =width ;_fcfee ._aecd =width ;_fcfee ._deff =width ;case CellBorderSideTop :_fcfee ._caca =width ;
case CellBorderSideBottom :_fcfee ._ecaegf =width ;case CellBorderSideLeft :_fcfee ._aecd =width ;case CellBorderSideRight :_fcfee ._deff =width ;};};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_cegc *Line )SetFitMode (fitMode FitMode ){_cegc ._ccba =fitMode };func (_eded *Image )makeXObject ()error {_ebde :=_eded ._dbgb ;if _ebde ==nil {_ebde =_a .NewFlateEncoder ();};_gfb ,_egacb :=_ddb .NewXObjectImageFromImage (_eded ._aeaed ,nil ,_ebde );
if _egacb !=nil {_cf .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_egacb );return _egacb ;};_eded ._gebaa =_gfb ;
return nil ;};func (_cbcaf *TOCLine )getLineLink ()*_ddb .PdfAnnotation {if _cbcaf ._efgbg <=0{return nil ;};return _ffab (_cbcaf ._efgbg -1,_cbcaf ._added ,_cbcaf ._ecdf ,0);};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_dfba *TableCell )SetBorderLineStyle (style _ggb .LineStyle ){_dfba ._bcffc =style };

// SetStyleTop sets border style for top side.
func (_ega *border )SetStyleTop (style CellBorderStyle ){_ega ._beag =style };

// NewImageFromData creates an Image from image data.
func (_fbfg *Creator )NewImageFromData (data []byte )(*Image ,error ){return _eeba (data )};

// SetMargins sets the Paragraph's margins.
func (_gcadb *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_gcadb ._ebgb .Left =left ;_gcadb ._ebgb .Right =right ;_gcadb ._ebgb .Top =top ;_gcadb ._ebgb .Bottom =bottom ;};func _eed (_egd *Chapter ,_acb *TOC ,_dab *_ddb .Outline ,_bag string ,_fccb int ,_cged TextStyle )*Chapter {var _cced uint =1;
if _egd !=nil {_cced =_egd ._gagf +1;};_beaa :=&Chapter {_fbd :_fccb ,_bege :_bag ,_bab :true ,_fedf :true ,_dgg :_egd ,_gccb :_acb ,_age :_dab ,_fade :[]Drawable {},_gagf :_cced };_cae :=_ffcf (_beaa .headingText (),_cged );_cae .SetFont (_cged .Font );
_cae .SetFontSize (_cged .FontSize );_beaa ._edf =_cae ;return _beaa ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_fbg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _fbg ._eeb .Left ,_fbg ._eeb .Right ,_fbg ._eeb .Top ,_fbg ._eeb .Bottom ;};

// Height returns the total height of all rows.
func (_bbccg *Table )Height ()float64 {_cbgbb :=float64 (0.0);for _ ,_dead :=range _bbccg ._fcga {_cbgbb +=_dead ;};return _cbgbb ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_gcbb *Invoice )AddressStyle ()TextStyle {return _gcbb ._dcaa };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_eaga *Creator )Draw (d Drawable )error {if _eaga .getActivePage ()==nil {_eaga .NewPage ();};_beea ,_dbbb ,_bebg :=d .GeneratePageBlocks (_eaga ._fda );if _bebg !=nil {return _bebg ;};if len (_dbbb ._ggcf )> 0{_eaga .Errors =append (_eaga .Errors ,_dbbb ._ggcf ...);
};for _fafg ,_fgda :=range _beea {if _fafg > 0{_eaga .NewPage ();};_dcfc :=_eaga .getActivePage ();if _ggde ,_eeg :=_eaga ._dfg [_dcfc ];_eeg {if _bdfd :=_ggde .mergeBlocks (_fgda );_bdfd !=nil {return _bdfd ;};if _ceea :=_bcbc (_fgda ._ad ,_ggde ._ad );
_ceea !=nil {return _ceea ;};}else {_eaga ._dfg [_dcfc ]=_fgda ;};};_eaga ._fda .X =_dbbb .X ;_eaga ._fda .Y =_dbbb .Y ;_eaga ._fda .Height =_dbbb .PageHeight -_dbbb .Y -_dbbb .Margins .Bottom ;return nil ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_faab *Creator )SetForms (form *_ddb .PdfAcroForm )error {_faab ._cdg =form ;return nil };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_dgabd *TOC )SetLineNumberStyle (style TextStyle ){_dgabd ._aebeg =style };func (_defd *Invoice )drawInformation ()*Table {_egec :=_abeacc (2);_eege :=append ([][2]*InvoiceCell {_defd ._adfd ,_defd ._dada ,_defd ._fegd },_defd ._baeg ...);for _ ,_gfgf :=range _eege {_gabaf ,_bgc :=_gfgf [0],_gfgf [1];
if _bgc .Value ==""{continue ;};_ecge :=_egec .NewCell ();_ecge .SetBackgroundColor (_gabaf .BackgroundColor );_defd .setCellBorder (_ecge ,_gabaf );_cfab :=_fgee (_gabaf .TextStyle );_cfab .Append (_gabaf .Value );_cfab .SetMargins (0,0,2,1);_ecge .SetContent (_cfab );
_ecge =_egec .NewCell ();_ecge .SetBackgroundColor (_bgc .BackgroundColor );_defd .setCellBorder (_ecge ,_bgc );_cfab =_fgee (_bgc .TextStyle );_cfab .Append (_bgc .Value );_cfab .SetMargins (0,0,2,1);_ecge .SetContent (_cfab );};return _egec ;};

// SetColorRight sets border color for right.
func (_bed *border )SetColorRight (col Color ){_bed ._bfd =col };