//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_gd "encoding/binary";_f "errors";_a "fmt";_bd "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/bitwise";_gg "image";_g "image/color";_c "image/draw";_bg "math";);type RasterOperator int ;func (_gaaeg *NRGBA16 )setNRGBA (_cgceb ,_cccc ,_cbbe int ,_acff _g .NRGBA ){if _cgceb *3%2==0{_gaaeg .Data [_cbbe ]=(_acff .R >>4)<<4|(_acff .G >>4);
_gaaeg .Data [_cbbe +1]=(_acff .B >>4)<<4|(_gaaeg .Data [_cbbe +1]&0xf);}else {_gaaeg .Data [_cbbe ]=(_gaaeg .Data [_cbbe ]&0xf0)|(_acff .R >>4);_gaaeg .Data [_cbbe +1]=(_acff .G >>4)<<4|(_acff .B >>4);};if _gaaeg .Alpha !=nil {_bbef :=_cccc *BytesPerLine (_gaaeg .Width ,4,1);
if _bbef < len (_gaaeg .Alpha ){if _cgceb %2==0{_gaaeg .Alpha [_bbef ]=(_acff .A >>uint (4))<<uint (4)|(_gaaeg .Alpha [_cbbe ]&0xf);}else {_gaaeg .Alpha [_bbef ]=(_gaaeg .Alpha [_bbef ]&0xf0)|(_acff .A >>uint (4));};};};};func (_abgg *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_abgg .copy ()}};
func _gaebd (_ggb _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_ggb .Y }};var (_cfg =_dd ();_gfd =_fbb ();_aea =_ebd (););func (_bafe *Monochrome )setIndexedBit (_ecda int ){_bafe .Data [(_ecda >>3)]|=0x80>>uint (_ecda &7)};func (_bbbd *Gray4 )Histogram ()(_gcea [256]int ){for _dbea :=0;
_dbea < _bbbd .Width ;_dbea ++{for _ebaf :=0;_ebaf < _bbbd .Height ;_ebaf ++{_gcea [_bbbd .GrayAt (_dbea ,_ebaf ).Y ]++;};};return _gcea ;};func (_bdeb *Gray8 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_bdeb .Width ,Y :_bdeb .Height }};
};var _ _gg .Image =&Gray16 {};func _dff (){for _fgdf :=0;_fgdf < 256;_fgdf ++{_fggb [_fgdf ]=uint8 (_fgdf &0x1)+(uint8 (_fgdf >>1)&0x1)+(uint8 (_fgdf >>2)&0x1)+(uint8 (_fgdf >>3)&0x1)+(uint8 (_fgdf >>4)&0x1)+(uint8 (_fgdf >>5)&0x1)+(uint8 (_fgdf >>6)&0x1)+(uint8 (_fgdf >>7)&0x1);
};};func (_dafg *Gray8 )At (x ,y int )_g .Color {_adeaa ,_ :=_dafg .ColorAt (x ,y );return _adeaa };func _dbcb (_ccfeb _g .NYCbCrA )_g .RGBA {_baf ,_eeea ,_dcb ,_ffg :=_ccc (_ccfeb ).RGBA ();return _g .RGBA {R :uint8 (_baf >>8),G :uint8 (_eeea >>8),B :uint8 (_dcb >>8),A :uint8 (_ffg >>8)};
};func (_fggc *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_fggc .Width ||y >=_fggc .Height {return ;};g =_ggaa (g );_fggc .setGray (x ,y ,g );};func _ccgdd (_bbec _gg .Image ,_ggddg Image ,_becbe _gg .Rectangle ){if _aafb ,_gbea :=_bbec .(SMasker );
_gbea &&_aafb .HasAlpha (){_ggddg .(SMasker ).MakeAlpha ();};_cee (_bbec ,_ggddg ,_becbe );};func _eccd (_bdee _gg .Image ,_acga uint8 )*_gg .Gray {_badd :=_bdee .Bounds ();_edge :=_gg .NewGray (_badd );var (_ccbg _g .Color ;_cdce _g .Gray ;);for _bead :=0;
_bead < _badd .Max .X ;_bead ++{for _begc :=0;_begc < _badd .Max .Y ;_begc ++{_ccbg =_bdee .At (_bead ,_begc );_edge .Set (_bead ,_begc ,_ccbg );_cdce =_edge .GrayAt (_bead ,_begc );_edge .SetGray (_bead ,_begc ,_g .Gray {Y :_gcec (_cdce .Y ,_acga )});
};};return _edge ;};func _aggd (_gbdg _g .Color )_g .Color {_ffaf :=_g .NRGBAModel .Convert (_gbdg ).(_g .NRGBA );return _ebdb (_ffaf );};func (_aef *Gray4 )setGray (_dfba int ,_efc int ,_dfge _g .Gray ){_ecee :=_efc *_aef .BytesPerLine ;_edeb :=_ecee +(_dfba >>1);
if _edeb >=len (_aef .Data ){return ;};_gabd :=_dfge .Y >>4;_aef .Data [_edeb ]=(_aef .Data [_edeb ]&(^(0xf0>>uint (4*(_dfba &1)))))|(_gabd <<uint (4-4*(_dfba &1)));};func _gcec (_bedf ,_bdede uint8 )uint8 {if _bedf < _bdede {return 255;};return 0;};func (_fdda *ImageBase )setFourBytes (_bded int ,_geaa uint32 )error {if _bded +3> len (_fdda .Data )-1{return _a .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_bded );
};_fdda .Data [_bded ]=byte ((_geaa &0xff000000)>>24);_fdda .Data [_bded +1]=byte ((_geaa &0xff0000)>>16);_fdda .Data [_bded +2]=byte ((_geaa &0xff00)>>8);_fdda .Data [_bded +3]=byte (_geaa &0xff);return nil ;};func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};
func (_cce *Monochrome )copy ()*Monochrome {_ebb :=_gcc (_cce .Width ,_cce .Height );_ebb .ModelThreshold =_cce .ModelThreshold ;_ebb .Data =make ([]byte ,len (_cce .Data ));copy (_ebb .Data ,_cce .Data );if len (_cce .Decode )!=0{_ebb .Decode =make ([]float64 ,len (_cce .Decode ));
copy (_ebb .Decode ,_cce .Decode );};if len (_cce .Alpha )!=0{_ebb .Alpha =make ([]byte ,len (_cce .Alpha ));copy (_ebb .Alpha ,_cce .Alpha );};return _ebb ;};func (_cebf *NRGBA64 )At (x ,y int )_g .Color {_gdgba ,_ :=_cebf .ColorAt (x ,y );return _gdgba };
func _eabg (_bbf _g .Gray )_g .Gray {_afdf :=_bbf .Y >>6;_afdf |=_afdf <<2;_bbf .Y =_afdf |_afdf <<4;return _bbf ;};var _ Image =&NRGBA16 {};func _cde (_dcea _g .NRGBA64 )_g .RGBA {_afca ,_eece ,_abe ,_dgd :=_dcea .RGBA ();return _g .RGBA {R :uint8 (_afca >>8),G :uint8 (_eece >>8),B :uint8 (_abe >>8),A :uint8 (_dgd >>8)};
};func (_cbdb *Monochrome )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_cbdb .Width ,Y :_cbdb .Height }};};func _ecbc (_cddf ,_adadd Gray ,_aga _gg .Rectangle ){for _cfde :=0;_cfde < _aga .Max .X ;_cfde ++{for _fbgg :=0;_fbgg < _aga .Max .Y ;
_fbgg ++{_adadd .SetGray (_cfde ,_fbgg ,_cddf .GrayAt (_cfde ,_fbgg ));};};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _fbad (_gedb _gg .Image )(Image ,error ){if _adadf ,_ffcf :=_gedb .(*Gray4 );_ffcf {return _adadf .Copy (),nil ;
};_ecbg :=_gedb .Bounds ();_ecea ,_bdaa :=NewImage (_ecbg .Max .X ,_ecbg .Max .Y ,4,1,nil ,nil ,nil );if _bdaa !=nil {return nil ,_bdaa ;};_fega (_gedb ,_ecea ,_ecbg );return _ecea ,nil ;};func _fcec (_gbf CMYK ,_daed Gray ,_cege _gg .Rectangle ){for _ccdfc :=0;
_ccdfc < _cege .Max .X ;_ccdfc ++{for _bba :=0;_bba < _cege .Max .Y ;_bba ++{_gec :=_begf (_gbf .CMYKAt (_ccdfc ,_bba ));_daed .SetGray (_ccdfc ,_bba ,_gec );};};};func (_acfb *Gray8 )SetGray (x ,y int ,g _g .Gray ){_dccc :=y *_acfb .BytesPerLine +x ;if _dccc > len (_acfb .Data )-1{return ;
};_acfb .Data [_dccc ]=g .Y ;};func _bfcgd (_fdag _gg .Image )(Image ,error ){if _dbgb ,_cgfg :=_fdag .(*Gray8 );_cgfg {return _dbgb .Copy (),nil ;};_edgc :=_fdag .Bounds ();_adc ,_gagg :=NewImage (_edgc .Max .X ,_edgc .Max .Y ,8,1,nil ,nil ,nil );if _gagg !=nil {return nil ,_gagg ;
};_fega (_fdag ,_adc ,_edgc );return _adc ,nil ;};func _eaga (_gea _g .Gray )_g .RGBA {return _g .RGBA {R :_gea .Y ,G :_gea .Y ,B :_gea .Y ,A :0xff}};func _dd ()(_eeg [256]uint16 ){for _fea :=0;_fea < 256;_fea ++{if _fea &0x01!=0{_eeg [_fea ]|=0x3;};if _fea &0x02!=0{_eeg [_fea ]|=0xc;
};if _fea &0x04!=0{_eeg [_fea ]|=0x30;};if _fea &0x08!=0{_eeg [_fea ]|=0xc0;};if _fea &0x10!=0{_eeg [_fea ]|=0x300;};if _fea &0x20!=0{_eeg [_fea ]|=0xc00;};if _fea &0x40!=0{_eeg [_fea ]|=0x3000;};if _fea &0x80!=0{_eeg [_fea ]|=0xc000;};};return _eeg ;};
var _ Image =&Monochrome {};func (_dacf *CMYK32 )Set (x ,y int ,c _g .Color ){_edf :=4*(y *_dacf .Width +x );if _edf +3>=len (_dacf .Data ){return ;};_cef :=_g .CMYKModel .Convert (c ).(_g .CMYK );_dacf .Data [_edf ]=_cef .C ;_dacf .Data [_edf +1]=_cef .M ;
_dacf .Data [_edf +2]=_cef .Y ;_dacf .Data [_edf +3]=_cef .K ;};func _cgd (_acca RGBA ,_afc CMYK ,_abaf _gg .Rectangle ){for _gfgd :=0;_gfgd < _abaf .Max .X ;_gfgd ++{for _cca :=0;_cca < _abaf .Max .Y ;_cca ++{_eafc :=_acca .RGBAAt (_gfgd ,_cca );_afc .SetCMYK (_gfgd ,_cca ,_ffb (_eafc ));
};};};func (_bcad *NRGBA32 )At (x ,y int )_g .Color {_afaa ,_ :=_bcad .ColorAt (x ,y );return _afaa };func (_gafc *ImageBase )GetAlpha ()[]byte {return _gafc .Alpha };func _gbag (_bgcf _g .NRGBA64 )_g .Gray {var _fedc _g .NRGBA64 ;if _bgcf ==_fedc {return _g .Gray {Y :0xff};
};_fdf ,_gdcc ,_acbe ,_ :=_bgcf .RGBA ();_gce :=(19595*_fdf +38470*_gdcc +7471*_acbe +1<<15)>>24;return _g .Gray {Y :uint8 (_gce )};};func (_beafa *NRGBA32 )setRGBA (_fbda int ,_agdc _g .NRGBA ){_fbaab :=3*_fbda ;_beafa .Data [_fbaab ]=_agdc .R ;_beafa .Data [_fbaab +1]=_agdc .G ;
_beafa .Data [_fbaab +2]=_agdc .B ;if _fbda < len (_beafa .Alpha ){_beafa .Alpha [_fbda ]=_agdc .A ;};};func _ebdb (_ddgc _g .NRGBA )_g .NRGBA {_ddgc .R =_ddgc .R >>4|(_ddgc .R >>4)<<4;_ddgc .G =_ddgc .G >>4|(_ddgc .G >>4)<<4;_ddgc .B =_ddgc .B >>4|(_ddgc .B >>4)<<4;
return _ddgc ;};func _baag (_bfcg _g .Gray )_g .NRGBA {return _g .NRGBA {R :_bfcg .Y ,G :_bfcg .Y ,B :_bfcg .Y ,A :0xff}};type nrgba64 interface{NRGBA64At (_fbed ,_faagd int )_g .NRGBA64 ;SetNRGBA64 (_ffcfe ,_bbeg int ,_ccccf _g .NRGBA64 );};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};type ColorConverter interface{Convert (_dggc _gg .Image )(Image ,error );};func (_dbeg *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };func (_dgge *Gray16 )Validate ()error {if len (_dgge .Data )!=_dgge .Height *_dgge .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_fbee *Monochrome )getBitAt (_fgb ,_gfcf int )bool {_daeg :=_gfcf *_fbee .BytesPerLine +(_fgb >>3);_gbac :=_fgb &0x07;_cdd :=uint (7-_gbac );if _daeg > len (_fbee .Data )-1{return false ;};if (_fbee .Data [_daeg ]>>_cdd )&0x01>=1{return true ;
};return false ;};func (_gabf *ImageBase )setTwoBytes (_dggca int ,_gecc uint16 )error {if _dggca +1> len (_gabf .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gabf .Data [_dggca ]=byte ((_gecc &0xff00)>>8);
_gabf .Data [_dggca +1]=byte (_gecc &0xff);return nil ;};var _ Image =&RGBA32 {};var _ _gg .Image =&RGBA32 {};func (_begga *Gray16 )SetGray (x ,y int ,g _g .Gray ){_gcae :=(y *_begga .BytesPerLine /2+x )*2;if _gcae +1>=len (_begga .Data ){return ;};_begga .Data [_gcae ]=g .Y ;
_begga .Data [_gcae +1]=g .Y ;};func (_befe *ImageBase )HasAlpha ()bool {if _befe .Alpha ==nil {return false ;};for _bbgg :=range _befe .Alpha {if _befe .Alpha [_bbgg ]!=0xff{return true ;};};return false ;};func _gge (_eabb _g .RGBA )_g .NRGBA {switch _eabb .A {case 0xff:return _g .NRGBA {R :_eabb .R ,G :_eabb .G ,B :_eabb .B ,A :0xff};
case 0x00:return _g .NRGBA {};default:_geab ,_gef ,_ebgea ,_fgeg :=_eabb .RGBA ();_geab =(_geab *0xffff)/_fgeg ;_gef =(_gef *0xffff)/_fgeg ;_ebgea =(_ebgea *0xffff)/_fgeg ;return _g .NRGBA {R :uint8 (_geab >>8),G :uint8 (_gef >>8),B :uint8 (_ebgea >>8),A :uint8 (_fgeg >>8)};
};};func (_afcfc *NRGBA64 )Base ()*ImageBase {return &_afcfc .ImageBase };func _dde (_cfb ,_gedc *Monochrome ,_gaf []byte ,_edeg int )(_bdf error ){var (_gdc ,_fdb ,_gdbe ,_dbe ,_dfc ,_cfe ,_bbd ,_deee int ;_eacd ,_faag ,_dfb ,_gdbf uint32 ;_gfdd ,_egad byte ;
_faac uint16 ;);_deb :=make ([]byte ,4);_ade :=make ([]byte ,4);for _gdbe =0;_gdbe < _cfb .Height -1;_gdbe ,_dbe =_gdbe +2,_dbe +1{_gdc =_gdbe *_cfb .BytesPerLine ;_fdb =_dbe *_gedc .BytesPerLine ;for _dfc ,_cfe =0,0;_dfc < _edeg ;_dfc ,_cfe =_dfc +4,_cfe +1{for _bbd =0;
_bbd < 4;_bbd ++{_deee =_gdc +_dfc +_bbd ;if _deee <=len (_cfb .Data )-1&&_deee < _gdc +_cfb .BytesPerLine {_deb [_bbd ]=_cfb .Data [_deee ];}else {_deb [_bbd ]=0x00;};_deee =_gdc +_cfb .BytesPerLine +_dfc +_bbd ;if _deee <=len (_cfb .Data )-1&&_deee < _gdc +(2*_cfb .BytesPerLine ){_ade [_bbd ]=_cfb .Data [_deee ];
}else {_ade [_bbd ]=0x00;};};_eacd =_gd .BigEndian .Uint32 (_deb );_faag =_gd .BigEndian .Uint32 (_ade );_dfb =_eacd &_faag ;_dfb |=_dfb <<1;_gdbf =_eacd |_faag ;_gdbf &=_gdbf <<1;_faag =_dfb &_gdbf ;_faag &=0xaaaaaaaa;_eacd =_faag |(_faag <<7);_gfdd =byte (_eacd >>24);
_egad =byte ((_eacd >>8)&0xff);_deee =_fdb +_cfe ;if _deee +1==len (_gedc .Data )-1||_deee +1>=_fdb +_gedc .BytesPerLine {if _bdf =_gedc .setByte (_deee ,_gaf [_gfdd ]);_bdf !=nil {return _a .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_deee );
};}else {_faac =(uint16 (_gaf [_gfdd ])<<8)|uint16 (_gaf [_egad ]);if _bdf =_gedc .setTwoBytes (_deee ,_faac );_bdf !=nil {return _a .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_deee );
};_cfe ++;};};};return nil ;};func (_faae *ImageBase )setByte (_ebcg int ,_cddff byte )error {if _ebcg > len (_faae .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_faae .Data [_ebcg ]=_cddff ;
return nil ;};func _egbb (_dfeb int ,_gefbe int )error {return _a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_dfeb ,_gefbe );
};func _efg ()(_fce []byte ){_fce =make ([]byte ,256);for _baa :=0;_baa < 256;_baa ++{_daa :=byte (_baa );_fce [_daa ]=(_daa &0x01)|((_daa &0x04)>>1)|((_daa &0x10)>>2)|((_daa &0x40)>>3)|((_daa &0x02)<<3)|((_daa &0x08)<<2)|((_daa &0x20)<<1)|(_daa &0x80);
};return _fce ;};func (_bbbg *NRGBA64 )Validate ()error {if len (_bbbg .Data )!=3*2*_bbbg .Width *_bbbg .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Image =&Gray2 {};func (_baabg *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_baabg .copy ()}};func (_cdgb *ImageBase )Pix ()[]byte {return _cdgb .Data };func (_bdbc *Monochrome )Validate ()error {if len (_bdbc .Data )!=_bdbc .Height *_bdbc .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _deg (_ffe NRGBA ,_abc CMYK ,_fcd _gg .Rectangle ){for _beb :=0;_beb < _fcd .Max .X ;_beb ++{for _eag :=0;_eag < _fcd .Max .Y ;_eag ++{_cac :=_ffe .NRGBAAt (_beb ,_eag );_abc .SetCMYK (_beb ,_eag ,_bfg (_cac ));};};};func _ffec (_gcg _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_gcg .R >>8),G :uint8 (_gcg .G >>8),B :uint8 (_gcg .B >>8),A :uint8 (_gcg .A >>8)};
};func (_ccbca *NRGBA64 )setNRGBA64 (_becga int ,_fcga _g .NRGBA64 ,_fgfdc int ){_ccbca .Data [_becga ]=uint8 (_fcga .R >>8);_ccbca .Data [_becga +1]=uint8 (_fcga .R &0xff);_ccbca .Data [_becga +2]=uint8 (_fcga .G >>8);_ccbca .Data [_becga +3]=uint8 (_fcga .G &0xff);
_ccbca .Data [_becga +4]=uint8 (_fcga .B >>8);_ccbca .Data [_becga +5]=uint8 (_fcga .B &0xff);if _fgfdc +1< len (_ccbca .Alpha ){_ccbca .Alpha [_fgfdc ]=uint8 (_fcga .A >>8);_ccbca .Alpha [_fgfdc +1]=uint8 (_fcga .A &0xff);};};var _ _gg .Image =&Gray8 {};
func init (){_dff ()};func (_fcdb *NRGBA64 )Set (x ,y int ,c _g .Color ){_gbc :=(y *_fcdb .Width +x )*2;_ecad :=_gbc *3;if _ecad +5>=len (_fcdb .Data ){return ;};_fefe :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_fcdb .setNRGBA64 (_ecad ,_fefe ,_gbc );
};func (_acfe *Gray8 )Base ()*ImageBase {return &_acfe .ImageBase };func _gcc (_gbg ,_dgg int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_gbg ,_dgg ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func _bbdcc (_afggc _gg .Image )(Image ,error ){if _bgacb ,_gfdcd :=_afggc .(*NRGBA32 );
_gfdcd {return _bgacb .Copy (),nil ;};_efba ,_egdg ,_ccdfg :=_ggdae (_afggc ,1);_efdc ,_ddagf :=NewImage (_efba .Max .X ,_efba .Max .Y ,8,3,nil ,_ccdfg ,nil );if _ddagf !=nil {return nil ,_ddagf ;};_adac (_afggc ,_efdc ,_efba );if len (_ccdfg )!=0&&!_egdg {if _cacf :=_gefbb (_ccdfg ,_efdc );
_cacf !=nil {return nil ,_cacf ;};};return _efdc ,nil ;};func _gbgf (_aab _gg .Image ,_abea Image ,_agbe _gg .Rectangle ){if _abbd ,_dgfff :=_aab .(SMasker );_dgfff &&_abbd .HasAlpha (){_abea .(SMasker ).MakeAlpha ();};switch _aggf :=_aab .(type ){case Gray :_afab (_aggf ,_abea .(RGBA ),_agbe );
case NRGBA :_dadeb (_aggf ,_abea .(RGBA ),_agbe );case *_gg .NYCbCrA :_aggde (_aggf ,_abea .(RGBA ),_agbe );case CMYK :_ecgc (_aggf ,_abea .(RGBA ),_agbe );case RGBA :_bccd (_aggf ,_abea .(RGBA ),_agbe );case nrgba64 :_egcbe (_aggf ,_abea .(RGBA ),_agbe );
default:_cee (_aab ,_abea ,_agbe );};};func (_cfbgcc *Monochrome )setGrayBit (_ccag ,_aedf int ){_cfbgcc .Data [_ccag ]|=0x80>>uint (_aedf &7)};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_fdec :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_fdec .Data =make ([]byte ,height *_fdec .BytesPerLine );};return _fdec ;};func _bfd (_fgg _g .CMYK )_g .RGBA {_ece ,_fgcc ,_cd :=_g .CMYKToRGB (_fgg .C ,_fgg .M ,_fgg .Y ,_fgg .K );return _g .RGBA {R :_ece ,G :_fgcc ,B :_cd ,A :0xff};};
func (_dcbb *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dcbb .copy ()}};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _cgbbc ,_bgbfd ,_eeadc ,_bfbgf int ;for _ecec :=0;_ecec < len (histogram );_ecec ++{if histogram [_ecec ]> 0{_cgbbc =_ecec ;break ;};};if _cgbbc > 0{_cgbbc --;};for _cebd :=255;_cebd > 0;_cebd --{if histogram [_cebd ]> 0{_bfbgf =_cebd ;
break ;};};if _bfbgf < 255{_bfbgf ++;};for _adfe :=0;_adfe < 256;_adfe ++{if histogram [_adfe ]> _bgbfd {_eeadc =_adfe ;_bgbfd =histogram [_adfe ];};};var _aeedf bool ;if (_eeadc -_cgbbc )< (_bfbgf -_eeadc ){_aeedf =true ;var _bcfa int ;_gagdg :=255;for _bcfa < _gagdg {_bcffc :=histogram [_bcfa ];
histogram [_bcfa ]=histogram [_gagdg ];histogram [_gagdg ]=_bcffc ;_bcfa ++;_gagdg --;};_cgbbc =255-_bfbgf ;_eeadc =255-_eeadc ;};if _cgbbc ==_eeadc {return uint8 (_cgbbc );};_efeb :=float64 (histogram [_eeadc ]);_badf :=float64 (_cgbbc -_eeadc );_fbfg :=_bg .Sqrt (_efeb *_efeb +_badf *_badf );
_efeb /=_fbfg ;_badf /=_fbfg ;_fbfg =_efeb *float64 (_cgbbc )+_badf *float64 (histogram [_cgbbc ]);_gcaf :=_cgbbc ;var _cgdd float64 ;for _ccffa :=_cgbbc +1;_ccffa <=_eeadc ;_ccffa ++{_dcee :=_efeb *float64 (_ccffa )+_badf *float64 (histogram [_ccffa ])-_fbfg ;
if _dcee > _cgdd {_gcaf =_ccffa ;_cgdd =_dcee ;};};_gcaf --;if _aeedf {var _bcfe int ;_fabd :=255;for _bcfe < _fabd {_feda :=histogram [_bcfe ];histogram [_bcfe ]=histogram [_fabd ];histogram [_fabd ]=_feda ;_bcfe ++;_fabd --;};return uint8 (255-_gcaf );
};return uint8 (_gcaf );};func (_aadb *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_aadb .ModelThreshold )};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_facg :=y *bytesPerLine +x >>2;if _facg >=len (data ){return _g .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ggfb :=data [_facg ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ggfb =uint8 (uint32 (LinearInterpolate (float64 (_ggfb ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_ggfb *85},nil ;};func (_gfdc *Gray4 )Validate ()error {if len (_gfdc .Data )!=_gfdc .Height *_gfdc .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_fgcd *RGBA32 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_fgcd .Width ,Y :_fgcd .Height }};};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _aggde (_bgff *_gg .NYCbCrA ,_baec RGBA ,_eecg _gg .Rectangle ){for _abfg :=0;_abfg < _eecg .Max .X ;_abfg ++{for _bacb :=0;_bacb < _eecg .Max .Y ;_bacb ++{_edde :=_bgff .NYCbCrAAt (_abfg ,_bacb );_baec .SetRGBA (_abfg ,_bacb ,_dbcb (_edde ));
};};};func (_cfcc *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_cfcc .Width ||y >=_cfcc .Height {return ;};_fab :=Gray2Model .Convert (c ).(_g .Gray );_fgbe :=y *_cfcc .BytesPerLine ;_fcgf :=_fgbe +(x >>2);_eca :=_fab .Y >>6;_cfcc .Data [_fcgf ]=(_cfcc .Data [_fcgf ]&(^(0xc0>>uint (2*((x )&3)))))|(_eca <<uint (6-2*(x &3)));
};func (_gdfe *Gray8 )Set (x ,y int ,c _g .Color ){_bdfb :=y *_gdfe .BytesPerLine +x ;if _bdfb > len (_gdfe .Data )-1{return ;};_edgd :=_g .GrayModel .Convert (c );_gdfe .Data [_bdfb ]=_edgd .(_g .Gray ).Y ;};func _bbgb (_fegb *Monochrome ,_bdgc ,_dggcd ,_deadc ,_dacd int ,_gbae RasterOperator ,_eacg *Monochrome ,_ceeb ,_fgfd int )error {if _fegb ==nil {return _f .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _gbae ==PixDst {return nil ;};switch _gbae {case PixClr ,PixSet ,PixNotDst :_acdb (_fegb ,_bdgc ,_dggcd ,_deadc ,_dacd ,_gbae );return nil ;};if _eacg ==nil {_bd .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _f .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bbcfc :=_baac (_fegb ,_bdgc ,_dggcd ,_deadc ,_dacd ,_gbae ,_eacg ,_ceeb ,_fgfd );_bbcfc !=nil {return _bbcfc ;};return nil ;};func _cbbf (_ecbdf *_gg .Gray ,_bddb uint8 )*_gg .Gray {_eagd :=_ecbdf .Bounds ();
_cbfbc :=_gg .NewGray (_eagd );for _gbbf :=0;_gbbf < _eagd .Dx ();_gbbf ++{for _eagde :=0;_eagde < _eagd .Dy ();_eagde ++{_aaag :=_ecbdf .GrayAt (_gbbf ,_eagde );_cbfbc .SetGray (_gbbf ,_eagde ,_g .Gray {Y :_gcec (_aaag .Y ,_bddb )});};};return _cbfbc ;
};func (_afag *Gray16 )At (x ,y int )_g .Color {_cfa ,_ :=_afag .ColorAt (x ,y );return _cfa };func _bbga (_aaf _g .RGBA )_g .Gray {_dgga :=(19595*uint32 (_aaf .R )+38470*uint32 (_aaf .G )+7471*uint32 (_aaf .B )+1<<7)>>16;return _g .Gray {Y :uint8 (_dgga )};
};func (_egfe *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_egfe .copy ()}};func _eggg (_afba int ,_bgegf int )int {if _afba < _bgegf {return _afba ;};return _bgegf ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_geea :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _bgaf Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bgaf =&Monochrome {ImageBase :_geea ,ModelThreshold :0x0f};case 2:_bgaf =&Gray2 {ImageBase :_geea };case 4:_bgaf =&Gray4 {ImageBase :_geea };case 8:_bgaf =&Gray8 {ImageBase :_geea };
case 16:_bgaf =&Gray16 {ImageBase :_geea };};case 3:switch bitsPerComponent {case 4:_bgaf =&NRGBA16 {ImageBase :_geea };case 8:_bgaf =&NRGBA32 {ImageBase :_geea };case 16:_bgaf =&NRGBA64 {ImageBase :_geea };};case 4:_bgaf =&CMYK32 {ImageBase :_geea };};
if _bgaf ==nil {return nil ,ErrInvalidImage ;};return _bgaf ,nil ;};func _agge (_feec *_gg .Gray )bool {for _abgb :=0;_abgb < len (_feec .Pix );_abgb ++{if !_gaac (_feec .Pix [_abgb ]){return false ;};};return true ;};func _fega (_gfaf _gg .Image ,_aceg Image ,_edec _gg .Rectangle ){switch _eeae :=_gfaf .(type ){case Gray :_ecbc (_eeae ,_aceg .(Gray ),_edec );
case NRGBA :_ccdg (_eeae ,_aceg .(Gray ),_edec );case CMYK :_fcec (_eeae ,_aceg .(Gray ),_edec );case RGBA :_egdc (_eeae ,_aceg .(Gray ),_edec );default:_cee (_gfaf ,_aceg .(Image ),_edec );};};func (_afgd *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };
func (_cad *NRGBA16 )At (x ,y int )_g .Color {_eebf ,_ :=_cad .ColorAt (x ,y );return _eebf };var _ Image =&Gray8 {};var _ Image =&NRGBA64 {};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_fcdd :=y *bytesPerLine +x ;
if _fcdd >=len (data ){return _g .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fade :=data [_fcdd ];if len (decode )==2{_fade =uint8 (uint32 (LinearInterpolate (float64 (_fade ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_fade },nil ;};func _aeed (_gadc _gg .Image )(Image ,error ){if _dcf ,_edg :=_gadc .(*Monochrome );
_edg {return _dcf ,nil ;};_cec :=_gadc .Bounds ();var _cfc Gray ;switch _bafg :=_gadc .(type ){case Gray :_cfc =_bafg ;case NRGBA :_cfc =&Gray8 {ImageBase :NewImageBase (_cec .Max .X ,_cec .Max .Y ,8,1,nil ,nil ,nil )};_gcge (_cfc ,_bafg ,_cec );case nrgba64 :_cfc =&Gray8 {ImageBase :NewImageBase (_cec .Max .X ,_cec .Max .Y ,8,1,nil ,nil ,nil )};
_faed (_cfc ,_bafg ,_cec );default:_dgf ,_cfce :=GrayConverter .Convert (_gadc );if _cfce !=nil {return nil ,_cfce ;};_cfc =_dgf .(Gray );};_adb ,_fdgb :=NewImage (_cec .Max .X ,_cec .Max .Y ,1,1,nil ,nil ,nil );if _fdgb !=nil {return nil ,_fdgb ;};_bgb :=_adb .(*Monochrome );
_ggd :=AutoThresholdTriangle (GrayHistogram (_cfc ));for _ebf :=0;_ebf < _cec .Max .X ;_ebf ++{for _efdf :=0;_efdf < _cec .Max .Y ;_efdf ++{_dgfg :=_ggef (_cfc .GrayAt (_ebf ,_efdf ),monochromeModel (_ggd ));_bgb .SetGray (_ebf ,_efdf ,_dgfg );};};return _adb ,nil ;
};func InDelta (expected ,current ,delta float64 )bool {_ccffg :=expected -current ;if _ccffg <=-delta ||_ccffg >=delta {return false ;};return true ;};func (_fbe *Monochrome )ResolveDecode ()error {if len (_fbe .Decode )!=2{return nil ;};if _fbe .Decode [0]==1&&_fbe .Decode [1]==0{if _adaa :=_fbe .InverseData ();
_adaa !=nil {return _adaa ;};_fbe .Decode =nil ;};return nil ;};func (_bdadf *ImageBase )MakeAlpha (){_bdadf .newAlpha ()};func _gdbb (_fgc _g .NRGBA )_g .Gray {var _gagd _g .NRGBA ;if _fgc ==_gagd {return _g .Gray {Y :0xff};};_adea ,_gba ,_adadc ,_ :=_fgc .RGBA ();
_bbgf :=(19595*_adea +38470*_gba +7471*_adadc +1<<15)>>24;return _g .Gray {Y :uint8 (_bbgf )};};func (_ddac *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_ddac .BytesPerLine ,_ddac .Data ,_ddac .Decode );};func _bcff (_eface _gg .Image )(Image ,error ){if _eed ,_bcd :=_eface .(*Gray16 );
_bcd {return _eed .Copy (),nil ;};_afef :=_eface .Bounds ();_fabf ,_fcea :=NewImage (_afef .Max .X ,_afef .Max .Y ,16,1,nil ,nil ,nil );if _fcea !=nil {return nil ,_fcea ;};_fega (_eface ,_fabf ,_afef );return _fabf ,nil ;};func _bec (_geb ,_ged int ,_dcd []byte )*Monochrome {_aed :=_gcc (_geb ,_ged );
_aed .Data =_dcd ;return _aed ;};func (_debb *Monochrome )clearBit (_add ,_bgbf int ){_debb .Data [_add ]&=^(0x80>>uint (_bgbf &7))};func _fbaf (_abccf _g .Color )_g .Color {_ffge :=_g .GrayModel .Convert (_abccf ).(_g .Gray );return _eabg (_ffge );};func (_gfce *NRGBA16 )Set (x ,y int ,c _g .Color ){_cfdef :=y *_gfce .BytesPerLine +x *3/2;
if _cfdef +1>=len (_gfce .Data ){return ;};_fagf :=NRGBA16Model .Convert (c ).(_g .NRGBA );_gfce .setNRGBA (x ,y ,_cfdef ,_fagf );};func (_gbd *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_f .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_bccc :=_gcc (width ,height );_dcfd :=make ([]int ,height );_abeg :=make ([]int ,width );_aaeg :=float64 (_gbd .Width )/float64 (width );_fcc :=float64 (_gbd .Height )/float64 (height );for _eabbe :=0;_eabbe < height ;_eabbe ++{_dcfd [_eabbe ]=int (_bg .Min (_fcc *float64 (_eabbe )+0.5,float64 (_gbd .Height -1)));
};for _gfag :=0;_gfag < width ;_gfag ++{_abeg [_gfag ]=int (_bg .Min (_aaeg *float64 (_gfag )+0.5,float64 (_gbd .Width -1)));};_egbdd :=-1;_efag :=byte (0);for _adge :=0;_adge < height ;_adge ++{_bac :=_dcfd [_adge ]*_gbd .BytesPerLine ;_gdf :=_adge *_bccc .BytesPerLine ;
for _fdde :=0;_fdde < width ;_fdde ++{_aadc :=_abeg [_fdde ];if _aadc !=_egbdd {_efag =_gbd .getBit (_bac ,_aadc );if _efag !=0{_bccc .setBit (_gdf ,_fdde );};_egbdd =_aadc ;}else {if _efag !=0{_bccc .setBit (_gdf ,_fdde );};};};};return _bccc ,nil ;};
type NRGBA interface{NRGBAAt (_cddd ,_afcf int )_g .NRGBA ;SetNRGBA (_ccffd ,_bbeb int ,_cea _g .NRGBA );};var _ NRGBA =&NRGBA16 {};func (_cdb *Gray16 )Set (x ,y int ,c _g .Color ){_efadc :=(y *_cdb .BytesPerLine /2+x )*2;if _efadc +1>=len (_cdb .Data ){return ;
};_dege :=_g .Gray16Model .Convert (c ).(_g .Gray16 );_cdb .Data [_efadc ],_cdb .Data [_efadc +1]=uint8 (_dege .Y >>8),uint8 (_dege .Y &0xff);};func _fg (_gad ,_be *Monochrome )(_gdg error ){_fc :=_be .BytesPerLine ;_db :=_gad .BytesPerLine ;var (_bc byte ;
_fd uint16 ;_da ,_gdd ,_gb ,_ea ,_ac int ;);for _gb =0;_gb < _be .Height ;_gb ++{_da =_gb *_fc ;_gdd =2*_gb *_db ;for _ea =0;_ea < _fc ;_ea ++{_bc =_be .Data [_da +_ea ];_fd =_cfg [_bc ];_ac =_gdd +_ea *2;if _gad .BytesPerLine !=_be .BytesPerLine *2&&(_ea +1)*2> _gad .BytesPerLine {_gdg =_gad .setByte (_ac ,byte (_fd >>8));
}else {_gdg =_gad .setTwoBytes (_ac ,_fd );};if _gdg !=nil {return _gdg ;};};for _ea =0;_ea < _db ;_ea ++{_ac =_gdd +_db +_ea ;_bc =_gad .Data [_gdd +_ea ];if _gdg =_gad .setByte (_ac ,_bc );_gdg !=nil {return _gdg ;};};};return nil ;};func (_ceca *ImageBase )setEightFullBytes (_fagb int ,_fbcc uint64 )error {if _fagb +7> len (_ceca .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ceca .Data [_fagb ]=byte ((_fbcc &0xff00000000000000)>>56);_ceca .Data [_fagb +1]=byte ((_fbcc &0xff000000000000)>>48);_ceca .Data [_fagb +2]=byte ((_fbcc &0xff0000000000)>>40);_ceca .Data [_fagb +3]=byte ((_fbcc &0xff00000000)>>32);_ceca .Data [_fagb +4]=byte ((_fbcc &0xff000000)>>24);
_ceca .Data [_fagb +5]=byte ((_fbcc &0xff0000)>>16);_ceca .Data [_fagb +6]=byte ((_fbcc &0xff00)>>8);_ceca .Data [_fagb +7]=byte (_fbcc &0xff);return nil ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _bg .Abs (xmax -xmin )< 0.000001{return ymin ;
};_fcdc :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _fcdc ;};func (_ebgf *Gray2 )Histogram ()(_ccfb [256]int ){for _ggdf :=0;_ggdf < _ebgf .Width ;_ggdf ++{for _fegf :=0;_fegf < _ebgf .Height ;_fegf ++{_ccfb [_ebgf .GrayAt (_ggdf ,_fegf ).Y ]++;
};};return _ccfb ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_cgce (n )+1);};func _ffb (_aad _g .RGBA )_g .CMYK {_dced ,_ecb ,_dccg ,_deeec :=_g .RGBToCMYK (_aad .R ,_aad .G ,_aad .B );return _g .CMYK {C :_dced ,M :_ecb ,Y :_dccg ,K :_deeec };
};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_efage *Gray4 )GrayAt (x ,y int )_g .Gray {_ggae ,_ :=ColorAtGray4BPC (x ,y ,_efage .BytesPerLine ,_efage .Data ,_efage .Decode );
return _ggae ;};func (_daede *ImageBase )setEightBytes (_cccd int ,_ecbe uint64 )error {_ege :=_daede .BytesPerLine -(_cccd %_daede .BytesPerLine );if _daede .BytesPerLine !=_daede .Width >>3{_ege --;};if _ege >=8{return _daede .setEightFullBytes (_cccd ,_ecbe );
};return _daede .setEightPartlyBytes (_cccd ,_ege ,_ecbe );};type CMYK32 struct{ImageBase };func _egcbe (_gdbef nrgba64 ,_edefc RGBA ,_eggd _gg .Rectangle ){for _defe :=0;_defe < _eggd .Max .X ;_defe ++{for _gff :=0;_gff < _eggd .Max .Y ;_gff ++{_fddee :=_gdbef .NRGBA64At (_defe ,_gff );
_edefc .SetRGBA (_defe ,_gff ,_cde (_fddee ));};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_fbbb *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };
func (_gdac *Gray2 )Validate ()error {if len (_gdac .Data )!=_gdac .Height *_gdac .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_begge *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };var _ Gray =&Gray16 {};func (_dcfde *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_dcfde .copy ()}};
type Image interface{_c .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_beeg ,_cddb int )(_g .Color ,error );Validate ()error ;};func (_dbbc *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func _fff (_egada CMYK ,_fcgad NRGBA ,_ccdfgf _gg .Rectangle ){for _fcda :=0;
_fcda < _ccdfgf .Max .X ;_fcda ++{for _cddde :=0;_cddde < _ccdfgf .Max .Y ;_cddde ++{_cgdgd :=_egada .CMYKAt (_fcda ,_cddde );_fcgad .SetNRGBA (_fcda ,_cddde ,_bgfc (_cgdgd ));};};};func _dadeb (_dcfg NRGBA ,_gddd RGBA ,_efef _gg .Rectangle ){for _degb :=0;
_degb < _efef .Max .X ;_degb ++{for _caac :=0;_caac < _efef .Max .Y ;_caac ++{_abddg :=_dcfg .NRGBAAt (_degb ,_caac );_gddd .SetRGBA (_degb ,_caac ,_bbce (_abddg ));};};};func _ebd ()(_dee [256]uint64 ){for _bcb :=0;_bcb < 256;_bcb ++{if _bcb &0x01!=0{_dee [_bcb ]|=0xff;
};if _bcb &0x02!=0{_dee [_bcb ]|=0xff00;};if _bcb &0x04!=0{_dee [_bcb ]|=0xff0000;};if _bcb &0x08!=0{_dee [_bcb ]|=0xff000000;};if _bcb &0x10!=0{_dee [_bcb ]|=0xff00000000;};if _bcb &0x20!=0{_dee [_bcb ]|=0xff0000000000;};if _bcb &0x40!=0{_dee [_bcb ]|=0xff000000000000;
};if _bcb &0x80!=0{_dee [_bcb ]|=0xff00000000000000;};};return _dee ;};func (_cfcf *Gray2 )At (x ,y int )_g .Color {_abcc ,_ :=_cfcf .ColorAt (x ,y );return _abcc };func _geaf (_baed _gg .Image )(Image ,error ){if _egdd ,_bdc :=_baed .(*RGBA32 );_bdc {return _egdd .Copy (),nil ;
};_bfac ,_dadb ,_acea :=_ggdae (_baed ,1);_ageg :=&RGBA32 {ImageBase :NewImageBase (_bfac .Max .X ,_bfac .Max .Y ,8,3,nil ,_acea ,nil )};_gbgf (_baed ,_ageg ,_bfac );if len (_acea )!=0&&!_dadb {if _cccf :=_gefbb (_acea ,_ageg );_cccf !=nil {return nil ,_cccf ;
};};return _ageg ,nil ;};func _edba (_fgfg _gg .Image )(Image ,error ){if _egab ,_abbb :=_fgfg .(*NRGBA16 );_abbb {return _egab .Copy (),nil ;};_efagd :=_fgfg .Bounds ();_cbgg ,_abge :=NewImage (_efagd .Max .X ,_efagd .Max .Y ,4,3,nil ,nil ,nil );if _abge !=nil {return nil ,_abge ;
};_adac (_fgfg ,_cbgg ,_efagd );return _cbgg ,nil ;};var _ _gg .Image =&Gray4 {};func (_dbg *Gray4 )Base ()*ImageBase {return &_dbg .ImageBase };var _ _gg .Image =&NRGBA16 {};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_aedb :=y *bytesPerLine +x >>3;
if _aedb >=len (data ){return _g .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_egfc :=data [_aedb ]>>uint (7-(x &7))&1;if len (decode )==2{_egfc =uint8 (LinearInterpolate (float64 (_egfc ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_egfc *255},nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_afcad :=(y *bytesPerLine /2+x )*2;
if _afcad +1>=len (data ){return _g .Gray16 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_edgf :=uint16 (data [_afcad ])<<8|uint16 (data [_afcad +1]);if len (decode )==2{_edgf =uint16 (uint64 (LinearInterpolate (float64 (_edgf ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_edgf },nil ;};var _ Image =&NRGBA32 {};var ErrInvalidImage =_f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_afb *ImageBase )copy ()ImageBase {_bed :=*_afb ;_bed .Data =make ([]byte ,len (_afb .Data ));copy (_bed .Data ,_afb .Data );return _bed ;};func (_egbg *NRGBA32 )Base ()*ImageBase {return &_egbg .ImageBase };var _ Gray =&Gray2 {};func (_eedf *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_aedbd :=(y *_eedf .Width +x )*2;
_cceg :=_aedbd *3;if _cceg +5>=len (_eedf .Data ){return ;};_eedf .setNRGBA64 (_cceg ,c ,_aedbd );};type CMYK interface{CMYKAt (_bbg ,_gfgg int )_g .CMYK ;SetCMYK (_caa ,_faaa int ,_cfbg _g .CMYK );};func (_ccgg *Monochrome )setGray (_afg int ,_bee _g .Gray ,_eabed int ){if _bee .Y ==0{_ccgg .clearBit (_eabed ,_afg );
}else {_ccgg .setGrayBit (_eabed ,_afg );};};func ImgToGray (i _gg .Image )*_gg .Gray {if _cbcb ,_bcbc :=i .(*_gg .Gray );_bcbc {return _cbcb ;};_adda :=i .Bounds ();_ffbc :=_gg .NewGray (_adda );for _gggfe :=0;_gggfe < _adda .Max .X ;_gggfe ++{for _bbda :=0;
_bbda < _adda .Max .Y ;_bbda ++{_dcbf :=i .At (_gggfe ,_bbda );_ffbc .Set (_gggfe ,_bbda ,_dcbf );};};return _ffbc ;};func (_acfg *Gray8 )GrayAt (x ,y int )_g .Gray {_bgde ,_ :=ColorAtGray8BPC (x ,y ,_acfg .BytesPerLine ,_acfg .Data ,_acfg .Decode );return _bgde ;
};func (_gabe *Monochrome )getBit (_begg ,_egcb int )uint8 {return _gabe .Data [_begg +(_egcb >>3)]>>uint (7-(_egcb &7))&1;};func _egdc (_accb RGBA ,_ccdf Gray ,_daff _gg .Rectangle ){for _dbcd :=0;_dbcd < _daff .Max .X ;_dbcd ++{for _baab :=0;_baab < _daff .Max .Y ;
_baab ++{_afage :=_bbga (_accb .RGBAAt (_dbcd ,_baab ));_ccdf .SetGray (_dbcd ,_baab ,_afage );};};};func _fgcb (_gbcf *_gg .Gray16 ,_gfff uint8 )*_gg .Gray {_ccfd :=_gbcf .Bounds ();_gbgfd :=_gg .NewGray (_ccfd );for _ebcea :=0;_ebcea < _ccfd .Dx ();_ebcea ++{for _fgeff :=0;
_fgeff < _ccfd .Dy ();_fgeff ++{_ebgd :=_gbcf .Gray16At (_ebcea ,_fgeff );_gbgfd .SetGray (_ebcea ,_fgeff ,_g .Gray {Y :_gcec (uint8 (_ebgd .Y /256),_gfff )});};};return _gbgfd ;};func (_deec *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_fbf :=y *_deec .BytesPerLine +x *3/2;
if _fbf +1>=len (_deec .Data ){return ;};c =_ebdb (c );_deec .setNRGBA (x ,y ,_fbf ,c );};func (_bdg *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };func _gaeb (_faa int )[]uint {var _eef []uint ;_dda :=_faa ;_ff :=_dda /8;if _ff !=0{for _cebg :=0;
_cebg < _ff ;_cebg ++{_eef =append (_eef ,8);};_af :=_dda %8;_dda =0;if _af !=0{_dda =_af ;};};_ca :=_dda /4;if _ca !=0{for _dbc :=0;_dbc < _ca ;_dbc ++{_eef =append (_eef ,4);};_ed :=_dda %4;_dda =0;if _ed !=0{_dda =_ed ;};};_bcc :=_dda /2;if _bcc !=0{for _eac :=0;
_eac < _bcc ;_eac ++{_eef =append (_eef ,2);};};return _eef ;};func _ggdae (_bgcee _gg .Image ,_eeed int )(_gg .Rectangle ,bool ,[]byte ){_beffg :=_bgcee .Bounds ();var (_eceee bool ;_gaed []byte ;);switch _accf :=_bgcee .(type ){case SMasker :_eceee =_accf .HasAlpha ();
case NRGBA ,RGBA ,*_gg .RGBA64 ,nrgba64 ,*_gg .NYCbCrA :_gaed =make ([]byte ,_beffg .Max .X *_beffg .Max .Y *_eeed );case *_gg .Paletted :var _agaa bool ;for _ ,_eade :=range _accf .Palette {_fceaf ,_fddd ,_dcdb ,_gefe :=_eade .RGBA ();if _fceaf ==0&&_fddd ==0&&_dcdb ==0&&_gefe !=0{_agaa =true ;
break ;};};if _agaa {_gaed =make ([]byte ,_beffg .Max .X *_beffg .Max .Y *_eeed );};};return _beffg ,_eceee ,_gaed ;};func _bccd (_gded ,_acba RGBA ,_ddbb _gg .Rectangle ){for _cabag :=0;_cabag < _ddbb .Max .X ;_cabag ++{for _ddga :=0;_ddga < _ddbb .Max .Y ;
_ddga ++{_acba .SetRGBA (_cabag ,_ddga ,_gded .RGBAAt (_cabag ,_ddga ));};};};func _adac (_cdge _gg .Image ,_dggb Image ,_dbca _gg .Rectangle ){if _beega ,_gaec :=_cdge .(SMasker );_gaec &&_beega .HasAlpha (){_dggb .(SMasker ).MakeAlpha ();};switch _bdbf :=_cdge .(type ){case Gray :_eeeg (_bdbf ,_dggb .(NRGBA ),_dbca );
case NRGBA :_bebag (_bdbf ,_dggb .(NRGBA ),_dbca );case *_gg .NYCbCrA :_ddab (_bdbf ,_dggb .(NRGBA ),_dbca );case CMYK :_fff (_bdbf ,_dggb .(NRGBA ),_dbca );case RGBA :_daffe (_bdbf ,_dggb .(NRGBA ),_dbca );case nrgba64 :_ddba (_bdbf ,_dggb .(NRGBA ),_dbca );
default:_cee (_cdge ,_dggb ,_dbca );};};func (_abag *Gray4 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_abag .Width ,Y :_abag .Height }};};func _daffe (_bgbeg RGBA ,_feeed NRGBA ,_bbgaf _gg .Rectangle ){for _bcaf :=0;_bcaf < _bbgaf .Max .X ;
_bcaf ++{for _cfeg :=0;_cfeg < _bbgaf .Max .Y ;_cfeg ++{_ccad :=_bgbeg .RGBAAt (_bcaf ,_cfeg );_feeed .SetNRGBA (_bcaf ,_cfeg ,_gge (_ccad ));};};};var _ Gray =&Monochrome {};func _agf (_dga _gg .Image )(Image ,error ){if _gee ,_edee :=_dga .(*CMYK32 );
_edee {return _gee .Copy (),nil ;};_ebgb :=_dga .Bounds ();_eaba ,_ggag :=NewImage (_ebgb .Max .X ,_ebgb .Max .Y ,8,4,nil ,nil ,nil );if _ggag !=nil {return nil ,_ggag ;};switch _feae :=_dga .(type ){case CMYK :_bccf (_feae ,_eaba .(CMYK ),_ebgb );case Gray :_fgd (_feae ,_eaba .(CMYK ),_ebgb );
case NRGBA :_deg (_feae ,_eaba .(CMYK ),_ebgb );case RGBA :_cgd (_feae ,_eaba .(CMYK ),_ebgb );default:_cee (_dga ,_eaba ,_ebgb );};return _eaba ,nil ;};func _ddab (_adca *_gg .NYCbCrA ,_ggagf NRGBA ,_dade _gg .Rectangle ){for _bdga :=0;_bdga < _dade .Max .X ;
_bdga ++{for _eaeg :=0;_eaeg < _dade .Max .Y ;_eaeg ++{_fcce :=_adca .NYCbCrAAt (_bdga ,_eaeg );_ggagf .SetNRGBA (_bdga ,_eaeg ,_ccc (_fcce ));};};};func (_baagg *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_baagg .BytesPerLine ,_baagg .Data ,_baagg .Decode );
};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bbgb (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_egc *CMYK32 )At (x ,y int )_g .Color {_adff ,_ :=_egc .ColorAt (x ,y );return _adff };
func (_dfcg *ImageBase )getByte (_bab int )(byte ,error ){if _bab > len (_dfcg .Data )-1||_bab < 0{return 0,_a .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bab );};return _dfcg .Data [_bab ],nil ;
};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;
PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;
PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_dfgd *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_dfgd .copy ()}};func (_dgea *Gray4 )At (x ,y int )_g .Color {_eae ,_ :=_dgea .ColorAt (x ,y );return _eae };var _ RGBA =&RGBA32 {};
func _gceb (_feee ,_fcde ,_cbec byte )byte {return (_feee &^(_cbec ))|(_fcde &_cbec )};func _eeeg (_fccd Gray ,_dcac NRGBA ,_gbdga _gg .Rectangle ){for _bebe :=0;_bebe < _gbdga .Max .X ;_bebe ++{for _deaf :=0;_deaf < _gbdga .Max .Y ;_deaf ++{_baff :=_fccd .GrayAt (_bebe ,_deaf );
_dcac .SetNRGBA (_bebe ,_deaf ,_baag (_baff ));};};};func _ce (_egb *Monochrome ,_ad int ,_aba []uint )(*Monochrome ,error ){_ada :=_ad *_egb .Width ;_de :=_ad *_egb .Height ;_fb :=_gcc (_ada ,_de );for _eb ,_ebg :=range _aba {var _ccf error ;switch _ebg {case 2:_ccf =_fg (_fb ,_egb );
case 4:_ccf =_abdg (_fb ,_egb );case 8:_ccf =_gf (_fb ,_egb );};if _ccf !=nil {return nil ,_ccf ;};if _eb !=len (_aba )-1{_egb =_fb .copy ();};};return _fb ,nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_dfaa :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _dfaa ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_cgcc :=width *colorComponents *bitsPerComponent ;_fabb :=_dfaa *8;_ddcgd :=8-(_fabb -_cgcc );_dcdc :=_e .NewReader (data );_aaac :=_dfaa -1;_gadb :=make ([]byte ,_aaac );_edbg :=make ([]byte ,height *_dfaa );
_ddb :=_e .NewWriterMSB (_edbg );var _gfad uint64 ;var _edbd error ;for _afcca :=0;_afcca < height ;_afcca ++{_ ,_edbd =_dcdc .Read (_gadb );if _edbd !=nil {return nil ,_edbd ;};_ ,_edbd =_ddb .Write (_gadb );if _edbd !=nil {return nil ,_edbd ;};_gfad ,_edbd =_dcdc .ReadBits (byte (_ddcgd ));
if _edbd !=nil {return nil ,_edbd ;};_ ,_edbd =_ddb .WriteBits (_gfad ,_ddcgd );if _edbd !=nil {return nil ,_edbd ;};_ddb .FinishByte ();};return _edbg ,nil ;};func _afab (_ddbad Gray ,_aeafc RGBA ,_bag _gg .Rectangle ){for _fcceb :=0;_fcceb < _bag .Max .X ;
_fcceb ++{for _edag :=0;_edag < _bag .Max .Y ;_edag ++{_bedd :=_ddbad .GrayAt (_fcceb ,_edag );_aeafc .SetRGBA (_fcceb ,_edag ,_eaga (_bedd ));};};};func (_bccfg *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_edbf :=_eabg (gray );_bgdb :=y *_bccfg .BytesPerLine ;
_bgab :=_bgdb +(x >>2);if _bgab >=len (_bccfg .Data ){return ;};_bca :=_edbf .Y >>6;_bccfg .Data [_bgab ]=(_bccfg .Data [_bgab ]&(^(0xc0>>uint (2*((x )&3)))))|(_bca <<uint (6-2*(x &3)));};func (_fgbef *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_eacda ,_ :=ColorAtNRGBA32 (x ,y ,_fgbef .Width ,_fgbef .Data ,_fgbef .Alpha ,_fgbef .Decode );
return _eacda ;};func (_gggf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bbgb (_gggf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_geae *Monochrome )Base ()*ImageBase {return &_geae .ImageBase };
func _edaf (_fdba *Monochrome ,_adgea ,_ecbf int ,_agee ,_efca int ,_becb RasterOperator ){var (_fbdc bool ;_eace bool ;_efbc int ;_bebb int ;_gcaa int ;_caag int ;_debf bool ;_dfef byte ;);_acbd :=8-(_adgea &7);_def :=_eefg [_acbd ];_dgb :=_fdba .BytesPerLine *_ecbf +(_adgea >>3);
if _agee < _acbd {_fbdc =true ;_def &=_ffea [8-_acbd +_agee ];};if !_fbdc {_efbc =(_agee -_acbd )>>3;if _efbc !=0{_eace =true ;_bebb =_dgb +1;};};_gcaa =(_adgea +_agee )&7;if !(_fbdc ||_gcaa ==0){_debf =true ;_dfef =_ffea [_gcaa ];_caag =_dgb +1+_efbc ;
};var _ebbc ,_ceeg int ;switch _becb {case PixClr :for _ebbc =0;_ebbc < _efca ;_ebbc ++{_fdba .Data [_dgb ]=_gceb (_fdba .Data [_dgb ],0x0,_def );_dgb +=_fdba .BytesPerLine ;};if _eace {for _ebbc =0;_ebbc < _efca ;_ebbc ++{for _ceeg =0;_ceeg < _efbc ;_ceeg ++{_fdba .Data [_bebb +_ceeg ]=0x0;
};_bebb +=_fdba .BytesPerLine ;};};if _debf {for _ebbc =0;_ebbc < _efca ;_ebbc ++{_fdba .Data [_caag ]=_gceb (_fdba .Data [_caag ],0x0,_dfef );_caag +=_fdba .BytesPerLine ;};};case PixSet :for _ebbc =0;_ebbc < _efca ;_ebbc ++{_fdba .Data [_dgb ]=_gceb (_fdba .Data [_dgb ],0xff,_def );
_dgb +=_fdba .BytesPerLine ;};if _eace {for _ebbc =0;_ebbc < _efca ;_ebbc ++{for _ceeg =0;_ceeg < _efbc ;_ceeg ++{_fdba .Data [_bebb +_ceeg ]=0xff;};_bebb +=_fdba .BytesPerLine ;};};if _debf {for _ebbc =0;_ebbc < _efca ;_ebbc ++{_fdba .Data [_caag ]=_gceb (_fdba .Data [_caag ],0xff,_dfef );
_caag +=_fdba .BytesPerLine ;};};case PixNotDst :for _ebbc =0;_ebbc < _efca ;_ebbc ++{_fdba .Data [_dgb ]=_gceb (_fdba .Data [_dgb ],^_fdba .Data [_dgb ],_def );_dgb +=_fdba .BytesPerLine ;};if _eace {for _ebbc =0;_ebbc < _efca ;_ebbc ++{for _ceeg =0;_ceeg < _efbc ;
_ceeg ++{_fdba .Data [_bebb +_ceeg ]=^(_fdba .Data [_bebb +_ceeg ]);};_bebb +=_fdba .BytesPerLine ;};};if _debf {for _ebbc =0;_ebbc < _efca ;_ebbc ++{_fdba .Data [_caag ]=_gceb (_fdba .Data [_caag ],^_fdba .Data [_caag ],_dfef );_caag +=_fdba .BytesPerLine ;
};};};};func (_ebe *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_ebe .Width ,_ebe .Data ,_ebe .Decode );};var (Gray2Model =_g .ModelFunc (_fbaf );Gray4Model =_g .ModelFunc (_gfgf );NRGBA16Model =_g .ModelFunc (_aggd ););type colorConverter struct{_bgf func (_aecb _gg .Image )(Image ,error );
};func (_dgc *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_dgc .Width ||y >=_dgc .Height {return ;};_fcb :=Gray4Model .Convert (c ).(_g .Gray );_dgc .setGray (x ,y ,_fcb );};func (_acce *RGBA32 )setRGBA (_cabe int ,_efbad _g .RGBA ){_fcac :=3*_cabe ;_acce .Data [_fcac ]=_efbad .R ;
_acce .Data [_fcac +1]=_efbad .G ;_acce .Data [_fcac +2]=_efbad .B ;if _cabe < len (_acce .Alpha ){_acce .Alpha [_cabe ]=_efbad .A ;};};func (_eaa *Gray8 )Validate ()error {if len (_eaa .Data )!=_eaa .Height *_eaa .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type shift int ;func (_gabb colorConverter )Convert (src _gg .Image )(Image ,error ){return _gabb ._bgf (src )};func _bbce (_geda _g .NRGBA )_g .RGBA {_fecg ,_cge ,_acd ,_bcf :=_geda .RGBA ();return _g .RGBA {R :uint8 (_fecg >>8),G :uint8 (_cge >>8),B :uint8 (_acd >>8),A :uint8 (_bcf >>8)};
};func _fgd (_gfa Gray ,_edb CMYK ,_degc _gg .Rectangle ){for _gcf :=0;_gcf < _degc .Max .X ;_gcf ++{for _cbg :=0;_cbg < _degc .Max .Y ;_cbg ++{_bdfd :=_gfa .GrayAt (_gcf ,_cbg );_edb .SetCMYK (_gcf ,_cbg ,_gaebd (_bdfd ));};};};func (_feef *Gray2 )GrayAt (x ,y int )_g .Gray {_dcg ,_ :=ColorAtGray2BPC (x ,y ,_feef .BytesPerLine ,_feef .Data ,_feef .Decode );
return _dcg ;};func (_ccd *CMYK32 )Validate ()error {if len (_ccd .Data )!=4*_ccd .Width *_ccd .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_edeea *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_edeea .Width ,_edeea .Data ,_edeea .Alpha ,_edeea .Decode );};func _cgf (_fec *Monochrome ,_gdb int ,_bcba []byte )(_dfg *Monochrome ,_dbf error ){const _eec ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _fec ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _gdb < 1||_gdb > 4{return nil ,_f .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _fec .Height <=1{return nil ,_f .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_dfg =_gcc (_fec .Width /2,_fec .Height /2);
if _bcba ==nil {_bcba =_efg ();};_dce :=_eggg (_fec .BytesPerLine ,2*_dfg .BytesPerLine );switch _gdb {case 1:_dbf =_deeb (_fec ,_dfg ,_bcba ,_dce );case 2:_dbf =_ccb (_fec ,_dfg ,_bcba ,_dce );case 3:_dbf =_dde (_fec ,_dfg ,_bcba ,_dce );case 4:_dbf =_adf (_fec ,_dfg ,_bcba ,_dce );
};if _dbf !=nil {return nil ,_dbf ;};return _dfg ,nil ;};func (_agdb *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _fad bool ;_ccgd :=scale ;if scale < 1{_ccgd =1/scale ;_fad =true ;};_baaf :=NextPowerOf2 (uint (_ccgd ));if InDelta (float64 (_baaf ),_ccgd ,0.001){if _fad {return _agdb .ReduceBinary (_ccgd );
};return _agdb .ExpandBinary (int (_baaf ));};_geeb :=int (_bg .RoundToEven (float64 (_agdb .Width )*scale ));_fege :=int (_bg .RoundToEven (float64 (_agdb .Height )*scale ));return _agdb .ScaleLow (_geeb ,_fege );};var _ Image =&Gray16 {};type RGBA32 struct{ImageBase };
type Histogramer interface{Histogram ()[256]int ;};type monochromeModel uint8 ;func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_ga :=BytesPerLine (width ,8,1);if len (data )< _ga *height {return nil ,nil ;};_ab :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};
_abd ,_cc :=MonochromeConverter .Convert (_ab );if _cc !=nil {return nil ,_cc ;};return _abd .Base ().Data ,nil ;};var _ Image =&Gray4 {};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_bdea :=y *width +x ;
_gaab :=3*_bdea ;if _gaab +2>=len (data ){return _g .NRGBA {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agde :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bdea {_agde =alpha [_bdea ];};_cfdf ,_cff ,_egda :=data [_gaab ],data [_gaab +1],data [_gaab +2];if len (decode )==6{_cfdf =uint8 (uint32 (LinearInterpolate (float64 (_cfdf ),0,255,decode [0],decode [1]))&0xff);
_cff =uint8 (uint32 (LinearInterpolate (float64 (_cff ),0,255,decode [2],decode [3]))&0xff);_egda =uint8 (uint32 (LinearInterpolate (float64 (_egda ),0,255,decode [4],decode [5]))&0xff);};return _g .NRGBA {R :_cfdf ,G :_cff ,B :_egda ,A :_agde },nil ;};
type Gray16 struct{ImageBase };func _baac (_gagc *Monochrome ,_fdgd ,_ded int ,_dbd ,_eead int ,_becg RasterOperator ,_bggc *Monochrome ,_dbec ,_gecf int )error {var _ccbc ,_effb ,_ffgca ,_efgg int ;if _fdgd < 0{_dbec -=_fdgd ;_dbd +=_fdgd ;_fdgd =0;};
if _dbec < 0{_fdgd -=_dbec ;_dbd +=_dbec ;_dbec =0;};_ccbc =_fdgd +_dbd -_gagc .Width ;if _ccbc > 0{_dbd -=_ccbc ;};_effb =_dbec +_dbd -_bggc .Width ;if _effb > 0{_dbd -=_effb ;};if _ded < 0{_gecf -=_ded ;_eead +=_ded ;_ded =0;};if _gecf < 0{_ded -=_gecf ;
_eead +=_gecf ;_gecf =0;};_ffgca =_ded +_eead -_gagc .Height ;if _ffgca > 0{_eead -=_ffgca ;};_efgg =_gecf +_eead -_bggc .Height ;if _efgg > 0{_eead -=_efgg ;};if _dbd <=0||_eead <=0{return nil ;};var _bfb error ;switch {case _fdgd &7==0&&_dbec &7==0:_bfb =_ecdg (_gagc ,_fdgd ,_ded ,_dbd ,_eead ,_becg ,_bggc ,_dbec ,_gecf );
case _fdgd &7==_dbec &7:_bfb =_bdbdg (_gagc ,_fdgd ,_ded ,_dbd ,_eead ,_becg ,_bggc ,_dbec ,_gecf );default:_bfb =_afce (_gagc ,_fdgd ,_ded ,_dbd ,_eead ,_becg ,_bggc ,_dbec ,_gecf );};if _bfb !=nil {return _bfb ;};return nil ;};func (_deeee *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_gaae :=4*(y *_deeee .Width +x );
if _gaae +3>=len (_deeee .Data ){return ;};_deeee .Data [_gaae ]=c .C ;_deeee .Data [_gaae +1]=c .M ;_deeee .Data [_gaae +2]=c .Y ;_deeee .Data [_gaae +3]=c .K ;};func (_ddcg *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_ddcg .copy ()}};func (_cbd *Monochrome )IsUnpadded ()bool {return (_cbd .Width *_cbd .Height )==len (_cbd .Data )};
func (_bfbf *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_eeaf :=y *_bfbf .Width +x ;_cfad :=3*_eeaf ;if _cfad +2>=len (_bfbf .Data ){return ;};_bfbf .setRGBA (_eeaf ,c );};func _ccb (_fdd ,_cb *Monochrome ,_cbc []byte ,_fba int )(_bef error ){var (_aee ,_efe ,_ccfe ,_adad ,_dccb ,_dgee ,_ggg ,_fbab int ;
_bge ,_ebae ,_cgb ,_aae uint32 ;_ddg ,_aec byte ;_ddc uint16 ;);_ede :=make ([]byte ,4);_ecf :=make ([]byte ,4);for _ccfe =0;_ccfe < _fdd .Height -1;_ccfe ,_adad =_ccfe +2,_adad +1{_aee =_ccfe *_fdd .BytesPerLine ;_efe =_adad *_cb .BytesPerLine ;for _dccb ,_dgee =0,0;
_dccb < _fba ;_dccb ,_dgee =_dccb +4,_dgee +1{for _ggg =0;_ggg < 4;_ggg ++{_fbab =_aee +_dccb +_ggg ;if _fbab <=len (_fdd .Data )-1&&_fbab < _aee +_fdd .BytesPerLine {_ede [_ggg ]=_fdd .Data [_fbab ];}else {_ede [_ggg ]=0x00;};_fbab =_aee +_fdd .BytesPerLine +_dccb +_ggg ;
if _fbab <=len (_fdd .Data )-1&&_fbab < _aee +(2*_fdd .BytesPerLine ){_ecf [_ggg ]=_fdd .Data [_fbab ];}else {_ecf [_ggg ]=0x00;};};_bge =_gd .BigEndian .Uint32 (_ede );_ebae =_gd .BigEndian .Uint32 (_ecf );_cgb =_bge &_ebae ;_cgb |=_cgb <<1;_aae =_bge |_ebae ;
_aae &=_aae <<1;_ebae =_cgb |_aae ;_ebae &=0xaaaaaaaa;_bge =_ebae |(_ebae <<7);_ddg =byte (_bge >>24);_aec =byte ((_bge >>8)&0xff);_fbab =_efe +_dgee ;if _fbab +1==len (_cb .Data )-1||_fbab +1>=_efe +_cb .BytesPerLine {if _bef =_cb .setByte (_fbab ,_cbc [_ddg ]);
_bef !=nil {return _a .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fbab );};}else {_ddc =(uint16 (_cbc [_ddg ])<<8)|uint16 (_cbc [_aec ]);if _bef =_cb .setTwoBytes (_fbab ,_ddc );_bef !=nil {return _a .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fbab );
};_dgee ++;};};};return nil ;};func _ggef (_ecd _g .Gray ,_aaec monochromeModel )_g .Gray {if _ecd .Y > uint8 (_aaec ){return _g .Gray {Y :_bg .MaxUint8 };};return _g .Gray {};};var _ _gg .Image =&Monochrome {};type monochromeThresholdConverter struct{Threshold uint8 ;
};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_fdbe :=(y *width +x )*2;_gbda :=_fdbe *3;if _gbda +5>=len (data ){return _g .NRGBA64 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _bgeb =0xffff;_afde :=uint16 (_bgeb );if alpha !=nil &&len (alpha )> _fdbe +1{_afde =uint16 (alpha [_fdbe ])<<8|uint16 (alpha [_fdbe +1]);};_cgec :=uint16 (data [_gbda ])<<8|uint16 (data [_gbda +1]);_bafa :=uint16 (data [_gbda +2])<<8|uint16 (data [_gbda +3]);
_abcbg :=uint16 (data [_gbda +4])<<8|uint16 (data [_gbda +5]);if len (decode )==6{_cgec =uint16 (uint64 (LinearInterpolate (float64 (_cgec ),0,65535,decode [0],decode [1]))&_bgeb );_bafa =uint16 (uint64 (LinearInterpolate (float64 (_bafa ),0,65535,decode [2],decode [3]))&_bgeb );
_abcbg =uint16 (uint64 (LinearInterpolate (float64 (_abcbg ),0,65535,decode [4],decode [5]))&_bgeb );};return _g .NRGBA64 {R :_cgec ,G :_bafa ,B :_abcbg ,A :_afde },nil ;};func (_eddd *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_aede :=_cgce (uint (factor ));
if !IsPowerOf2 (uint (factor )){_aede ++;};_dgdg :=make ([]int ,_aede );for _fbd :=range _dgdg {_dgdg [_fbd ]=4;};_caba ,_dbb :=_cfd (_eddd ,_dgdg ...);if _dbb !=nil {return nil ,_dbb ;};return _caba ,nil ;};var _ NRGBA =&NRGBA32 {};func (_eff *Gray2 )ColorModel ()_g .Model {return Gray2Model };
func ConverterFunc (converterFunc func (_cfbgc _gg .Image )(Image ,error ))ColorConverter {return colorConverter {_bgf :converterFunc };};func _ddba (_agda nrgba64 ,_gfagb NRGBA ,_bbgga _gg .Rectangle ){for _ebac :=0;_ebac < _bbgga .Max .X ;_ebac ++{for _bfcga :=0;
_bfcga < _bbgga .Max .Y ;_bfcga ++{_cfgc :=_agda .NRGBA64At (_ebac ,_bfcga );_gfagb .SetNRGBA (_ebac ,_bfcga ,_ffec (_cfgc ));};};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_acf :=4*(y *width +x );if _acf +3>=len (data ){return _g .CMYK {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_acf ]&0xff;M :=data [_acf +1]&0xff;Y :=data [_acf +2]&0xff;K :=data [_acf +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _abf (_ceec _gg .Image )(Image ,error ){if _ffee ,_bfdg :=_ceec .(*NRGBA64 );
_bfdg {return _ffee .Copy (),nil ;};_abdd ,_ffgd ,_geg :=_ggdae (_ceec ,2);_bfbc ,_abab :=NewImage (_abdd .Max .X ,_abdd .Max .Y ,16,3,nil ,_geg ,nil );if _abab !=nil {return nil ,_abab ;};_ccgdd (_ceec ,_bfbc ,_abdd );if len (_geg )!=0&&!_ffgd {if _abgd :=_gefbb (_geg ,_bfbc );
_abgd !=nil {return nil ,_abgd ;};};return _bfbc ,nil ;};const (_dfefc shift =iota ;_dcede ;);func _cfd (_afd *Monochrome ,_ddd ...int )(_dge *Monochrome ,_adg error ){if _afd ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ddd )==0{return nil ,_f .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_fbg :=_efg ();_dge =_afd ;for _ ,_gdda :=range _ddd {if _gdda <=0{break ;};_dge ,_adg =_cgf (_dge ,_gdda ,_fbg );if _adg !=nil {return nil ,_adg ;};};return _dge ,nil ;};func (_aafd *NRGBA16 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_aafd .Width ,Y :_aafd .Height }};
};func (_bdbd *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_a .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _bda (_bdbd ,factor );};func _bda (_d *Monochrome ,_eg int )(*Monochrome ,error ){if _d ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _eg ==1{return _d .copy (),nil ;
};if !IsPowerOf2 (uint (_eg )){return nil ,_a .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eg );};_ag :=_gaeb (_eg );
return _ce (_d ,_eg ,_ag );};func (_ddf *RGBA32 )Base ()*ImageBase {return &_ddf .ImageBase };var _ _gg .Image =&NRGBA32 {};func (_eegg *Gray2 )Base ()*ImageBase {return &_eegg .ImageBase };func _gf (_aa ,_fa *Monochrome )(_gag error ){_ae :=_fa .BytesPerLine ;
_dad :=_aa .BytesPerLine ;var _bgac ,_ba ,_agc ,_ccff ,_bf int ;for _agc =0;_agc < _fa .Height ;_agc ++{_bgac =_agc *_ae ;_ba =8*_agc *_dad ;for _ccff =0;_ccff < _ae ;_ccff ++{if _gag =_aa .setEightBytes (_ba +_ccff *8,_aea [_fa .Data [_bgac +_ccff ]]);
_gag !=nil {return _gag ;};};for _bf =1;_bf < 8;_bf ++{for _ccff =0;_ccff < _dad ;_ccff ++{if _gag =_aa .setByte (_ba +_bf *_dad +_ccff ,_aa .Data [_ba +_ccff ]);_gag !=nil {return _gag ;};};};};return nil ;};func (_adgb *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_adgb .BytesPerLine ,_adgb .Data ,_adgb .Decode );
};func (_bgafg *ImageBase )setEightPartlyBytes (_ddag ,_fcgfb int ,_bgbg uint64 )(_cbcc error ){var (_agcg byte ;_bbdb int ;);for _fccb :=1;_fccb <=_fcgfb ;_fccb ++{_bbdb =64-_fccb *8;_agcg =byte (_bgbg >>uint (_bbdb )&0xff);if _cbcc =_bgafg .setByte (_ddag +_fccb -1,_agcg );
_cbcc !=nil {return _cbcc ;};};_bfggd :=_bgafg .BytesPerLine *8-_bgafg .Width ;if _bfggd ==0{return nil ;};_bbdb -=8;_agcg =byte (_bgbg >>uint (_bbdb )&0xff)<<uint (_bfggd );if _cbcc =_bgafg .setByte (_ddag +_fcgfb ,_agcg );_cbcc !=nil {return _cbcc ;};
return nil ;};func (_bgd *Gray2 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_bgd .Width ,Y :_bgd .Height }};};func _deeb (_edd ,_fbge *Monochrome ,_fgac []byte ,_afe int )(_eba error ){var (_abdc ,_ec ,_eabe ,_dag ,_ace ,_acb ,_aag ,_gdge int ;
_gbgb ,_fcg uint32 ;_gga ,_age byte ;_fae uint16 ;);_gaa :=make ([]byte ,4);_dac :=make ([]byte ,4);for _eabe =0;_eabe < _edd .Height -1;_eabe ,_dag =_eabe +2,_dag +1{_abdc =_eabe *_edd .BytesPerLine ;_ec =_dag *_fbge .BytesPerLine ;for _ace ,_acb =0,0;
_ace < _afe ;_ace ,_acb =_ace +4,_acb +1{for _aag =0;_aag < 4;_aag ++{_gdge =_abdc +_ace +_aag ;if _gdge <=len (_edd .Data )-1&&_gdge < _abdc +_edd .BytesPerLine {_gaa [_aag ]=_edd .Data [_gdge ];}else {_gaa [_aag ]=0x00;};_gdge =_abdc +_edd .BytesPerLine +_ace +_aag ;
if _gdge <=len (_edd .Data )-1&&_gdge < _abdc +(2*_edd .BytesPerLine ){_dac [_aag ]=_edd .Data [_gdge ];}else {_dac [_aag ]=0x00;};};_gbgb =_gd .BigEndian .Uint32 (_gaa );_fcg =_gd .BigEndian .Uint32 (_dac );_fcg |=_gbgb ;_fcg |=_fcg <<1;_fcg &=0xaaaaaaaa;
_gbgb =_fcg |(_fcg <<7);_gga =byte (_gbgb >>24);_age =byte ((_gbgb >>8)&0xff);_gdge =_ec +_acb ;if _gdge +1==len (_fbge .Data )-1||_gdge +1>=_ec +_fbge .BytesPerLine {_fbge .Data [_gdge ]=_fgac [_gga ];}else {_fae =(uint16 (_fgac [_gga ])<<8)|uint16 (_fgac [_age ]);
if _eba =_fbge .setTwoBytes (_gdge ,_fae );_eba !=nil {return _a .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gdge );
};_acb ++;};};};return nil ;};func (_gfcg *Monochrome )At (x ,y int )_g .Color {_efdd ,_ :=_gfcg .ColorAt (x ,y );return _efdd };func _bccf (_ead ,_aaef CMYK ,_aagf _gg .Rectangle ){for _cba :=0;_cba < _aagf .Max .X ;_cba ++{for _bbba :=0;_bbba < _aagf .Max .Y ;
_bbba ++{_aaef .SetCMYK (_cba ,_bbba ,_ead .CMYKAt (_cba ,_bbba ));};};};func _ccc (_bfed _g .NYCbCrA )_g .NRGBA {_aebd :=int32 (_bfed .Y )*0x10101;_fagc :=int32 (_bfed .Cb )-128;_dfa :=int32 (_bfed .Cr )-128;_dgaa :=_aebd +91881*_dfa ;if uint32 (_dgaa )&0xff000000==0{_dgaa >>=8;
}else {_dgaa =^(_dgaa >>31)&0xffff;};_agef :=_aebd -22554*_fagc -46802*_dfa ;if uint32 (_agef )&0xff000000==0{_agef >>=8;}else {_agef =^(_agef >>31)&0xffff;};_dafc :=_aebd +116130*_fagc ;if uint32 (_dafc )&0xff000000==0{_dafc >>=8;}else {_dafc =^(_dafc >>31)&0xffff;
};return _g .NRGBA {R :uint8 (_dgaa >>8),G :uint8 (_agef >>8),B :uint8 (_dafc >>8),A :_bfed .A };};func (_dec *Gray4 )ColorModel ()_g .Model {return Gray4Model };func (_cecb *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_egggf ,_ :=ColorAtNRGBA16 (x ,y ,_cecb .Width ,_cecb .BytesPerLine ,_cecb .Data ,_cecb .Alpha ,_cecb .Decode );
return _egggf ;};func _fge (_daf *Monochrome ,_ef ,_dc int )(*Monochrome ,error ){if _daf ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ef <=0||_dc <=0{return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _ef ==_dc {if _ef ==1{return _daf .copy (),nil ;};if _ef ==2||_ef ==4||_ef ==8{_dg ,_gbb :=_bda (_daf ,_ef );if _gbb !=nil {return nil ,_gbb ;};return _dg ,nil ;};};_fac :=_ef *_daf .Width ;_dcc :=_dc *_daf .Height ;_bdab :=_gcc (_fac ,_dcc );_dae :=_bdab .BytesPerLine ;
var (_bfe ,_gfg ,_aca ,_fed ,_gae int ;_fbc byte ;_ega error ;);for _gfg =0;_gfg < _daf .Height ;_gfg ++{_bfe =_dc *_gfg *_dae ;for _aca =0;_aca < _daf .Width ;_aca ++{if _cf :=_daf .getBitAt (_aca ,_gfg );_cf {_gae =_ef *_aca ;for _fed =0;_fed < _ef ;
_fed ++{_bdab .setIndexedBit (_bfe *8+_gae +_fed );};};};for _fed =1;_fed < _dc ;_fed ++{_ceb :=_bfe +_fed *_dae ;for _aeb :=0;_aeb < _dae ;_aeb ++{if _fbc ,_ega =_bdab .getByte (_bfe +_aeb );_ega !=nil {return nil ,_ega ;};if _ega =_bdab .setByte (_ceb +_aeb ,_fbc );
_ega !=nil {return nil ,_ega ;};};};};return _bdab ,nil ;};var (MonochromeConverter =ConverterFunc (_aeed );Gray2Converter =ConverterFunc (_dgfe );Gray4Converter =ConverterFunc (_fbad );GrayConverter =ConverterFunc (_bfcgd );Gray16Converter =ConverterFunc (_bcff );
NRGBA16Converter =ConverterFunc (_edba );NRGBAConverter =ConverterFunc (_bbdcc );NRGBA64Converter =ConverterFunc (_abf );RGBAConverter =ConverterFunc (_geaf );CMYKConverter =ConverterFunc (_agf ););func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_fbba :=y *bytesPerLine +x *3/2;
if _fbba +1>=len (data ){return _g .NRGBA {},_egbb (x ,y );};const (_cfcb =0xf;_bgce =uint8 (0xff););_befb :=_bgce ;if alpha !=nil {_bgfb :=y *BytesPerLine (width ,4,1);if _bgfb < len (alpha ){if x %2==0{_befb =(alpha [_bgfb ]>>uint (4))&_cfcb ;}else {_befb =alpha [_bgfb ]&_cfcb ;
};_befb |=_befb <<4;};};var _eddb ,_cgbf ,_bfdc uint8 ;if x *3%2==0{_eddb =(data [_fbba ]>>uint (4))&_cfcb ;_cgbf =data [_fbba ]&_cfcb ;_bfdc =(data [_fbba +1]>>uint (4))&_cfcb ;}else {_eddb =data [_fbba ]&_cfcb ;_cgbf =(data [_fbba +1]>>uint (4))&_cfcb ;
_bfdc =data [_fbba +1]&_cfcb ;};if len (decode )==6{_eddb =uint8 (uint32 (LinearInterpolate (float64 (_eddb ),0,15,decode [0],decode [1]))&0xf);_cgbf =uint8 (uint32 (LinearInterpolate (float64 (_cgbf ),0,15,decode [2],decode [3]))&0xf);_bfdc =uint8 (uint32 (LinearInterpolate (float64 (_bfdc ),0,15,decode [4],decode [5]))&0xf);
};return _g .NRGBA {R :(_eddb <<4)|(_eddb &0xf),G :(_cgbf <<4)|(_cgbf &0xf),B :(_bfdc <<4)|(_bfdc &0xf),A :_befb },nil ;};func (_bgea *Monochrome )SetGray (x ,y int ,g _g .Gray ){_dgag :=y *_bgea .BytesPerLine +x >>3;if _dgag > len (_bgea .Data )-1{return ;
};g =_ggef (g ,monochromeModel (_bgea .ModelThreshold ));_bgea .setGray (x ,g ,_dgag );};func (_eeaa *Gray16 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_eeaa .Width ,Y :_eeaa .Height }};};func _gaac (_ccfc uint8 )bool {if _ccfc ==0||_ccfc ==255{return true ;
};return false ;};func _dgfe (_acag _gg .Image )(Image ,error ){if _daaf ,_cgbb :=_acag .(*Gray2 );_cgbb {return _daaf .Copy (),nil ;};_begfa :=_acag .Bounds ();_ced ,_ebag :=NewImage (_begfa .Max .X ,_begfa .Max .Y ,2,1,nil ,nil ,nil );if _ebag !=nil {return nil ,_ebag ;
};_fega (_acag ,_ced ,_begfa );return _ced ,nil ;};func _adf (_bae ,_efa *Monochrome ,_dbee []byte ,_fdc int )(_cab error ){var (_fecf ,_gcca ,_acc ,_agg ,_bdad ,_fgef ,_agcc ,_eee int ;_cabf ,_abg uint32 ;_egbd ,_ggf byte ;_bfc uint16 ;);_dggd :=make ([]byte ,4);
_gdgb :=make ([]byte ,4);for _acc =0;_acc < _bae .Height -1;_acc ,_agg =_acc +2,_agg +1{_fecf =_acc *_bae .BytesPerLine ;_gcca =_agg *_efa .BytesPerLine ;for _bdad ,_fgef =0,0;_bdad < _fdc ;_bdad ,_fgef =_bdad +4,_fgef +1{for _agcc =0;_agcc < 4;_agcc ++{_eee =_fecf +_bdad +_agcc ;
if _eee <=len (_bae .Data )-1&&_eee < _fecf +_bae .BytesPerLine {_dggd [_agcc ]=_bae .Data [_eee ];}else {_dggd [_agcc ]=0x00;};_eee =_fecf +_bae .BytesPerLine +_bdad +_agcc ;if _eee <=len (_bae .Data )-1&&_eee < _fecf +(2*_bae .BytesPerLine ){_gdgb [_agcc ]=_bae .Data [_eee ];
}else {_gdgb [_agcc ]=0x00;};};_cabf =_gd .BigEndian .Uint32 (_dggd );_abg =_gd .BigEndian .Uint32 (_gdgb );_abg &=_cabf ;_abg &=_abg <<1;_abg &=0xaaaaaaaa;_cabf =_abg |(_abg <<7);_egbd =byte (_cabf >>24);_ggf =byte ((_cabf >>8)&0xff);_eee =_gcca +_fgef ;
if _eee +1==len (_efa .Data )-1||_eee +1>=_gcca +_efa .BytesPerLine {_efa .Data [_eee ]=_dbee [_egbd ];if _cab =_efa .setByte (_eee ,_dbee [_egbd ]);_cab !=nil {return _a .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_eee );};}else {_bfc =(uint16 (_dbee [_egbd ])<<8)|uint16 (_dbee [_ggf ]);
if _cab =_efa .setTwoBytes (_eee ,_bfc );_cab !=nil {return _a .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eee );
};_fgef ++;};};};return nil ;};func (_bace *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_bbge ,_ :=ColorAtNRGBA64 (x ,y ,_bace .Width ,_bace .Data ,_bace .Alpha ,_bace .Decode );return _bbge ;};func _egbc (_bbdc *Monochrome ,_bced ,_bbbda int ,_gade ,_dfcf int ,_faedg RasterOperator ){var (_bff int ;
_ffdc byte ;_dggec ,_fcece int ;_fbcg int ;);_aecg :=_gade >>3;_cgcf :=_gade &7;if _cgcf > 0{_ffdc =_ffea [_cgcf ];};_bff =_bbdc .BytesPerLine *_bbbda +(_bced >>3);switch _faedg {case PixClr :for _dggec =0;_dggec < _dfcf ;_dggec ++{_fbcg =_bff +_dggec *_bbdc .BytesPerLine ;
for _fcece =0;_fcece < _aecg ;_fcece ++{_bbdc .Data [_fbcg ]=0x0;_fbcg ++;};if _cgcf > 0{_bbdc .Data [_fbcg ]=_gceb (_bbdc .Data [_fbcg ],0x0,_ffdc );};};case PixSet :for _dggec =0;_dggec < _dfcf ;_dggec ++{_fbcg =_bff +_dggec *_bbdc .BytesPerLine ;for _fcece =0;
_fcece < _aecg ;_fcece ++{_bbdc .Data [_fbcg ]=0xff;_fbcg ++;};if _cgcf > 0{_bbdc .Data [_fbcg ]=_gceb (_bbdc .Data [_fbcg ],0xff,_ffdc );};};case PixNotDst :for _dggec =0;_dggec < _dfcf ;_dggec ++{_fbcg =_bff +_dggec *_bbdc .BytesPerLine ;for _fcece =0;
_fcece < _aecg ;_fcece ++{_bbdc .Data [_fbcg ]=^_bbdc .Data [_fbcg ];_fbcg ++;};if _cgcf > 0{_bbdc .Data [_fbcg ]=_gceb (_bbdc .Data [_fbcg ],^_bbdc .Data [_fbcg ],_ffdc );};};};};func _acdb (_fcbdb *Monochrome ,_baad ,_cda ,_dfeeg ,_aff int ,_fgfc RasterOperator ){if _baad < 0{_dfeeg +=_baad ;
_baad =0;};_degea :=_baad +_dfeeg -_fcbdb .Width ;if _degea > 0{_dfeeg -=_degea ;};if _cda < 0{_aff +=_cda ;_cda =0;};_abba :=_cda +_aff -_fcbdb .Height ;if _abba > 0{_aff -=_abba ;};if _dfeeg <=0||_aff <=0{return ;};if (_baad &7)==0{_egbc (_fcbdb ,_baad ,_cda ,_dfeeg ,_aff ,_fgfc );
}else {_edaf (_fcbdb ,_baad ,_cda ,_dfeeg ,_aff ,_fgfc );};};type NRGBA64 struct{ImageBase };func (_cbfb *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func (_ffc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ffc .copy ()}};func _gfgf (_gbed _g .Color )_g .Color {_bfa :=_g .GrayModel .Convert (_gbed ).(_g .Gray );
return _ggaa (_bfa );};func (_bdabc *Monochrome )Histogram ()(_aadbg [256]int ){for _ ,_bgg :=range _bdabc .Data {_aadbg [0xff]+=int (_fggb [_bdabc .Data [_bgg ]]);};return _aadbg ;};func (_edcb *RGBA32 )At (x ,y int )_g .Color {_gged ,_ :=_edcb .ColorAt (x ,y );
return _gged };func (_efggb *NRGBA16 )Base ()*ImageBase {return &_efggb .ImageBase };func (_bggd *Monochrome )setBit (_beaf ,_edc int ){_bggd .Data [_beaf +(_edc >>3)]|=0x80>>uint (_edc &7)};var _fggb [256]uint8 ;func (_eebc *Monochrome )GrayAt (x ,y int )_g .Gray {_faaf ,_ :=ColorAtGray1BPC (x ,y ,_eebc .BytesPerLine ,_eebc .Data ,_eebc .Decode );
return _faaf ;};func (_ddacg *NRGBA16 )Validate ()error {if len (_ddacg .Data )!=3*_ddacg .Width *_ddacg .Height /2{return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _fbb ()(_bbe [256]uint32 ){for _beg :=0;_beg < 256;_beg ++{if _beg &0x01!=0{_bbe [_beg ]|=0xf;};if _beg &0x02!=0{_bbe [_beg ]|=0xf0;};if _beg &0x04!=0{_bbe [_beg ]|=0xf00;};if _beg &0x08!=0{_bbe [_beg ]|=0xf000;};if _beg &0x10!=0{_bbe [_beg ]|=0xf0000;
};if _beg &0x20!=0{_bbe [_beg ]|=0xf00000;};if _beg &0x40!=0{_bbe [_beg ]|=0xf000000;};if _beg &0x80!=0{_bbe [_beg ]|=0xf0000000;};};return _bbe ;};var (_ffea =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_eefg =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func (_dcbe *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_afdb :=y *_dcbe .Width +x ;_bgegd :=3*_afdb ;if _bgegd +2>=len (_dcbe .Data ){return ;};_dcbe .setRGBA (_afdb ,c );};func (_feg *monochromeThresholdConverter )Convert (img _gg .Image )(Image ,error ){if _ddge ,_cgg :=img .(*Monochrome );
_cgg {return _ddge .Copy (),nil ;};_aeag :=img .Bounds ();_agd ,_gbe :=NewImage (_aeag .Max .X ,_aeag .Max .Y ,1,1,nil ,nil ,nil );if _gbe !=nil {return nil ,_gbe ;};_agd .(*Monochrome ).ModelThreshold =_feg .Threshold ;for _bcfc :=0;_bcfc < _aeag .Max .X ;
_bcfc ++{for _dbed :=0;_dbed < _aeag .Max .Y ;_dbed ++{_dfgc :=img .At (_bcfc ,_dbed );_agd .Set (_bcfc ,_dbed ,_dfgc );};};return _agd ,nil ;};type Gray4 struct{ImageBase };func _bgfc (_abga _g .CMYK )_g .NRGBA {_eeb ,_cbe ,_egf :=_g .CMYKToRGB (_abga .C ,_abga .M ,_abga .Y ,_abga .K );
return _g .NRGBA {R :_eeb ,G :_cbe ,B :_egf ,A :0xff};};var _ _gg .Image =&NRGBA64 {};func _ggaa (_ffgc _g .Gray )_g .Gray {_ffgc .Y >>=4;_ffgc .Y |=_ffgc .Y <<4;return _ffgc };func _bdbdg (_ebce *Monochrome ,_bfca ,_ebfb ,_cbb ,_bgbe int ,_caaf RasterOperator ,_ccge *Monochrome ,_dabc ,_fcfff int )error {var (_gdff bool ;
_gggb bool ;_bfbg int ;_cggg int ;_fdac int ;_geac bool ;_gebf byte ;_aded int ;_fgfdg int ;_gcfa int ;_dcfdc ,_gdeg int ;);_eda :=8-(_bfca &7);_ebbd :=_eefg [_eda ];_eaec :=_ebce .BytesPerLine *_ebfb +(_bfca >>3);_cabc :=_ccge .BytesPerLine *_fcfff +(_dabc >>3);
if _cbb < _eda {_gdff =true ;_ebbd &=_ffea [8-_eda +_cbb ];};if !_gdff {_bfbg =(_cbb -_eda )>>3;if _bfbg > 0{_gggb =true ;_cggg =_eaec +1;_fdac =_cabc +1;};};_aded =(_bfca +_cbb )&7;if !(_gdff ||_aded ==0){_geac =true ;_gebf =_ffea [_aded ];_fgfdg =_eaec +1+_bfbg ;
_gcfa =_cabc +1+_bfbg ;};switch _caaf {case PixSrc :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],_ccge .Data [_cabc ],_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;
_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]=_ccge .Data [_fdac +_gdeg ];};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],_ccge .Data [_gcfa ],_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixNotSrc :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],^_ccge .Data [_cabc ],_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;
};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]=^_ccge .Data [_fdac +_gdeg ];};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],^_ccge .Data [_gcfa ],_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixSrcOrDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],_ccge .Data [_cabc ]|_ebce .Data [_eaec ],_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;
};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]|=_ccge .Data [_fdac +_gdeg ];};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],_ccge .Data [_gcfa ]|_ebce .Data [_fgfdg ],_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixSrcAndDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],_ccge .Data [_cabc ]&_ebce .Data [_eaec ],_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;
};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]&=_ccge .Data [_fdac +_gdeg ];};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],_ccge .Data [_gcfa ]&_ebce .Data [_fgfdg ],_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixSrcXorDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],_ccge .Data [_cabc ]^_ebce .Data [_eaec ],_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;
};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]^=_ccge .Data [_fdac +_gdeg ];};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],_ccge .Data [_gcfa ]^_ebce .Data [_fgfdg ],_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixNotSrcOrDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],^(_ccge .Data [_cabc ])|_ebce .Data [_eaec ],_ebbd );_eaec +=_ebce .BytesPerLine ;
_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]|=^(_ccge .Data [_fdac +_gdeg ]);};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;
_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],^(_ccge .Data [_gcfa ])|_ebce .Data [_fgfdg ],_gebf );_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixNotSrcAndDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],^(_ccge .Data [_cabc ])&_ebce .Data [_eaec ],_ebbd );
_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]&=^_ccge .Data [_fdac +_gdeg ];};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;
};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],^(_ccge .Data [_gcfa ])&_ebce .Data [_fgfdg ],_gebf );_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixSrcOrNotDst :for _dcfdc =0;
_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],_ccge .Data [_cabc ]|^(_ebce .Data [_eaec ]),_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;
_gdeg ++{_ebce .Data [_cggg +_gdeg ]=_ccge .Data [_fdac +_gdeg ]|^(_ebce .Data [_cggg +_gdeg ]);};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],_ccge .Data [_gcfa ]|^(_ebce .Data [_fgfdg ]),_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixSrcAndNotDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],_ccge .Data [_cabc ]&^(_ebce .Data [_eaec ]),_ebbd );_eaec +=_ebce .BytesPerLine ;
_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]=_ccge .Data [_fdac +_gdeg ]&^(_ebce .Data [_cggg +_gdeg ]);};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;
};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],_ccge .Data [_gcfa ]&^(_ebce .Data [_fgfdg ]),_gebf );_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixNotPixSrcOrDst :for _dcfdc =0;
_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],^(_ccge .Data [_cabc ]|_ebce .Data [_eaec ]),_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;
_gdeg ++{_ebce .Data [_cggg +_gdeg ]=^(_ccge .Data [_fdac +_gdeg ]|_ebce .Data [_cggg +_gdeg ]);};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],^(_ccge .Data [_gcfa ]|_ebce .Data [_fgfdg ]),_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixNotPixSrcAndDst :for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],^(_ccge .Data [_cabc ]&_ebce .Data [_eaec ]),_ebbd );_eaec +=_ebce .BytesPerLine ;
_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;_gdeg ++{_ebce .Data [_cggg +_gdeg ]=^(_ccge .Data [_fdac +_gdeg ]&_ebce .Data [_cggg +_gdeg ]);};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;
};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],^(_ccge .Data [_gcfa ]&_ebce .Data [_fgfdg ]),_gebf );_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};case PixNotPixSrcXorDst :for _dcfdc =0;
_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_eaec ]=_gceb (_ebce .Data [_eaec ],^(_ccge .Data [_cabc ]^_ebce .Data [_eaec ]),_ebbd );_eaec +=_ebce .BytesPerLine ;_cabc +=_ccge .BytesPerLine ;};if _gggb {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{for _gdeg =0;_gdeg < _bfbg ;
_gdeg ++{_ebce .Data [_cggg +_gdeg ]=^(_ccge .Data [_fdac +_gdeg ]^_ebce .Data [_cggg +_gdeg ]);};_cggg +=_ebce .BytesPerLine ;_fdac +=_ccge .BytesPerLine ;};};if _geac {for _dcfdc =0;_dcfdc < _bgbe ;_dcfdc ++{_ebce .Data [_fgfdg ]=_gceb (_ebce .Data [_fgfdg ],^(_ccge .Data [_gcfa ]^_ebce .Data [_fgfdg ]),_gebf );
_fgfdg +=_ebce .BytesPerLine ;_gcfa +=_ccge .BytesPerLine ;};};default:_bd .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_caaf );return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _cee (_aebc _gg .Image ,_bde Image ,_cfdg _gg .Rectangle ){for _ceg :=0;_ceg < _cfdg .Max .X ;_ceg ++{for _gda :=0;_gda < _cfdg .Max .Y ;_gda ++{_beff :=_aebc .At (_ceg ,_gda );_bde .Set (_ceg ,_gda ,_beff );};};};func (_abdcg *Gray16 )Histogram ()(_fggd [256]int ){for _bbgab :=0;
_bbgab < _abdcg .Width ;_bbgab ++{for _aafc :=0;_aafc < _abdcg .Height ;_aafc ++{_fggd [_abdcg .GrayAt (_bbgab ,_aafc ).Y ]++;};};return _fggd ;};var _ Gray =&Gray8 {};type Gray interface{GrayAt (_ggeg ,_bfgd int )_g .Gray ;SetGray (_fgda ,_gfc int ,_gca _g .Gray );
};func (_aecga *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_adee ,_ :=ColorAtRGBA32 (x ,y ,_aecga .Width ,_aecga .Data ,_aecga .Alpha ,_aecga .Decode );return _adee ;};func (_fccg *NRGBA64 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_fccg .Width ,Y :_fccg .Height }};
};func _bebag (_fgaa ,_feefg NRGBA ,_gafcb _gg .Rectangle ){for _fabfd :=0;_fabfd < _gafcb .Max .X ;_fabfd ++{for _gcd :=0;_gcd < _gafcb .Max .Y ;_gcd ++{_feefg .SetNRGBA (_fabfd ,_gcd ,_fgaa .NRGBAAt (_fabfd ,_gcd ));};};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _gefbb (_ecg []byte ,_abcb Image )error {_daad :=true ;for _bcee :=0;_bcee < len (_ecg );_bcee ++{if _ecg [_bcee ]!=0xff{_daad =false ;break ;};};if _daad {switch _cega :=_abcb .(type ){case *NRGBA32 :_cega .Alpha =nil ;case *NRGBA64 :_cega .Alpha =nil ;
default:return _a .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_abcb );
};};return nil ;};func _cgc (_ccg _g .NRGBA )_g .Gray {_aeaf ,_bdgg ,_beca ,_ :=_ccg .RGBA ();_ffce :=(19595*_aeaf +38470*_bdgg +7471*_beca +1<<15)>>24;return _g .Gray {Y :uint8 (_ffce )};};type NRGBA16 struct{ImageBase };func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ _gg .Image =&Gray2 {};func (_cfbge *CMYK32 )Base ()*ImageBase {return &_cfbge .ImageBase };func (_bea monochromeModel )Convert (c _g .Color )_g .Color {_bgeg :=_g .GrayModel .Convert (c ).(_g .Gray );return _ggef (_bgeg ,_bea );};func _afce (_dbad *Monochrome ,_beba ,_addf ,_bgdc ,_efdg int ,_ddbf RasterOperator ,_fecfd *Monochrome ,_efb ,_faf int )error {var (_agce bool ;
_bggf bool ;_bbca byte ;_fedcd int ;_cbgf int ;_bdd int ;_fccbf int ;_cbf bool ;_acbf int ;_dfad int ;_agbg int ;_dggcb bool ;_cbed byte ;_fcbb int ;_geff int ;_bdgd int ;_egag byte ;_ggdb int ;_geccg int ;_fbga uint ;_bfcgb uint ;_gfgdd byte ;_effe shift ;
_ebdg bool ;_aaae bool ;_bcg ,_abb int ;);if _efb &7!=0{_geccg =8-(_efb &7);};if _beba &7!=0{_cbgf =8-(_beba &7);};if _geccg ==0&&_cbgf ==0{_gfgdd =_eefg [0];}else {if _cbgf > _geccg {_fbga =uint (_cbgf -_geccg );}else {_fbga =uint (8-(_geccg -_cbgf ));
};_bfcgb =8-_fbga ;_gfgdd =_eefg [_fbga ];};if (_beba &7)!=0{_agce =true ;_fedcd =8-(_beba &7);_bbca =_eefg [_fedcd ];_bdd =_dbad .BytesPerLine *_addf +(_beba >>3);_fccbf =_fecfd .BytesPerLine *_faf +(_efb >>3);_ggdb =8-(_efb &7);if _fedcd > _ggdb {_effe =_dfefc ;
if _bgdc >=_geccg {_ebdg =true ;};}else {_effe =_dcede ;};};if _bgdc < _fedcd {_bggf =true ;_bbca &=_ffea [8-_fedcd +_bgdc ];};if !_bggf {_acbf =(_bgdc -_fedcd )>>3;if _acbf !=0{_cbf =true ;_dfad =_dbad .BytesPerLine *_addf +((_beba +_cbgf )>>3);_agbg =_fecfd .BytesPerLine *_faf +((_efb +_cbgf )>>3);
};};_fcbb =(_beba +_bgdc )&7;if !(_bggf ||_fcbb ==0){_dggcb =true ;_cbed =_ffea [_fcbb ];_geff =_dbad .BytesPerLine *_addf +((_beba +_cbgf )>>3)+_acbf ;_bdgd =_fecfd .BytesPerLine *_faf +((_efb +_cbgf )>>3)+_acbf ;if _fcbb > int (_bfcgb ){_aaae =true ;
};};switch _ddbf {case PixSrc :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;
};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],_egag ,_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );
_dbad .Data [_dfad +_abb ]=_egag ;};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );
};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],_egag ,_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixNotSrc :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );
};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],^_egag ,_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );
_dbad .Data [_dfad +_abb ]=^_egag ;};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );
};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],^_egag ,_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixSrcOrDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );
};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],_egag |_dbad .Data [_bdd ],_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;
_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]|=_egag ;};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;
if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],_egag |_dbad .Data [_geff ],_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixSrcAndDst :if _agce {for _bcg =0;
_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],_egag &_dbad .Data [_bdd ],_bbca );
_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]&=_egag ;
};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],_egag &_dbad .Data [_geff ],_cbed );
_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixSrcXorDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );
};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],_egag ^_dbad .Data [_bdd ],_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;
_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]^=_egag ;};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;
if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],_egag ^_dbad .Data [_geff ],_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixNotSrcOrDst :if _agce {for _bcg =0;
_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],^_egag |_dbad .Data [_bdd ],_bbca );
_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]|=^_egag ;
};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],^_egag |_dbad .Data [_geff ],_cbed );
_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixNotSrcAndDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );
};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],^_egag &_dbad .Data [_bdd ],_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;
_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]&=^_egag ;};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;
if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],^_egag &_dbad .Data [_geff ],_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixSrcOrNotDst :if _agce {for _bcg =0;
_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],_egag |^_dbad .Data [_bdd ],_bbca );
_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]=_egag |^_dbad .Data [_dfad +_abb ];
};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],_egag |^_dbad .Data [_geff ],_cbed );
_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixSrcAndNotDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );
};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],_egag &^_dbad .Data [_bdd ],_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;
_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]=_egag &^_dbad .Data [_dfad +_abb ];};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;
_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],_egag &^_dbad .Data [_geff ],_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};
_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],^(_egag |_dbad .Data [_bdd ]),_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );
_dbad .Data [_dfad +_abb ]=^(_egag |_dbad .Data [_dfad +_abb ]);};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );
};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],^(_egag |_dbad .Data [_geff ]),_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixNotPixSrcAndDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;
if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],^(_egag &_dbad .Data [_bdd ]),_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;
};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]=^(_egag &_dbad .Data [_dfad +_abb ]);};_dfad +=_dbad .BytesPerLine ;
_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],^(_egag &_dbad .Data [_geff ]),_cbed );
_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;};};case PixNotPixSrcXorDst :if _agce {for _bcg =0;_bcg < _efdg ;_bcg ++{if _effe ==_dfefc {_egag =_fecfd .Data [_fccbf ]<<_fbga ;if _ebdg {_egag =_gceb (_egag ,_fecfd .Data [_fccbf +1]>>_bfcgb ,_gfgdd );
};}else {_egag =_fecfd .Data [_fccbf ]>>_bfcgb ;};_dbad .Data [_bdd ]=_gceb (_dbad .Data [_bdd ],^(_egag ^_dbad .Data [_bdd ]),_bbca );_bdd +=_dbad .BytesPerLine ;_fccbf +=_fecfd .BytesPerLine ;};};if _cbf {for _bcg =0;_bcg < _efdg ;_bcg ++{for _abb =0;
_abb < _acbf ;_abb ++{_egag =_gceb (_fecfd .Data [_agbg +_abb ]<<_fbga ,_fecfd .Data [_agbg +_abb +1]>>_bfcgb ,_gfgdd );_dbad .Data [_dfad +_abb ]=^(_egag ^_dbad .Data [_dfad +_abb ]);};_dfad +=_dbad .BytesPerLine ;_agbg +=_fecfd .BytesPerLine ;};};if _dggcb {for _bcg =0;
_bcg < _efdg ;_bcg ++{_egag =_fecfd .Data [_bdgd ]<<_fbga ;if _aaae {_egag =_gceb (_egag ,_fecfd .Data [_bdgd +1]>>_bfcgb ,_gfgdd );};_dbad .Data [_geff ]=_gceb (_dbad .Data [_geff ],^(_egag ^_dbad .Data [_geff ]),_cbed );_geff +=_dbad .BytesPerLine ;_bdgd +=_fecfd .BytesPerLine ;
};};default:_bd .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_ddbf );return _f .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func _gcge (_eeca Gray ,_ecc NRGBA ,_dba _gg .Rectangle ){for _efac :=0;_efac < _dba .Max .X ;_efac ++{for _eea :=0;_eea < _dba .Max .Y ;_eea ++{_cegg :=_gdbb (_ecc .NRGBAAt (_efac ,_eea ));_eeca .SetGray (_efac ,_eea ,_cegg );};};};func (_gcgb *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_gcgb .BytesPerLine ,_gcgb .Data ,_gcgb .Decode );
};func _ecdg (_bce *Monochrome ,_dgeg ,_eecc ,_afgg ,_fcbd int ,_gceg RasterOperator ,_egea *Monochrome ,_bccfb ,_agb int )error {var (_aecf byte ;_bdebc int ;_eegge int ;_degcb ,_dbde int ;_abae ,_gedbf int ;);_eagc :=_afgg >>3;_eaea :=_afgg &7;if _eaea > 0{_aecf =_ffea [_eaea ];
};_bdebc =_egea .BytesPerLine *_agb +(_bccfb >>3);_eegge =_bce .BytesPerLine *_eecc +(_dgeg >>3);switch _gceg {case PixSrc :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;
_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=_egea .Data [_degcb ];_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],_egea .Data [_degcb ],_aecf );};};case PixNotSrc :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;
_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=^(_egea .Data [_degcb ]);_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],^_egea .Data [_degcb ],_aecf );};};case PixSrcOrDst :for _abae =0;
_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]|=_egea .Data [_degcb ];_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],_egea .Data [_degcb ]|_bce .Data [_dbde ],_aecf );
};};case PixSrcAndDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]&=_egea .Data [_degcb ];_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],_egea .Data [_degcb ]&_bce .Data [_dbde ],_aecf );
};};case PixSrcXorDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]^=_egea .Data [_degcb ];_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],_egea .Data [_degcb ]^_bce .Data [_dbde ],_aecf );
};};case PixNotSrcOrDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]|=^(_egea .Data [_degcb ]);_dbde ++;_degcb ++;
};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],^(_egea .Data [_degcb ])|_bce .Data [_dbde ],_aecf );};};case PixNotSrcAndDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;
for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]&=^(_egea .Data [_degcb ]);_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],^(_egea .Data [_degcb ])&_bce .Data [_dbde ],_aecf );};};case PixSrcOrNotDst :for _abae =0;
_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=_egea .Data [_degcb ]|^(_bce .Data [_dbde ]);_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],_egea .Data [_degcb ]|^(_bce .Data [_dbde ]),_aecf );
};};case PixSrcAndNotDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=_egea .Data [_degcb ]&^(_bce .Data [_dbde ]);
_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],_egea .Data [_degcb ]&^(_bce .Data [_dbde ]),_aecf );};};case PixNotPixSrcOrDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;
for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=^(_egea .Data [_degcb ]|_bce .Data [_dbde ]);_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],^(_egea .Data [_degcb ]|_bce .Data [_dbde ]),_aecf );};};case PixNotPixSrcAndDst :for _abae =0;
_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=^(_egea .Data [_degcb ]&_bce .Data [_dbde ]);_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],^(_egea .Data [_degcb ]&_bce .Data [_dbde ]),_aecf );
};};case PixNotPixSrcXorDst :for _abae =0;_abae < _fcbd ;_abae ++{_degcb =_bdebc +_abae *_egea .BytesPerLine ;_dbde =_eegge +_abae *_bce .BytesPerLine ;for _gedbf =0;_gedbf < _eagc ;_gedbf ++{_bce .Data [_dbde ]=^(_egea .Data [_degcb ]^_bce .Data [_dbde ]);
_dbde ++;_degcb ++;};if _eaea > 0{_bce .Data [_dbde ]=_gceb (_bce .Data [_dbde ],^(_egea .Data [_degcb ]^_bce .Data [_dbde ]),_aecf );};};default:_bd .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gceg );
return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _ecgc (_deda CMYK ,_ceee RGBA ,_fcbf _gg .Rectangle ){for _ffcc :=0;_ffcc < _fcbf .Max .X ;
_ffcc ++{for _agdbg :=0;_agdbg < _fcbf .Max .Y ;_agdbg ++{_aeff :=_deda .CMYKAt (_ffcc ,_agdbg );_ceee .SetRGBA (_ffcc ,_agdbg ,_bfd (_aeff ));};};};func _cgce (_dgaf uint )uint {var _acg uint ;for _dgaf !=0{_dgaf >>=1;_acg ++;};return _acg -1;};type Gray2 struct{ImageBase };
func (_ebdbe *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_ebdbe .copy ()}};func _ccdg (_gde NRGBA ,_fgcfb Gray ,_cced _gg .Rectangle ){for _gfca :=0;_gfca < _cced .Max .X ;_gfca ++{for _ffef :=0;_ffef < _cced .Max .Y ;_ffef ++{_cae :=_cgc (_gde .NRGBAAt (_gfca ,_ffef ));
_fgcfb .SetGray (_gfca ,_ffef ,_cae );};};};func (_fcgc *NRGBA32 )Validate ()error {if len (_fcgc .Data )!=3*_fcgc .Width *_fcgc .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func FromGoImage (i _gg .Image )(Image ,error ){switch _gead :=i .(type ){case Image :return _gead .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_gg .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_gg .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};type Gray8 struct{ImageBase };func ImgToBinary (i _gg .Image ,threshold uint8 )*_gg .Gray {switch _ddfe :=i .(type ){case *_gg .Gray :if _agge (_ddfe ){return _ddfe ;
};return _cbbf (_ddfe ,threshold );case *_gg .Gray16 :return _fgcb (_ddfe ,threshold );default:return _eccd (_ddfe ,threshold );};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_fbag :=y *bytesPerLine +x >>1;
if _fbag >=len (data ){return _g .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bbfe :=data [_fbag ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bbfe =uint8 (uint32 (LinearInterpolate (float64 (_bbfe ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_bbfe *17&0xff},nil ;};func (_efad *Gray16 )Base ()*ImageBase {return &_efad .ImageBase };
var _ Gray =&Gray4 {};func IsGrayImgBlackAndWhite (i *_gg .Gray )bool {return _agge (i )};func (_aece *NRGBA32 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_aece .Width ,Y :_aece .Height }};};type RGBA interface{RGBAAt (_cbgc ,_eacb int )_g .RGBA ;
SetRGBA (_fgcg ,_ggdd int ,_fafg _g .RGBA );};func (_faaag *RGBA32 )Validate ()error {if len (_faaag .Data )!=3*_faaag .Width *_faaag .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ffga *ImageBase )newAlpha (){_ebad :=BytesPerLine (_ffga .Width ,_ffga .BitsPerComponent ,1);_ffga .Alpha =make ([]byte ,_ffga .Height *_ebad );};func (_adag *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_adag .ImageBase .copy (),ModelThreshold :_adag .ModelThreshold };
};func (_fda *Gray8 )Histogram ()(_dbaa [256]int ){for _dfee :=0;_dfee < len (_fda .Data );_dfee ++{_dbaa [_fda .Data [_dfee ]]++;};return _dbaa ;};func (_bdaf *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_bdaf .Width ,_bdaf .Data ,_bdaf .Alpha ,_bdaf .Decode );
};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _bfg (_geed _g .NRGBA )_g .CMYK {_afcc ,_dfe ,_dea ,_ :=_geed .RGBA ();_cbeb ,_dead ,_bfgg ,_eabea :=_g .RGBToCMYK (uint8 (_afcc >>8),uint8 (_dfe >>8),uint8 (_dea >>8));return _g .CMYK {C :_cbeb ,M :_dead ,Y :_bfgg ,K :_eabea };
};func (_edef *Gray16 )GrayAt (x ,y int )_g .Gray {_adgd ,_ :=_edef .ColorAt (x ,y );return _g .Gray {Y :uint8 (_adgd .(_g .Gray16 ).Y >>8)};};func (_bbc *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_bbb ,_ :=ColorAtCMYK (x ,y ,_bbc .Width ,_bbc .Data ,_bbc .Decode );
return _bbb ;};func (_eeced *NRGBA32 )Set (x ,y int ,c _g .Color ){_abaed :=y *_eeced .Width +x ;_ecbd :=3*_abaed ;if _ecbd +2>=len (_eeced .Data ){return ;};_afee :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_eeced .setRGBA (_abaed ,_afee );};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_affa :=y *width +x ;
_gadcf :=3*_affa ;if _gadcf +2>=len (data ){return _g .RGBA {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cdee :=uint8 (0xff);if alpha !=nil &&len (alpha )> _affa {_cdee =alpha [_affa ];};_ebeaf ,_facf ,_ecgg :=data [_gadcf ],data [_gadcf +1],data [_gadcf +2];if len (decode )==6{_ebeaf =uint8 (uint32 (LinearInterpolate (float64 (_ebeaf ),0,255,decode [0],decode [1]))&0xff);
_facf =uint8 (uint32 (LinearInterpolate (float64 (_facf ),0,255,decode [2],decode [3]))&0xff);_ecgg =uint8 (uint32 (LinearInterpolate (float64 (_ecgg ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_ebeaf ,G :_facf ,B :_ecgg ,A :_cdee },nil ;
};func _abdg (_bgc ,_bga *Monochrome )(_fe error ){_bb :=_bga .BytesPerLine ;_gc :=_bgc .BytesPerLine ;_ebc :=_bga .BytesPerLine *4-_bgc .BytesPerLine ;var (_egg ,_ge byte ;_gab uint32 ;_ebge ,_eaf ,_cg ,_df ,_fdg ,_eab ,_ee int ;);for _cg =0;_cg < _bga .Height ;
_cg ++{_ebge =_cg *_bb ;_eaf =4*_cg *_gc ;for _df =0;_df < _bb ;_df ++{_egg =_bga .Data [_ebge +_df ];_gab =_gfd [_egg ];_eab =_eaf +_df *4;if _ebc !=0&&(_df +1)*4> _bgc .BytesPerLine {for _fdg =_ebc ;_fdg > 0;_fdg --{_ge =byte ((_gab >>uint (_fdg *8))&0xff);
_ee =_eab +(_ebc -_fdg );if _fe =_bgc .setByte (_ee ,_ge );_fe !=nil {return _fe ;};};}else if _fe =_bgc .setFourBytes (_eab ,_gab );_fe !=nil {return _fe ;};if _fe =_bgc .setFourBytes (_eaf +_df *4,_gfd [_bga .Data [_ebge +_df ]]);_fe !=nil {return _fe ;
};};for _fdg =1;_fdg < 4;_fdg ++{for _df =0;_df < _gc ;_df ++{if _fe =_bgc .setByte (_eaf +_fdg *_gc +_df ,_bgc .Data [_eaf +_df ]);_fe !=nil {return _fe ;};};};};return nil ;};type NRGBA32 struct{ImageBase };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;
MakeAlpha ();};var _ Image =&CMYK32 {};func (_daca *CMYK32 )Bounds ()_gg .Rectangle {return _gg .Rectangle {Max :_gg .Point {X :_daca .Width ,Y :_daca .Height }};};func (_cgea *Monochrome )Set (x ,y int ,c _g .Color ){_bcbd :=y *_cgea .BytesPerLine +x >>3;
if _bcbd > len (_cgea .Data )-1{return ;};_fdfe :=_cgea .ColorModel ().Convert (c ).(_g .Gray );_cgea .setGray (x ,_fdfe ,_bcbd );};func (_fcff *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_fcff .BytesPerLine ,_fcff .Data ,_fcff .Decode );
};func (_dca *Monochrome )InverseData ()error {return _dca .RasterOperation (0,0,_dca .Width ,_dca .Height ,PixNotDst ,nil ,0,0);};func (_dafge *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dafge .Width ,_dafge .Data ,_dafge .Alpha ,_dafge .Decode );
};func (_bad *Monochrome )AddPadding ()(_gadcc error ){if _gdcce :=((_bad .Width *_bad .Height )+7)>>3;len (_bad .Data )< _gdcce {return _a .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_bad .Data ),_gdcce );
};_afa :=_bad .Width %8;if _afa ==0{return nil ;};_bdgga :=_bad .Width /8;_ccdd :=_e .NewReader (_bad .Data );_gfb :=make ([]byte ,_bad .Height *_bad .BytesPerLine );_fde :=_e .NewWriterMSB (_gfb );_bcfca :=make ([]byte ,_bdgga );var (_abca int ;_cdc uint64 ;
);for _abca =0;_abca < _bad .Height ;_abca ++{if _ ,_gadcc =_ccdd .Read (_bcfca );_gadcc !=nil {return _gadcc ;};if _ ,_gadcc =_fde .Write (_bcfca );_gadcc !=nil {return _gadcc ;};if _cdc ,_gadcc =_ccdd .ReadBits (byte (_afa ));_gadcc !=nil {return _gadcc ;
};if _gadcc =_fde .WriteByte (byte (_cdc )<<uint (8-_afa ));_gadcc !=nil {return _gadcc ;};};_bad .Data =_fde .Data ();return nil ;};func (_dfcb *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dfcb .Width ,_dfcb .BytesPerLine ,_dfcb .Data ,_dfcb .Alpha ,_dfcb .Decode );
};func (_eeec *RGBA32 )Set (x ,y int ,c _g .Color ){_gece :=y *_eeec .Width +x ;_gggbc :=3*_gece ;if _gggbc +2>=len (_eeec .Data ){return ;};_ebed :=_g .RGBAModel .Convert (c ).(_g .RGBA );_eeec .setRGBA (_gece ,_ebed );};func _faed (_ggdg Gray ,_fcf nrgba64 ,_deadb _gg .Rectangle ){for _fbabf :=0;
_fbabf < _deadb .Max .X ;_fbabf ++{for _egd :=0;_egd < _deadb .Max .Y ;_egd ++{_aafe :=_gbag (_fcf .NRGBA64At (_fbabf ,_egd ));_ggdg .SetGray (_fbabf ,_egd ,_aafe );};};};func _begf (_bdb _g .CMYK )_g .Gray {_eacde ,_ggage ,_efd :=_g .CMYKToRGB (_bdb .C ,_bdb .M ,_bdb .Y ,_bdb .K );
_fag :=(19595*uint32 (_eacde )+38470*uint32 (_ggage )+7471*uint32 (_efd )+1<<7)>>16;return _g .Gray {Y :uint8 (_fag )};};func GrayHistogram (g Gray )(_afac [256]int ){switch _dafa :=g .(type ){case Histogramer :return _dafa .Histogram ();case _gg .Image :_cgbd :=_dafa .Bounds ();
for _dbaae :=0;_dbaae < _cgbd .Max .X ;_dbaae ++{for _cabca :=0;_cabca < _cgbd .Max .Y ;_cabca ++{_afac [g .GrayAt (_dbaae ,_cabca ).Y ]++;};};return _afac ;default:return [256]int {};};};