//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_ad "github.com/unidoc/unipdf/v3/common";_db "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ae "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_fecd *Encoder )dataSize ()int {return _cba *len (_fecd ._dbc )+_fecd ._fb };
func (_bd *Encoder )Init (){_bd ._gf =_gg (_gda );_bd ._aea =0x8000;_bd ._bc =0;_bd ._ab =12;_bd ._dbd =-1;_bd ._cgg =0;_bd ._fb =0;_bd ._dcc =make ([]byte ,_cba );for _dcf :=0;_dcf < len (_bd ._dccc );_dcf ++{_bd ._dccc [_dcf ]=_gg (512);};_bd ._bef =nil ;
};type Encoder struct{_bc uint32 ;_aea uint16 ;_ab ,_cgg uint8 ;_dbd int ;_ce int ;_dbc [][]byte ;_dcc []byte ;_fb int ;_gf *codingContext ;_dccc [13]*codingContext ;_bef *codingContext ;};func (_bcb *Encoder )DataSize ()int {return _bcb .dataSize ()};
func (_ed *Encoder )EncodeBitmap (bm *_db .Bitmap ,duplicateLineRemoval bool )error {_ad .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ege ,_gfg uint8 ;_afd ,_edg ,_aeb uint16 ;_ac ,_ec ,_gd byte ;_aebe ,_dcd ,_fee int ;_ff ,_cc []byte ;);for _ag :=0;_ag < bm .Height ;_ag ++{_ac ,_ec =0,0;if _ag >=2{_ac =bm .Data [(_ag -2)*bm .RowStride ];};if _ag >=1{_ec =bm .Data [(_ag -1)*bm .RowStride ];
if duplicateLineRemoval {_dcd =_ag *bm .RowStride ;_ff =bm .Data [_dcd :_dcd +bm .RowStride ];_fee =(_ag -1)*bm .RowStride ;_cc =bm .Data [_fee :_fee +bm .RowStride ];if _a .Equal (_ff ,_cc ){_gfg =_ege ^1;_ege =1;}else {_gfg =_ege ;_ege =0;};};};if duplicateLineRemoval {if _def :=_ed .encodeBit (_ed ._gf ,_af ,_gfg );
_def !=nil {return _def ;};if _ege !=0{continue ;};};_gd =bm .Data [_ag *bm .RowStride ];_afd =uint16 (_ac >>5);_edg =uint16 (_ec >>4);_ac <<=3;_ec <<=4;_aeb =0;for _aebe =0;_aebe < bm .Width ;_aebe ++{_efa :=uint32 (_afd <<11|_edg <<4|_aeb );_fce :=(_gd &0x80)>>7;
_gdf :=_ed .encodeBit (_ed ._gf ,_efa ,_fce );if _gdf !=nil {return _gdf ;};_afd <<=1;_edg <<=1;_aeb <<=1;_afd |=uint16 ((_ac &0x80)>>7);_edg |=uint16 ((_ec &0x80)>>7);_aeb |=uint16 (_fce );_eef :=_aebe %8;_eee :=_aebe /8+1;if _eef ==4&&_ag >=2{_ac =0;
if _eee < bm .RowStride {_ac =bm .Data [(_ag -2)*bm .RowStride +_eee ];};}else {_ac <<=1;};if _eef ==3&&_ag >=1{_ec =0;if _eee < bm .RowStride {_ec =bm .Data [(_ag -1)*bm .RowStride +_eee ];};}else {_ec <<=1;};if _eef ==7{_gd =0;if _eee < bm .RowStride {_gd =bm .Data [_ag *bm .RowStride +_eee ];
};}else {_gd <<=1;};_afd &=31;_edg &=127;_aeb &=15;};};return nil ;};func (_b Class )String ()string {switch _b {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_fba *Encoder )Reset (){_fba ._aea =0x8000;_fba ._bc =0;
_fba ._ab =12;_fba ._dbd =-1;_fba ._cgg =0;_fba ._bef =nil ;_fba ._gf =_gg (_gda );};func (_afe *Encoder )code1 (_ecc *codingContext ,_edf uint32 ,_dea uint16 ,_aabc byte ){if _ecc .mps (_edf )==1{_afe .codeMPS (_ecc ,_edf ,_dea ,_aabc );}else {_afe .codeLPS (_ecc ,_edf ,_dea ,_aabc );
};};func (_egdd *Encoder )emit (){if _egdd ._fb ==_cba {_egdd ._dbc =append (_egdd ._dbc ,_egdd ._dcc );_egdd ._dcc =make ([]byte ,_cba );_egdd ._fb =0;};_egdd ._dcc [_egdd ._fb ]=_egdd ._cgg ;_egdd ._fb ++;};func (_eaa *Encoder )code0 (_dbb *codingContext ,_ffc uint32 ,_fcg uint16 ,_bgb byte ){if _dbb .mps (_ffc )==0{_eaa .codeMPS (_dbb ,_ffc ,_fcg ,_bgb );
}else {_eaa .codeLPS (_dbb ,_ffc ,_fcg ,_bgb );};};func (_ddc *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _dedf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cde int64 ;for _ccf ,_dec :=range _ddc ._dbc {_ccdb ,_eae :=w .Write (_dec );
if _eae !=nil {return 0,_ae .Wrapf (_eae ,_dedf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ccf );};_cde +=int64 (_ccdb );};_ddc ._dcc =_ddc ._dcc [:_ddc ._fb ];
_cf ,_aab :=w .Write (_ddc ._dcc );if _aab !=nil {return 0,_ae .Wrap (_aab ,_dedf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cde +=int64 (_cf );return _cde ,nil ;};func (_fcf *Encoder )setBits (){_aeff :=_fcf ._bc +uint32 (_fcf ._aea );
_fcf ._bc |=0xffff;if _fcf ._bc >=_aeff {_fcf ._bc -=0x8000;};};func (_adaa *Encoder )lBlock (){if _adaa ._dbd >=0{_adaa .emit ();};_adaa ._dbd ++;_adaa ._cgg =uint8 (_adaa ._bc >>19);_adaa ._bc &=0x7ffff;_adaa ._ab =8;};func New ()*Encoder {_adg :=&Encoder {};
_adg .Init ();return _adg };func (_gdb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_acf error ){_ad .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _acf =_gdb .encodeIAID (symbolCodeLength ,value );_acf !=nil {return _ae .Wrap (_acf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fc *codingContext )flipMps (_ee uint32 ){_fc ._ef [_ee ]=1-_fc ._ef [_ee ]};
func (_aef *Encoder )encodeIAID (_dac ,_aga int )error {if _aef ._bef ==nil {_aef ._bef =_gg (1<<uint (_dac ));};_eega :=uint32 (1<<uint32 (_dac +1))-1;_aga <<=uint (32-_dac );_gcc :=uint32 (1);for _dad :=0;_dad < _dac ;_dad ++{_cfb :=_gcc &_eega ;_cb :=uint8 ((uint32 (_aga )&0x80000000)>>31);
if _gag :=_aef .encodeBit (_aef ._bef ,_cfb ,_cb );_gag !=nil {return _gag ;};_gcc =(_gcc <<1)|uint32 (_cb );_aga <<=1;};return nil ;};type codingContext struct{_ge []byte ;_ef []byte ;};type Class int ;const _af =0x9b25;func (_bf *Encoder )Refine (iTemp ,iTarget *_db .Bitmap ,ox ,oy int )error {for _afdg :=0;
_afdg < iTarget .Height ;_afdg ++{var _feec int ;_bdg :=_afdg +oy ;var (_egd ,_edd ,_fa ,_fec ,_faa uint16 ;_ccd ,_cga ,_ea ,_gdc ,_bg byte ;);if _bdg >=1&&(_bdg -1)< iTemp .Height {_ccd =iTemp .Data [(_bdg -1)*iTemp .RowStride ];};if _bdg >=0&&_bdg < iTemp .Height {_cga =iTemp .Data [_bdg *iTemp .RowStride ];
};if _bdg >=-1&&_bdg +1< iTemp .Height {_ea =iTemp .Data [(_bdg +1)*iTemp .RowStride ];};if _afdg >=1{_gdc =iTarget .Data [(_afdg -1)*iTarget .RowStride ];};_bg =iTarget .Data [_afdg *iTarget .RowStride ];_ada :=uint (6+ox );_egd =uint16 (_ccd >>_ada );
_edd =uint16 (_cga >>_ada );_fa =uint16 (_ea >>_ada );_fec =uint16 (_gdc >>6);_aa :=uint (2-ox );_ccd <<=_aa ;_cga <<=_aa ;_ea <<=_aa ;_gdc <<=2;for _feec =0;_feec < iTarget .Width ;_feec ++{_bfg :=(_egd <<10)|(_edd <<7)|(_fa <<4)|(_fec <<1)|_faa ;_bgf :=_bg >>7;
_da :=_bf .encodeBit (_bf ._gf ,uint32 (_bfg ),_bgf );if _da !=nil {return _da ;};_egd <<=1;_edd <<=1;_fa <<=1;_fec <<=1;_egd |=uint16 (_ccd >>7);_edd |=uint16 (_cga >>7);_fa |=uint16 (_ea >>7);_fec |=uint16 (_gdc >>7);_faa =uint16 (_bgf );_gc :=_feec %8;
_ded :=_feec /8+1;if _gc ==5+ox {_ccd ,_cga ,_ea =0,0,0;if _ded < iTemp .RowStride &&_bdg >=1&&(_bdg -1)< iTemp .Height {_ccd =iTemp .Data [(_bdg -1)*iTemp .RowStride +_ded ];};if _ded < iTemp .RowStride &&_bdg >=0&&_bdg < iTemp .Height {_cga =iTemp .Data [_bdg *iTemp .RowStride +_ded ];
};if _ded < iTemp .RowStride &&_bdg >=-1&&(_bdg +1)< iTemp .Height {_ea =iTemp .Data [(_bdg +1)*iTemp .RowStride +_ded ];};}else {_ccd <<=1;_cga <<=1;_ea <<=1;};if _gc ==5&&_afdg >=1{_gdc =0;if _ded < iTarget .RowStride {_gdc =iTarget .Data [(_afdg -1)*iTarget .RowStride +_ded ];
};}else {_gdc <<=1;};if _gc ==7{_bg =0;if _ded < iTarget .RowStride {_bg =iTarget .Data [_afdg *iTarget .RowStride +_ded ];};}else {_bg <<=1;};_egd &=7;_edd &=7;_fa &=7;_fec &=7;};};return nil ;};func (_abb *Encoder )encodeOOB (_cag Class )error {_bce :=_abb ._dccc [_cag ];
_ebg :=_abb .encodeBit (_bce ,1,1);if _ebg !=nil {return _ebg ;};_ebg =_abb .encodeBit (_bce ,3,0);if _ebg !=nil {return _ebg ;};_ebg =_abb .encodeBit (_bce ,6,0);if _ebg !=nil {return _ebg ;};_ebg =_abb .encodeBit (_bce ,12,0);if _ebg !=nil {return _ebg ;
};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_daf *Encoder )rBlock (){if _daf ._dbd >=0{_daf .emit ();};_daf ._dbd ++;_daf ._cgg =uint8 (_daf ._bc >>20);_daf ._bc &=0xfffff;
_daf ._ab =7;};func (_agg *Encoder )codeMPS (_bfb *codingContext ,_ccg uint32 ,_cda uint16 ,_ade byte ){_agg ._aea -=_cda ;if _agg ._aea &0x8000!=0{_agg ._bc +=uint32 (_cda );return ;};if _agg ._aea < _cda {_agg ._aea =_cda ;}else {_agg ._bc +=uint32 (_cda );
};_bfb ._ge [_ccg ]=_cfd [_ade ]._cbc ;_agg .renormalize ();};func (_aed *Encoder )codeLPS (_bae *codingContext ,_efaf uint32 ,_bfa uint16 ,_eeg byte ){_aed ._aea -=_bfa ;if _aed ._aea < _bfa {_aed ._bc +=uint32 (_bfa );}else {_aed ._aea =_bfa ;};if _cfd [_eeg ]._efac ==1{_bae .flipMps (_efaf );
};_bae ._ge [_efaf ]=_cfd [_eeg ]._ddb ;_aed .renormalize ();};func (_ga *Encoder )Flush (){_ga ._fb =0;_ga ._dbc =nil ;_ga ._dbd =-1};func _gg (_eg int )*codingContext {return &codingContext {_ge :make ([]byte ,_eg ),_ef :make ([]byte ,_eg )};};var _e =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
const (_gda =65536;_cba =20*1024;);var _ _d .WriterTo =&Encoder {};func (_dee *Encoder )renormalize (){for {_dee ._aea <<=1;_dee ._bc <<=1;_dee ._ab --;if _dee ._ab ==0{_dee .byteOut ();};if (_dee ._aea &0x8000)!=0{break ;};};};func (_aec *Encoder )flush (){_aec .setBits ();
_aec ._bc <<=_aec ._ab ;_aec .byteOut ();_aec ._bc <<=_aec ._ab ;_aec .byteOut ();_aec .emit ();if _aec ._cgg !=0xff{_aec ._dbd ++;_aec ._cgg =0xff;_aec .emit ();};_aec ._dbd ++;_aec ._cgg =0xac;_aec ._dbd ++;_aec .emit ();};type intEncRangeS struct{_dc ,_be int ;
_f ,_c uint8 ;_fe uint16 ;_de uint8 ;};var _cfd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_cd *Encoder )EncodeInteger (proc Class ,value int )(_fcd error ){_ad .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fcd =_cd .encodeInteger (proc ,value );_fcd !=nil {return _ae .Wrap (_fcd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_dd *Encoder )Final (){_dd .flush ()};func (_ece *Encoder )EncodeOOB (proc Class )(_bcf error ){_ad .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _bcf =_ece .encodeOOB (proc );_bcf !=nil {return _ae .Wrap (_bcf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_cg *codingContext )mps (_eb uint32 )int {return int (_cg ._ef [_eb ])};type state struct{_cge uint16 ;_cbc ,_ddb uint8 ;
_efac uint8 ;};func (_ba *Encoder )byteOut (){if _ba ._cgg ==0xff{_ba .rBlock ();return ;};if _ba ._bc < 0x8000000{_ba .lBlock ();return ;};_ba ._cgg ++;if _ba ._cgg !=0xff{_ba .lBlock ();return ;};_ba ._bc &=0x7ffffff;_ba .rBlock ();};func (_cdd *Encoder )encodeInteger (_eba Class ,_dgd int )error {const _ca ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _dgd > 2000000000||_dgd < -2000000000{return _ae .Errorf (_ca ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dgd );
};_afee :=_cdd ._dccc [_eba ];_ccc :=uint32 (1);var _dga int ;for ;;_dga ++{if _e [_dga ]._dc <=_dgd &&_e [_dga ]._be >=_dgd {break ;};};if _dgd < 0{_dgd =-_dgd ;};_dgd -=int (_e [_dga ]._fe );_efg :=_e [_dga ]._f ;for _eefg :=uint8 (0);_eefg < _e [_dga ]._c ;
_eefg ++{_cee :=_efg &1;if _gca :=_cdd .encodeBit (_afee ,_ccc ,_cee );_gca !=nil {return _ae .Wrap (_gca ,_ca ,"");};_efg >>=1;if _ccc &0x100> 0{_ccc =(((_ccc <<1)|uint32 (_cee ))&0x1ff)|0x100;}else {_ccc =(_ccc <<1)|uint32 (_cee );};};_dgd <<=32-_e [_dga ]._de ;
for _ffec :=uint8 (0);_ffec < _e [_dga ]._de ;_ffec ++{_bda :=uint8 ((uint32 (_dgd )&0x80000000)>>31);if _ceb :=_cdd .encodeBit (_afee ,_ccc ,_bda );_ceb !=nil {return _ae .Wrap (_ceb ,_ca ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_dgd <<=1;if _ccc &0x100!=0{_ccc =(((_ccc <<1)|uint32 (_bda ))&0x1ff)|0x100;}else {_ccc =(_ccc <<1)|uint32 (_bda );};};return nil ;};func (_ffe *Encoder )encodeBit (_edb *codingContext ,_gge uint32 ,_gb uint8 )error {const _edgc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_ffe ._ce ++;if _gge >=uint32 (len (_edb ._ge )){return _ae .Errorf (_edgc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gge );
};_aag :=_edb ._ge [_gge ];_df :=_edb .mps (_gge );_fef :=_cfd [_aag ]._cge ;_ad .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ffe ._ce ,_gb ,_aag ,_df ,_fef ,_ffe ._aea ,_ffe ._bc ,_ffe ._ab ,_ffe ._cgg ,_ffe ._dbd );
if _gb ==0{_ffe .code0 (_edb ,_gge ,_fef ,_aag );}else {_ffe .code1 (_edb ,_gge ,_fef ,_aag );};return nil ;};