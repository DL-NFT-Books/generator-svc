//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_fe "encoding/binary";_a "errors";_ae "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_agg *SubstreamReader )Align ()(_fbcb byte ){_fbcb =_agg ._dgb ;_agg ._dgb =0;return _fbcb };
func (_cdc *Writer )Write (p []byte )(int ,error ){if len (p )> _cdc .byteCapacity (){return 0,_b .EOF ;};for _ ,_fgde :=range p {if _dgbf :=_cdc .writeByte (_fgde );_dgbf !=nil {return 0,_dgbf ;};};return len (p ),nil ;};func (_gga *Writer )FinishByte (){if _gga ._fed ==0{return ;
};_gga ._fed =0;_gga ._aca ++;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ff :true }};func (_fc *BufferedWriter )Data ()[]byte {return _fc ._d };func (_gag *Reader )Read (p []byte )(_gfg int ,_dc error ){if _gag ._abbc ==0{return _gag .read (p );
};for ;_gfg < len (p );_gfg ++{if p [_gfg ],_dc =_gag .readUnalignedByte ();_dc !=nil {return 0,_dc ;};};return _gfg ,nil ;};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;Data ()[]byte ;};func (_cg *BufferedWriter )writeShiftedBytes (_ceg []byte )int {for _ ,_ccg :=range _ceg {_cg .writeByte (_ccg );
};return len (_ceg );};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};const _fca =1000*1000;
_cce :=length ;if _cce > _fca {_cce =_fca ;};_ae .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_fbb :r ,_gfb :offset ,_eda :length ,_bfe :make ([]byte ,_cce )},nil ;};func (_dbc *BufferedWriter )writeFullBytes (_bd []byte )int {_dbd :=copy (_dbc ._d [_dbc .fullOffset ():],_bd );_dbc ._daf +=_dbd ;return _dbd ;};func (_gff *Reader )ReadBit ()(_dfg int ,_baaf error ){_fee ,_baaf :=_gff .readBool ();
if _baaf !=nil {return 0,_baaf ;};if _fee {_dfg =1;};return _dfg ,nil ;};func (_ea *BufferedWriter )fullOffset ()int {_cbg :=_ea ._daf ;if _ea ._da !=0{_cbg ++;};return _cbg ;};func (_fbe *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_fbe ._acf =uint64 (offset );
case _b .SeekCurrent :_fbe ._acf +=uint64 (offset );case _b .SeekEnd :_fbe ._acf =_fbe ._eda +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_fbe ._dgb =0;return int64 (_fbe ._acf ),nil ;};func _gfge (_gda ,_eef uint64 )uint64 {if _gda < _eef {return _gda ;};return _eef ;};func (_ddf *Reader )read (_bff []byte )(int ,error ){if _ddf ._acbe >=int64 (len (_ddf ._bc )){return 0,_b .EOF ;};_ddf ._ccd =-1;
_gc :=copy (_bff ,_ddf ._bc [_ddf ._acbe :]);_ddf ._acbe +=int64 (_gc );return _gc ,nil ;};func (_bed *SubstreamReader )fillBuffer ()error {if uint64 (_bed ._fbb .StreamPosition ())!=_bed ._acf +_bed ._gfb {_ ,_ggc :=_bed ._fbb .Seek (int64 (_bed ._acf +_bed ._gfb ),_b .SeekStart );
if _ggc !=nil {return _ggc ;};};_bed ._faa =_bed ._acf ;_egg :=_gfge (uint64 (len (_bed ._bfe )),_bed ._eda -_bed ._acf );_dcb :=make ([]byte ,_egg );_ebfc ,_cgf :=_bed ._fbb .Read (_dcb );if _cgf !=nil {return _cgf ;};for _bbb :=uint64 (0);_bbb < _egg ;
_bbb ++{_bed ._bfe [_bbb ]=_dcb [_bbb ];};_bed ._ffe =_bed ._faa +uint64 (_ebfc );return nil ;};const (_gf =64;_c =int (^uint (0)>>1););func NewReader (data []byte )*Reader {return &Reader {_bc :data }};func (_ebf *Reader )readBool ()(_gfe bool ,_ffb error ){if _ebf ._abbc ==0{_ebf ._fag ,_ffb =_ebf .readBufferByte ();
if _ffb !=nil {return false ,_ffb ;};_gfe =(_ebf ._fag &0x80)!=0;_ebf ._fag ,_ebf ._abbc =_ebf ._fag &0x7f,7;return _gfe ,nil ;};_ebf ._abbc --;_gfe =(_ebf ._fag &(1<<_ebf ._abbc ))!=0;_ebf ._fag &=1<<_ebf ._abbc -1;return _gfe ,nil ;};func (_fgf *Writer )ResetBit (){_fgf ._fed =0};
func (_ed *BufferedWriter )FinishByte (){if _ed ._da ==0{return ;};_ed ._da =0;_ed ._daf ++;};func (_cfb *BufferedWriter )expandIfNeeded (_eecf int ){if !_cfb .tryGrowByReslice (_eecf ){_cfb .grow (_eecf );};};func (_gfd *Reader )readBufferByte ()(byte ,error ){if _gfd ._acbe >=int64 (len (_gfd ._bc )){return 0,_b .EOF ;
};_gfd ._ccd =-1;_aac :=_gfd ._bc [_gfd ._acbe ];_gfd ._acbe ++;_gfd ._dfe =int (_aac );return _aac ,nil ;};func (_fbc *Reader )Align ()(_adf byte ){_adf =_fbc ._abbc ;_fbc ._abbc =0;return _adf };func (_ce *BufferedWriter )ResetBitIndex (){_ce ._da =0};
var _ _b .Writer =&BufferedWriter {};func (_bg *SubstreamReader )ReadBits (n byte )(_cae uint64 ,_ggd error ){if n < _bg ._dgb {_ffca :=_bg ._dgb -n ;_cae =uint64 (_bg ._gg >>_ffca );_bg ._gg &=1<<_ffca -1;_bg ._dgb =_ffca ;return _cae ,nil ;};if n > _bg ._dgb {if _bg ._dgb > 0{_cae =uint64 (_bg ._gg );
n -=_bg ._dgb ;};var _fcf byte ;for n >=8{_fcf ,_ggd =_bg .readBufferByte ();if _ggd !=nil {return 0,_ggd ;};_cae =_cae <<8+uint64 (_fcf );n -=8;};if n > 0{if _bg ._gg ,_ggd =_bg .readBufferByte ();_ggd !=nil {return 0,_ggd ;};_ded :=8-n ;_cae =_cae <<n +uint64 (_bg ._gg >>_ded );
_bg ._gg &=1<<_ded -1;_bg ._dgb =_ded ;}else {_bg ._dgb =0;};return _cae ,nil ;};_bg ._dgb =0;return uint64 (_bg ._gg ),nil ;};func (_bcb *SubstreamReader )readBufferByte ()(byte ,error ){if _bcb ._acf >=_bcb ._eda {return 0,_b .EOF ;};if _bcb ._acf >=_bcb ._ffe ||_bcb ._acf < _bcb ._faa {if _ggf :=_bcb .fillBuffer ();
_ggf !=nil {return 0,_ggf ;};};_dca :=_bcb ._bfe [_bcb ._acf -_bcb ._faa ];_bcb ._acf ++;return _dca ,nil ;};func (_ddg *Writer )UseMSB ()bool {return _ddg ._fdg };func (_bf *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bf ._abbc !=0{return _bf .ReadBits (_bf ._abbc );
};return 0,nil ;};var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_bb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _g .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_bb ._d )-1< _bb ._daf {_bb .expandIfNeeded (1);};_ge :=_bb ._da ;if _bb ._ff {_ge =7-_bb ._da ;};_bb ._d [_bb ._daf ]|=byte (uint16 (bit <<_ge )&0xff);_bb ._da ++;if _bb ._da ==8{_bb ._daf ++;_bb ._da =0;};return nil ;};func (_aaa *SubstreamReader )BitPosition ()int {return int (_aaa ._dgb )};
func (_aegg *Reader )ReadUint32 ()(uint32 ,error ){_afb :=make ([]byte ,4);_ ,_bdg :=_aegg .Read (_afb );if _bdg !=nil {return 0,_bdg ;};return _fe .BigEndian .Uint32 (_afb ),nil ;};type BitWriter interface{WriteBit (_fg int )error ;WriteBits (_acb uint64 ,_baa int )(_dbdg int ,_gd error );
FinishByte ();SkipBits (_efb int )error ;};func NewWriter (data []byte )*Writer {return &Writer {_cced :data }};func (_eeg *Reader )Reset (){_eeg ._acbe =_eeg ._add ;_eeg ._abbc =_eeg ._bad ;_eeg ._fag =_eeg ._egee ;_eeg ._dfe =_eeg ._dfd ;};func (_dgc *SubstreamReader )Mark (){_dgc ._aeae =_dgc ._acf ;
_dgc ._dee =_dgc ._dgb };func (_eg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ef :=int (_eg ._da )+skip ;if _ef >=0&&_ef < 8{_eg ._da =uint8 (_ef );return nil ;};_ef =int (_eg ._da )+_eg ._daf *8+skip ;if _ef < 0{return _g .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cb :=_ef /8;_fa :=_ef %8;_eg ._da =uint8 (_fa );if _ba :=_cb -_eg ._daf ;_ba > 0&&len (_eg ._d )-1< _cb {if _eg ._da !=0{_ba ++;};_eg .expandIfNeeded (_ba );};_eg ._daf =_cb ;return nil ;};func (_caf *SubstreamReader )Read (b []byte )(_dgg int ,_bfa error ){if _caf ._acf >=_caf ._eda {_ae .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_caf ._acf ,_caf ._eda );
return 0,_b .EOF ;};for ;_dgg < len (b );_dgg ++{if b [_dgg ],_bfa =_caf .readUnalignedByte ();_bfa !=nil {if _bfa ==_b .EOF {return _dgg ,nil ;};return 0,_bfa ;};};return _dgg ,nil ;};func (_cd *BufferedWriter )grow (_eaf int ){if _cd ._d ==nil &&_eaf < _gf {_cd ._d =make ([]byte ,_eaf ,_gf );
return ;};_dg :=len (_cd ._d );if _cd ._da !=0{_dg ++;};_aa :=cap (_cd ._d );switch {case _eaf <=_aa /2-_dg :_ae .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_cd ._d ),cap (_cd ._d ),_eaf );
_ae .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_aa ,_dg );copy (_cd ._d ,_cd ._d [_cd .fullOffset ():]);
case _aa > _c -_aa -_eaf :_ae .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cbc :=make ([]byte ,2*_aa +_eaf );copy (_cbc ,_cd ._d );_cd ._d =_cbc ;};_cd ._d =_cd ._d [:_dg +_eaf ];
};type SubstreamReader struct{_acf uint64 ;_fbb StreamReader ;_gfb uint64 ;_eda uint64 ;_bfe []byte ;_faa uint64 ;_ffe uint64 ;_gg byte ;_dgb byte ;_aeae uint64 ;_dee byte ;};func (_cca *SubstreamReader )readUnalignedByte ()(_ffba byte ,_egc error ){_badb :=_cca ._dgb ;
_ffba =_cca ._gg <<(8-_badb );_cca ._gg ,_egc =_cca .readBufferByte ();if _egc !=nil {return 0,_egc ;};_ffba |=_cca ._gg >>_badb ;_cca ._gg &=1<<_badb -1;return _ffba ,nil ;};func (_dag *SubstreamReader )readBool ()(_dadc bool ,_geg error ){if _dag ._dgb ==0{_dag ._gg ,_geg =_dag .readBufferByte ();
if _geg !=nil {return false ,_geg ;};_dadc =(_dag ._gg &0x80)!=0;_dag ._gg ,_dag ._dgb =_dag ._gg &0x7f,7;return _dadc ,nil ;};_dag ._dgb --;_dadc =(_dag ._gg &(1<<_dag ._dgb ))!=0;_dag ._gg &=1<<_dag ._dgb -1;return _dadc ,nil ;};func (_eec *BufferedWriter )Write (d []byte )(int ,error ){_eec .expandIfNeeded (len (d ));
if _eec ._da ==0{return _eec .writeFullBytes (d ),nil ;};return _eec .writeShiftedBytes (d ),nil ;};func (_aeg *Reader )Length ()uint64 {return uint64 (len (_aeg ._bc ))};func (_dbf *SubstreamReader )Offset ()uint64 {return _dbf ._gfb };func (_efa *SubstreamReader )Reset (){_efa ._acf =_efa ._aeae ;
_efa ._dgb =_efa ._dee };func (_ddc *Writer )WriteBits (bits uint64 ,number int )(_age int ,_edc error ){const _eba ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_g .Errorf (_eba ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_abc :=number /8;if _abc > 0{_afed :=number -_abc *8;for _dga :=_abc -1;_dga >=0;_dga --{_aafc :=byte ((bits >>uint (_dga *8+_afed ))&0xff);if _edc =_ddc .WriteByte (_aafc );_edc !=nil {return _age ,_g .Wrapf (_edc ,_eba ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_abc -_dga +1);
};};number -=_abc *8;if number ==0{return _abc ,nil ;};};var _ebb int ;for _bec :=0;_bec < number ;_bec ++{if _ddc ._fdg {_ebb =int ((bits >>uint (number -1-_bec ))&0x1);}else {_ebb =int (bits &0x1);bits >>=1;};if _edc =_ddc .WriteBit (_ebb );_edc !=nil {return _age ,_g .Wrapf (_edc ,_eba ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bec );
};};return _abc ,nil ;};func (_cdb *Writer )Data ()[]byte {return _cdb ._cced };func (_ebe *Reader )Mark (){_ebe ._add =_ebe ._acbe ;_ebe ._bad =_ebe ._abbc ;_ebe ._egee =_ebe ._fag ;_ebe ._dfd =_ebe ._dfe ;};func (_egec *SubstreamReader )ReadBool ()(bool ,error ){return _egec .readBool ()};
func (_cc *BufferedWriter )WriteBits (bits uint64 ,number int )(_ad int ,_abb error ){const _gb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_g .Errorf (_gb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bbd :=number /8;if _bbd > 0{_cbb :=number -_bbd *8;for _cf :=_bbd -1;_cf >=0;_cf --{_ag :=byte ((bits >>uint (_cf *8+_cbb ))&0xff);if _abb =_cc .WriteByte (_ag );_abb !=nil {return _ad ,_g .Wrapf (_abb ,_gb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bbd -_cf +1);
};};number -=_bbd *8;if number ==0{return _bbd ,nil ;};};var _ada int ;for _ga :=0;_ga < number ;_ga ++{if _cc ._ff {_ada =int ((bits >>uint (number -1-_ga ))&0x1);}else {_ada =int (bits &0x1);bits >>=1;};if _abb =_cc .WriteBit (_ada );_abb !=nil {return _ad ,_g .Wrapf (_abb ,_gb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ga );
};};return _bbd ,nil ;};func (_bbf *Writer )byteCapacity ()int {_dda :=len (_bbf ._cced )-_bbf ._aca ;if _bbf ._fed !=0{_dda --;};return _dda ;};func (_egef *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_egef ._ccd =-1;var _aea int64 ;switch whence {case _b .SeekStart :_aea =offset ;
case _b .SeekCurrent :_aea =_egef ._acbe +offset ;case _b .SeekEnd :_aea =int64 (len (_egef ._bc ))+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _aea < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_egef ._acbe =_aea ;
_egef ._abbc =0;return _aea ,nil ;};func (_fec *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cff :=make ([]byte ,4);_ ,_ccf :=_fec .Read (_cff );if _ccf !=nil {return 0,_ccf ;};return _fe .BigEndian .Uint32 (_cff ),nil ;};func (_bdc *Writer )SkipBits (skip int )error {const _agf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_ccab :=int (_bdc ._fed )+skip ;if _ccab >=0&&_ccab < 8{_bdc ._fed =uint8 (_ccab );return nil ;};_ccab =int (_bdc ._fed )+_bdc ._aca *8+skip ;if _ccab < 0{return _g .Errorf (_agf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_egb :=_ccab /8;_dbdd :=_ccab %8;_ae .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_ae .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bdc ._fed ,_bdc ._aca ,int (_bdc ._fed )+(_bdc ._aca )*8,len (_bdc ._cced ),cap (_bdc ._cced ));
_ae .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ccab ,_dbdd );_bdc ._fed =uint8 (_dbdd );
if _gee :=_egb -_bdc ._aca ;_gee > 0&&len (_bdc ._cced )-1< _egb {_ae .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gee );return _g .Errorf (_agf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bdc ._aca =_egb ;_ae .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bdc ._fed ,_bdc ._aca );return nil ;};func (_bffb *Writer )WriteByte (c byte )error {return _bffb .writeByte (c )};
func (_ace *BufferedWriter )tryGrowByReslice (_df int )bool {if _af :=len (_ace ._d );_df <=cap (_ace ._d )-_af {_ace ._d =_ace ._d [:_af +_df ];return true ;};return false ;};var _ _b .ByteWriter =&BufferedWriter {};type BufferedWriter struct{_d []byte ;
_da uint8 ;_daf int ;_ff bool ;};func (_cee *Reader )BitPosition ()int {return int (_cee ._abbc )};func (_ddb *SubstreamReader )StreamPosition ()int64 {return int64 (_ddb ._acf )};func (_ac *BufferedWriter )byteCapacity ()int {_ege :=len (_ac ._d )-_ac ._daf ;
if _ac ._da !=0{_ege --;};return _ege ;};var _ BinaryWriter =&Writer {};func (_adb *SubstreamReader )Length ()uint64 {return _adb ._eda };var _ BinaryWriter =&BufferedWriter {};func (_aad *SubstreamReader )ReadBit ()(_fac int ,_gec error ){_ebff ,_gec :=_aad .readBool ();
if _gec !=nil {return 0,_gec ;};if _ebff {_fac =1;};return _fac ,nil ;};func (_afc *Reader )StreamPosition ()int64 {return _afc ._acbe };func (_fb *BufferedWriter )writeByte (_db byte ){switch {case _fb ._da ==0:_fb ._d [_fb ._daf ]=_db ;_fb ._daf ++;case _fb ._ff :_fb ._d [_fb ._daf ]|=_db >>_fb ._da ;
_fb ._daf ++;_fb ._d [_fb ._daf ]=byte (uint16 (_db )<<(8-_fb ._da )&0xff);default:_fb ._d [_fb ._daf ]|=byte (uint16 (_db )<<_fb ._da &0xff);_fb ._daf ++;_fb ._d [_fb ._daf ]=_db >>(8-_fb ._da );};};func (_be *BufferedWriter )Reset (){_be ._d =_be ._d [:0];
_be ._daf =0;_be ._da =0};func (_bdf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bdf .writeBit (uint8 (bit ));};return _g .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fge byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
StreamPosition ()int64 ;};func (_ca *Reader )ReadBool ()(bool ,error ){return _ca .readBool ()};func (_fbf *Reader )ReadByte ()(byte ,error ){if _fbf ._abbc ==0{return _fbf .readBufferByte ();};return _fbf .readUnalignedByte ();};func NewWriterMSB (data []byte )*Writer {return &Writer {_cced :data ,_fdg :true }};
func (_ccge *SubstreamReader )ReadByte ()(byte ,error ){if _ccge ._dgb ==0{return _ccge .readBufferByte ();};return _ccge .readUnalignedByte ();};func (_afe *Reader )ReadBits (n byte )(_ffc uint64 ,_bcd error ){if n < _afe ._abbc {_aegb :=_afe ._abbc -n ;
_ffc =uint64 (_afe ._fag >>_aegb );_afe ._fag &=1<<_aegb -1;_afe ._abbc =_aegb ;return _ffc ,nil ;};if n > _afe ._abbc {if _afe ._abbc > 0{_ffc =uint64 (_afe ._fag );n -=_afe ._abbc ;};for n >=8{_dbe ,_dd :=_afe .readBufferByte ();if _dd !=nil {return 0,_dd ;
};_ffc =_ffc <<8+uint64 (_dbe );n -=8;};if n > 0{if _afe ._fag ,_bcd =_afe .readBufferByte ();_bcd !=nil {return 0,_bcd ;};_dad :=8-n ;_ffc =_ffc <<n +uint64 (_afe ._fag >>_dad );_afe ._fag &=1<<_dad -1;_afe ._abbc =_dad ;}else {_afe ._abbc =0;};return _ffc ,nil ;
};_afe ._abbc =0;return uint64 (_afe ._fag ),nil ;};type Writer struct{_cced []byte ;_fed uint8 ;_aca int ;_fdg bool ;};func (_ab *BufferedWriter )Len ()int {return _ab .byteCapacity ()};func (_bdfg *Writer )writeByte (_gcg byte )error {if _bdfg ._aca > len (_bdfg ._cced )-1{return _b .EOF ;
};if _bdfg ._aca ==len (_bdfg ._cced )-1&&_bdfg ._fed !=0{return _b .EOF ;};if _bdfg ._fed ==0{_bdfg ._cced [_bdfg ._aca ]=_gcg ;_bdfg ._aca ++;return nil ;};if _bdfg ._fdg {_bdfg ._cced [_bdfg ._aca ]|=_gcg >>_bdfg ._fed ;_bdfg ._aca ++;_bdfg ._cced [_bdfg ._aca ]=byte (uint16 (_gcg )<<(8-_bdfg ._fed )&0xff);
}else {_bdfg ._cced [_bdfg ._aca ]|=byte (uint16 (_gcg )<<_bdfg ._fed &0xff);_bdfg ._aca ++;_bdfg ._cced [_bdfg ._aca ]=_gcg >>(8-_bdfg ._fed );};return nil ;};func (_cad *Writer )writeBit (_gab uint8 )error {if len (_cad ._cced )-1< _cad ._aca {return _b .EOF ;
};_dcd :=_cad ._fed ;if _cad ._fdg {_dcd =7-_cad ._fed ;};_cad ._cced [_cad ._aca ]|=byte (uint16 (_gab <<_dcd )&0xff);_cad ._fed ++;if _cad ._fed ==8{_cad ._aca ++;_cad ._fed =0;};return nil ;};func (_aaf *Reader )readUnalignedByte ()(_fgd byte ,_fd error ){_de :=_aaf ._abbc ;
_fgd =_aaf ._fag <<(8-_de );_aaf ._fag ,_fd =_aaf .readBufferByte ();if _fd !=nil {return 0,_fd ;};_fgd |=_aaf ._fag >>_de ;_aaf ._fag &=1<<_de -1;return _fgd ,nil ;};type Reader struct{_bc []byte ;_fag byte ;_abbc byte ;_acbe int64 ;_dfe int ;_ccd int ;
_add int64 ;_bad byte ;_egee byte ;_dfd int ;};func (_eb *BufferedWriter )WriteByte (bt byte )error {if _eb ._daf > len (_eb ._d )-1||(_eb ._daf ==len (_eb ._d )-1&&_eb ._da !=0){_eb .expandIfNeeded (1);};_eb .writeByte (bt );return nil ;};