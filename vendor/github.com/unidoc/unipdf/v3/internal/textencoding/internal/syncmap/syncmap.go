//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _ga "sync";func (_aa *RuneStringMap )Range (f func (_bd rune ,_aab string )(_cb bool )){_aa ._cfd .RLock ();defer _aa ._cfd .RUnlock ();for _ge ,_gg :=range _aa ._fdd {if f (_ge ,_gg ){break ;};};};func (_ee *ByteRuneMap )Length ()int {_ee ._a .RLock ();
defer _ee ._a .RUnlock ();return len (_ee ._e )};func (_eecf *StringsMap )Range (f func (_ad ,_cge string )(_eea bool )){_eecf ._cfe .RLock ();defer _eecf ._cfe .RUnlock ();for _gf ,_dbb :=range _eecf ._gdg {if f (_gf ,_dbb ){break ;};};};func (_ag *RuneByteMap )Read (r rune )(byte ,bool ){_ag ._eb .RLock ();
defer _ag ._eb .RUnlock ();_bcf ,_bf :=_ag ._df [r ];return _bcf ,_bf ;};func (_bag *RuneByteMap )Length ()int {_bag ._eb .RLock ();defer _bag ._eb .RUnlock ();return len (_bag ._df );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fdd :m }};
func (_f *RuneByteMap )Write (r rune ,b byte ){_f ._eb .Lock ();defer _f ._eb .Unlock ();_f ._df [r ]=b };type RuneUint16Map struct{_fddf map[rune ]uint16 ;_cee _ga .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_eeg :=make (map[rune ]byte ,length );
return &RuneByteMap {_df :_eeg };};func (_bgf *RuneStringMap )Read (r rune )(string ,bool ){_bgf ._cfd .RLock ();defer _bgf ._cfd .RUnlock ();_ea ,_da :=_bgf ._fdd [r ];return _ea ,_da ;};func (_c *ByteRuneMap )Range (f func (_d byte ,_cf rune )(_ca bool )){_c ._a .RLock ();
defer _c ._a .RUnlock ();for _bc ,_cc :=range _c ._e {if f (_bc ,_cc ){break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ffe :m }};type RuneByteMap struct{_df map[rune ]byte ;_eb _ga .RWMutex ;};func (_ed *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ed ._cee .RLock ();
defer _ed ._cee .RUnlock ();_bage ,_gc :=_ed ._fddf [r ];return _bage ,_gc ;};func (_fda *RuneUint16Map )Length ()int {_fda ._cee .RLock ();defer _fda ._cee .RUnlock ();return len (_fda ._fddf );};func (_dg *RuneSet )Exists (r rune )bool {_dg ._ff .RLock ();
defer _dg ._ff .RUnlock ();_ ,_bcc :=_dg ._fa [r ];return _bcc ;};func (_cfdc *StringsMap )Copy ()*StringsMap {_cfdc ._cfe .RLock ();defer _cfdc ._cfe .RUnlock ();_eeeg :=map[string ]string {};for _bbb ,_dfc :=range _cfdc ._gdg {_eeeg [_bbb ]=_dfc ;};return &StringsMap {_gdg :_eeeg };
};type RuneSet struct{_fa map[rune ]struct{};_ff _ga .RWMutex ;};func (_fdde *StringsMap )Read (g string )(string ,bool ){_fdde ._cfe .RLock ();defer _fdde ._cfe .RUnlock ();_deg ,_eaf :=_fdde ._gdg [g ];return _deg ,_eaf ;};func (_fc *RuneStringMap )Write (r rune ,s string ){_fc ._cfd .Lock ();
defer _fc ._cfd .Unlock ();_fc ._fdd [r ]=s ;};func (_ccb *RuneUint16Map )Range (f func (_cbg rune ,_afc uint16 )(_gdb bool )){_ccb ._cee .RLock ();defer _ccb ._cee .RUnlock ();for _dag ,_fg :=range _ccb ._fddf {if f (_dag ,_fg ){break ;};};};func (_dae *RuneUint16Map )RangeDelete (f func (_fgg rune ,_eaa uint16 )(_db bool ,_eag bool )){_dae ._cee .Lock ();
defer _dae ._cee .Unlock ();for _bgfe ,_eff :=range _dae ._fddf {_agd ,_ggg :=f (_bgfe ,_eff );if _agd {delete (_dae ._fddf ,_bgfe );};if _ggg {break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ggb :=map[string ]string {};for _ ,_de :=range tuples {_ggb [_de .Key ]=_de .Value ;
};return &StringsMap {_gdg :_ggb };};func (_dbd *StringRuneMap )Read (g string )(rune ,bool ){_dbd ._aaf .RLock ();defer _dbd ._aaf .RUnlock ();_cac ,_eecg :=_dbd ._ffe [g ];return _cac ,_eecg ;};func (_cfb *StringRuneMap )Write (g string ,r rune ){_cfb ._aaf .Lock ();
defer _cfb ._aaf .Unlock ();_cfb ._ffe [g ]=r ;};func (_cab *RuneSet )Write (r rune ){_cab ._ff .Lock ();defer _cab ._ff .Unlock ();_cab ._fa [r ]=struct{}{};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fa :make (map[rune ]struct{},length )}};
func (_eec *RuneSet )Range (f func (_cg rune )(_cga bool )){_eec ._ff .RLock ();defer _eec ._ff .RUnlock ();for _ce :=range _eec ._fa {if f (_ce ){break ;};};};func (_eee *StringRuneMap )Length ()int {_eee ._aaf .RLock ();defer _eee ._aaf .RUnlock ();return len (_eee ._ffe );
};type RuneStringMap struct{_fdd map[rune ]string ;_cfd _ga .RWMutex ;};func (_aad *RuneStringMap )Length ()int {_aad ._cfd .RLock ();defer _aad ._cfd .RUnlock ();return len (_aad ._fdd );};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fddf :make (map[rune ]uint16 ,length )};
};func (_af *RuneSet )Length ()int {_af ._ff .RLock ();defer _af ._ff .RUnlock ();return len (_af ._fa )};type StringRuneMap struct{_ffe map[string ]rune ;_aaf _ga .RWMutex ;};type StringsTuple struct{Key ,Value string ;};type StringsMap struct{_gdg map[string ]string ;
_cfe _ga .RWMutex ;};func (_fbg *StringRuneMap )Range (f func (_gcc string ,_gdbb rune )(_dd bool )){_fbg ._aaf .RLock ();defer _fbg ._aaf .RUnlock ();for _bb ,_aaba :=range _fbg ._ffe {if f (_bb ,_aaba ){break ;};};};func (_ef *ByteRuneMap )Write (b byte ,r rune ){_ef ._a .Lock ();
defer _ef ._a .Unlock ();_ef ._e [b ]=r };func (_eg *ByteRuneMap )Read (b byte )(rune ,bool ){_eg ._a .RLock ();defer _eg ._a .RUnlock ();_b ,_gb :=_eg ._e [b ];return _b ,_gb ;};func (_bac *StringsMap )Write (g1 ,g2 string ){_bac ._cfe .Lock ();defer _bac ._cfe .Unlock ();
_bac ._gdg [g1 ]=g2 ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};type ByteRuneMap struct{_e map[byte ]rune ;_a _ga .RWMutex ;};func (_edc *RuneUint16Map )Delete (r rune ){_edc ._cee .Lock ();defer _edc ._cee .Unlock ();
delete (_edc ._fddf ,r );};func (_gaa *RuneUint16Map )Write (r rune ,g uint16 ){_gaa ._cee .Lock ();defer _gaa ._cee .Unlock ();_gaa ._fddf [r ]=g ;};func (_bg *RuneByteMap )Range (f func (_gd rune ,_ba byte )(_gbf bool )){_bg ._eb .RLock ();defer _bg ._eb .RUnlock ();
for _fd ,_fe :=range _bg ._df {if f (_fd ,_fe ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};