//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_bc "fmt";_ba "github.com/unidoc/unipdf/v3/common";_d "math";);func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ge Matrix )ScalingFactorX ()float64 {return _d .Hypot (_ge [0],_ge [1])};func (_eb *Matrix )Shear (x ,y float64 ){_eb .Concat (ShearMatrix (x ,y ))};type Matrix [9]float64 ;
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_ec Matrix )Angle ()float64 {_gc :=_d .Atan2 (-_ec [1],_ec [0]);if _gc < 0.0{_gc +=2*_d .Pi ;};return _gc /_d .Pi *180.0;};func RotationMatrix (angle float64 )Matrix {_ab :=_d .Cos (angle );
_e :=_d .Sin (angle );return NewMatrix (_ab ,_e ,-_e ,_ab ,0,0);};func (_db Point )Rotate (theta float64 )Point {_aaa :=_d .Hypot (_db .X ,_db .Y );_ceb :=_d .Atan2 (_db .Y ,_db .X );_gfe ,_efa :=_d .Sincos (_ceb +theta /180.0*_d .Pi );return Point {_aaa *_efa ,_aaa *_gfe };
};func (_afe Point )Displace (delta Point )Point {return Point {_afe .X +delta .X ,_afe .Y +delta .Y }};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_gg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_gg .clampRange ();return _gg ;};func (_eaf Matrix )Singular ()bool {return _d .Abs (_eaf [0]*_eaf [4]-_eaf [1]*_eaf [3])< _ced };func (_ef Matrix )Mult (b Matrix )Matrix {_ef .Concat (b );return _ef };func (_bg Matrix )Identity ()bool {return _bg [0]==1&&_bg [1]==0&&_bg [2]==0&&_bg [3]==0&&_bg [4]==1&&_bg [5]==0&&_bg [6]==0&&_bg [7]==0&&_bg [8]==1;
};func (_ebc *Point )Set (x ,y float64 ){_ebc .X ,_ebc .Y =x ,y };func (_cd Matrix )ScalingFactorY ()float64 {return _d .Hypot (_cd [3],_cd [4])};func (_dc Point )String ()string {return _bc .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_dc .X ,_dc .Y );
};const _acb =1e-6;func (_abg Matrix )Scale (xScale ,yScale float64 )Matrix {return _abg .Mult (ScaleMatrix (xScale ,yScale ));};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_g Matrix )Round (precision float64 )Matrix {for _a :=range _g {_g [_a ]=_d .Round (_g [_a ]/precision )*precision ;
};return _g ;};func (_cb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_dgd :=x *_cb [0]+y *_cb [3]+_cb [6];_ea :=x *_cb [1]+y *_cb [4]+_cb [7];return _dgd ,_ea ;};func (_c Matrix )String ()string {_cf ,_abc ,_be ,_f ,_cfb ,_bd :=_c [0],_c [1],_c [3],_c [4],_c [6],_c [7];
return _bc .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cf ,_abc ,_be ,_f ,_cfb ,_bd );
};func (_dgb Matrix )Unrealistic ()bool {_bbf ,_gce ,_fde ,_fa :=_d .Abs (_dgb [0]),_d .Abs (_dgb [1]),_d .Abs (_dgb [3]),_d .Abs (_dgb [4]);_adb :=_bbf > _acb &&_fa > _acb ;_gac :=_gce > _acb &&_fde > _acb ;return !(_adb ||_gac );};const _da =1.0e-6;func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_ed Matrix )Translation ()(float64 ,float64 ){return _ed [6],_ed [7]};func (_dg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_dg [0],_dg [1]=a ,b ;_dg [3],_dg [4]=c ,d ;_dg [6],_dg [7]=tx ,ty ;_dg .clampRange ();};func (_efe *Point )transformByMatrix (_aag Matrix ){_efe .X ,_efe .Y =_aag .Transform (_efe .X ,_efe .Y )};
type Point struct{X float64 ;Y float64 ;};func (_ce *Matrix )Clone ()Matrix {return NewMatrix (_ce [0],_ce [1],_ce [3],_ce [4],_ce [6],_ce [7])};func (_baf Matrix )Translate (tx ,ty float64 )Matrix {return _baf .Mult (TranslationMatrix (tx ,ty ))};func (_af Matrix )Rotate (theta float64 )Matrix {return _af .Mult (RotationMatrix (theta ))};
const _ced =1e-10;func (_aeb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_aeb .X +t *b .X ,Y :(1-t )*_aeb .Y +t *b .Y };};func (_bf *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bgd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_bf .transformByMatrix (_bgd );
};func (_eca Point )Distance (b Point )float64 {return _d .Hypot (_eca .X -b .X ,_eca .Y -b .Y )};func (_cg Matrix )Inverse ()(Matrix ,bool ){_fe ,_ae :=_cg [0],_cg [1];_bca ,_aa :=_cg [3],_cg [4];_fg ,_gf :=_cg [6],_cg [7];_cede :=_fe *_aa -_ae *_bca ;
if _d .Abs (_cede )< _da {return Matrix {},false ;};_fc ,_ad :=_aa /_cede ,-_ae /_cede ;_fd ,_ebf :=-_bca /_cede ,_fe /_cede ;_cge :=-(_fc *_fg +_fd *_gf );_aab :=-(_ad *_fg +_ebf *_gf );return NewMatrix (_fc ,_ad ,_fd ,_ebf ,_cge ,_aab ),true ;};func (_ga *Matrix )clampRange (){for _bb ,_ggd :=range _ga {if _ggd > _eg {_ba .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ggd ,_eg );
_ga [_bb ]=_eg ;}else if _ggd < -_eg {_ba .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ggd ,-_eg );_ga [_bb ]=-_eg ;};};};const _eg =1e9;func (_ac *Matrix )Concat (b Matrix ){*_ac =Matrix {b [0]*_ac [0]+b [1]*_ac [3],b [0]*_ac [1]+b [1]*_ac [4],0,b [3]*_ac [0]+b [4]*_ac [3],b [3]*_ac [1]+b [4]*_ac [4],0,b [6]*_ac [0]+b [7]*_ac [3]+_ac [6],b [6]*_ac [1]+b [7]*_ac [4]+_ac [7],1};
_ac .clampRange ();};